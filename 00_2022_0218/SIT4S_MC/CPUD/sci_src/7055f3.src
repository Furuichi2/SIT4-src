; SH7055F
; Example program for "user writing control program".
; F-ZTAT Microcomputer On-Board Purge/Write program Ver.5.0
; Copyright(C) Hitachi, Ltd. 1996-2000.
; Licensed Material of Hitachi, Ltd.
	.CPU		SH2
;DEFAULT MHZ
KHZ		.EQU		10*4*1000		; 10.00 MHZ
;KHZ		.EQU		 9*4*1000		;  9.00 MHZ
;KHZ		.EQU		 8*4*1000		;  8.00 MHZ
;KHZ		.EQU		 6*4*1000		;  6.00 MHZ
;KHZ		.EQU		 5*4*1000		;  5.00 MHZ
;
;DEFAULT WAIT LOOP TIMES
LOOP1		.EQU		1*KHZ/4000+1		; 1 usec WAIT LOOP TIMES
LOOP2		.EQU		2*KHZ/4000+1		; 2 usec WAIT LOOP TIMES
LOOP4		.EQU		4*KHZ/4000+1		; 4 usec WAIT LOOP TIMES
LOOP5		.EQU		5*KHZ/4000+1		; 5 usec WAIT LOOP TIMES
LOOP10		.EQU		10*KHZ/4000+1		; 10 usec WAIT LOOP TIMES
LOOP20		.EQU		20*KHZ/4000+1		; 20 usec WAIT LOOP TIMES
LOOP50		.EQU		50*KHZ/4000+1		; 50 usec WAIT LOOP TIMES
LOOP100		.EQU		100*KHZ/4000+1		; 100 usec WAIT LOOP TIMES
TIME10		.EQU		10*KHZ/2000		; OVER WRITE WAIT LOOP TIMES
TIME30		.EQU		30*KHZ/2000		; 1-6 WRITE TIME LOOP TIMES
TIME200		.EQU		200*KHZ/2000		; 7-1000 WRITE TIME LOOP TIMES
TIME10000	.EQU		10000*KHZ/2000		; ERASE WAIT TIME LOOP TIMES
;
;WAIT LOOP TIMES POINTER(2 BYTES)
I_WLOOP1	.EQU		0*2
I_WLOOP2	.EQU		1*2
I_WLOOP4	.EQU		2*2
I_WLOOP5	.EQU		3*2
I_WLOOP10	.EQU		4*2
I_WLOOP20	.EQU		5*2
I_WLOOP50	.EQU		6*2
I_WLOOP100	.EQU		7*2
;
;WAIT LOOP TIMES POINTER((4 BYTES)
I_WTIME10	.EQU		0*4
I_WTIME30	.EQU		1*4
I_WTIME200	.EQU		2*4
I_WTIME10000	.EQU		3*4
;
;FLASH REGISTER
FLMCR1		.EQU		H'FFFFE800	; FLASH MEMORY CONTROL REGISTER 1
FLMCR2		.EQU		H'FFFFE801	; FLASH MEMORY CONTROL REGISTER 2
EBR1		.EQU		H'FFFFE802	; ERASE BLOCK REGISTER 1
EBR2		.EQU		H'FFFFE803	; ERASE BLOCK REGISTER 2
;
SWE		.EQU		H'40		; SOFTWARE ENABLE BIT
ESU		.EQU		H'20		; ERASE SETUP BIT
PSU		.EQU		H'10		; PROGRAM SETUP BIT
EV		.EQU		H'08		; ERASE VERIFY BIT
PV		.EQU		H'04		; PROGRAM VERIFY BIT
E		.EQU		H'02		; ERASE BIT
P		.EQU		H'01		; PRGRAM BIT
SWE_N		.EQU		H'BF		; SOFTWARE ENABLE BIT CLEAR
ESU_N		.EQU		H'DF		; ERASE SETUP BIT CLEAR
PSU_N		.EQU		H'EF		; PROGRAM SETUP BIT CLEAR
EV_N		.EQU		H'F7		; ERASE VERIFY BIT CLEAR
PV_N		.EQU		H'FB		; PROGRAM VERIFY BIT CLEAR
E_N		.EQU		H'FD		; ERASE BIT CLEAR
P_N		.EQU		H'FE		; PROGRAM BIT CLEAR
;
;ADVANCED TIMER UNIT-2
TSTR		.EQU		H'FFFFF401	; TIMER START REGISTER
TCNT		.EQU		H'FFFFF430	; FREE RUNNING COUNT REGISTER 
TSR		.EQU		H'FFFFF42C	; TIMER STATUS REGISTER (BIT4 = OVF)
;
;WATCH DOG TIMER 
TCSR		.EQU		H'FFFFEC10	; TIMER CONTROL/STATUS REGISTER
RSTCSR		.EQU		H'FFFFEC12	; RESET CONTROL/STATUS REGISTER
;
;SERIAL COMMUNICATION INTERFACE CHANNEL.1
PCDR		.EQU		H'FFFFF73E	; PORT C DATA REGISTER
RXD		.EQU		H'0002		; PC1 FOR RXD1
PCCR		.EQU		H'FFFFF73C	; PORT C CONTROL REGISTER(FOR TXD1, RXD1)
SCI_REG		.EQU		H'FFFFF000	; SERIAL CHANNEL 1 REGISTER
SCISMR		.EQU		H'08		; SERIAL MODE REGISTER
SCIBRR		.EQU		H'09		; BIT RATE REGISTER
SCISCR		.EQU		H'0A		; SERIAL CONTROL REGISTER
SCITDR		.EQU		H'0B		; TRANSMIT DATA REGISTER
SCISSR		.EQU		H'0C		; SERIAL STATUS REGISTER
SCIRDR		.EQU		H'0D		; RECEIVE DATA REGISTER
;
OFP_ERR		.EQU		B'00111000	; OVERLAN, FRAMING, PARITY ERROR BIT
TEND		.EQU		B'00000100	; TRANSMIT END BIT
;
;PROGRAM RAM AREA
USER_TOP	.EQU		H'FFFF6800	; PROGRAM START ADDRESS
USER_RAM	.EQU		H'FFFF8000	; VARIABLE AREA START ADDRESS
USER_SP		.EQU		H'FFFFE000	; STACK POINTER
;
;CONSTANT DEFINATION
FLMCR_SEL	.EQU		H'00040000	; SET FLMCR2 FOR WRITE
CHK_ADR		.EQU		H'00008000	; EBR2 BLOCK START ADDRESS
ST_ADR		.EQU		H'7F		; DESIGNATED ADDRESS CHECK DATA
ACK		.EQU		H'06		; COMMUNICATION CODE(OK)
BELL		.EQU		H'07		; COMMUNICATION CODE(NG)
XON		.EQU		H'11		; COMMUNICATION CODE(CONTINUE)
OK		.EQU		H'0		; OK FLAG
NG		.EQU		H'1		; NG FLAG
WNG		.EQU		H'2		; FLASH MEMORY NG FLAG
;
;FLASH CONSTANT
MAXWT		.EQU		1000		; MAX WRITE NUMBER OF TIMES
MAXET		.EQU		100		; MAX ERASE NUMBER OF TIMES
OW_COUNT	.EQU		6		; OVER WRITE NUMBER OF TIMES
MAXBLK1		.EQU		8		; EBR1 BLOCK NUMBER
MAXBLK2		.EQU		8		; EBR2 BLOCK NUMBER
RATIO_NUM	.EQU		2		; RATIO NUMBER RECEIVE FROM HOST
CKMRATIO	.EQU		H'0004		; PERMITTED CKM RATIO INPUT
CKPRATIO	.EQU		H'0002		; PERMITTED CKP RATIO INPUT
MINKHZ		.EQU		5000		; MINIMUM PERMITTED FREQUENCY
MAXKHZ		.EQU		10000		; MAXIMUM PERMITTED FREQUENCY
WRITE_WDT	.EQU		H'A579		; WRITE WDT CLOCK(1/64 SYSTEM CLOCK)
ERASE_WDT	.EQU		H'A57F		; ERASE WDT CLOCK(1/8192 SYSTEM CLOCK)
;
;FLASH MEMORY AREA FOR CHECK SUM
START_ADDRESS	.EQU		H'00000000	; START ADDRESS OF FLASH MEMORY
END_ADDRESS	.EQU		H'0007FFFF	; END ADDRESS OF FLASH MEMORY
;
	.SECTION   RAM,DATA,LOCATE = USER_RAM
	.ALIGN	4
W_BUF			.RES.B	128		; ERASE BLOCK START ADDRESS OR WRITE DATA AREA
BUFF			.RES.B	128		; RETRY WRITE DATA AREA
OWBUFF			.RES.B	128		; OVER WRITE DATA AREA
	.ALIGN	4
COUNT			.RES.B	4		; WRITE COUNT & ERASE COUNT
;
	.ALIGN	4
VF_RET			.RES.B	4		; VERIFY RESULT
W_ADR			.RES.B	4		; WRITE ADDRESS
RESTSIZE		.RES.B	4		; WRITE DATA SIZE
E_ADR_PTR		.RES.B	4		; BLOCK ERASE ADDRESS POINTER
EVF_ST			.RES.B	4		; ERASE VERIFY START ADDRESS 
EVF_ED			.RES.B	4		; ERASE VERIFY END ADDRESS
CHKSM			.RES.B	1		; CHECKSUM OF WRITE DATA
;
	.ALIGN	4
BAUDRATE		.RES.B	4		; BAUDRATE RECEIVE FROM HOST
WORKCLK			.RES.B	4		; INPUT FREQUENCY FROM HOST
CKM_RATIO		.RES.B	2		; MASTER CLOCK RATIO FROM HOST
CKP_RATIO		.RES.B	2		; PERIPHERAL CLOCK RATIO FROM HOST
WORKBRR  		.RES.B	1		; BRR OF LOWER BRR MARGIN ERROR
;
	.ALIGN	4
CKM_FREQ		.RES.B	4		; MASTER CLOCK VALUE
CKP_FREQ		.RES.B	4		; PERIPHERAL CLOCK VALUE
;
	.ALIGN	4
WLOOP1			.RES.B	2		; 1 usec WAIT LOOP POINTER
WLOOP2			.RES.B	2		; 2 usec WAIT LOOP POINTER
WLOOP4			.RES.B	2		; 4 usec WAIT LOOP POINTER
WLOOP5			.RES.B	2		; 5 usec WAIT LOOP POINTER
WLOOP10			.RES.B	2		; 10 usec WAIT LOOP POINTER
WLOOP20			.RES.B	2		; 20 usec WAIT LOOP POINTER
WLOOP50			.RES.B	2		; 50 usec WAIT LOOP POINTER
WLOOP100		.RES.B	2		; 100 usec WAIT LOOP POINTER
;
	.ALIGN	4
WTIME10			.RES.B	4		; OVER WRITE WAIT LOOP POINTER
WTIME30			.RES.B	4		; 1-6 WRITE TIME LOOP POINTER
WTIME200		.RES.B	4		; 7-1000 WRITE TIME LOOP POINTER
WTIME10000		.RES.B	4		; ERASE WAIT TIME LOOP POINTER
;
        .SECTION  FLASH,CODE,LOCATE = USER_TOP
;
; *******************************************************************************
; * TITLE / MAIN								*
; * FUNCTION / WAIT COMMAND FROM HOST						*
; *	      "S" FOR SET BRR AND RREQUENCY					*
; *	      "W" FOR ERASE AND REWRITE FLASH MEMORY				*
; *	      "C" FOR SUM VALUE OF ALL AREA OF FLASH MEMORY			*
; * INPUT  / R0 = COMMAND FROM HOST						*
; * OUTPUT / -									*
; *******************************************************************************
MAIN		.EQU	$
		MOV.L   #USER_SP,R0
		MOV	R0,R15			; SET STACK POINTER
;
		BSR	SCI_INIT		; INITIALIZE SCI
		NOP
;
		BSR	INI_WLOOP		; SET DEFAULT WAIT LOOP TIMES
		NOP
;
INPCMD		BSR	RCV1BYTE		; RECEIVE COMMAND
		NOP
		CMP/EQ	#"S",R0			; CHECK "S"
		BF	INPCMD20		; IF NOT GO CHECK "W"
		BSR	SETUPCMD		; GO TO SET FREQUENCY AND BRR
		NOP
		BRA	INPCMD			; GO TO RECEIVE COMMAND
		NOP
;
INPCMD20	CMP/EQ	#"W",R0			; CHECK "W"
		BF	INPCMD30		; IF NOT GO CHECK "C"
		BSR	WCMD			; GO TO ERASE/WRITE FLASH MEMORY
		NOP				; 
		BRA	INPCMD			; GO TO RECEIVE COMMAND
		NOP
;
INPCMD30	CMP/EQ	#"C",R0			; CHECK "C"
		BF	INPCMD			; IF NOT "C", GO TO RECEIVE COMMAND AGAIN
		BSR	CHECKSUM		; GO TO CHECK SUM VALUE OF FLASH MEMORY
		NOP
		BRA	INPCMD			; GO TO RECEIVE COMMAND
		NOP
;
; *******************************************************************************
; * TITLE / WAIT LOOP TIMES INITIALIZATION					*
; * FUNCTION / INITIALIZE WAIT LOOP TIMES OF DEFAULT FREQUENCY			*
; * INPUT  / R0 = WAIT LOOP TIMES						*
; * OUTPUT / -									*
; *******************************************************************************
INI_WLOOP	.EQU	$
		MOV.L	#WLOOP1,R1
		MOV.W	#LOOP1,R0
		MOV.W	R0,@(I_WLOOP1,R1)	; SET WAIT LOOP TIMES
;
		MOV.W	#LOOP2,R0
		MOV.W	R0,@(I_WLOOP2,R1)
;
		MOV.W	#LOOP4,R0
		MOV.W	R0,@(I_WLOOP4,R1)
;
		MOV.W	#LOOP5,R0
		MOV.W	R0,@(I_WLOOP5,R1)
;
		MOV.W	#LOOP10,R0
		MOV.W	R0,@(I_WLOOP10,R1)
;
		MOV.W	#LOOP20,R0
		MOV.W	R0,@(I_WLOOP20,R1)
;
		MOV.W	#LOOP50,R0
		MOV.W	R0,@(I_WLOOP50,R1)
;
		MOV.W	#LOOP100,R0
		MOV.W	R0,@(I_WLOOP100,R1)
;
		MOV.L	#WTIME10,R1
		MOV.L	#TIME10,R0
		MOV.L	R0,@(I_WTIME10,R1)
;
		MOV.L	#TIME30,R0
		MOV.L	R0,@(I_WTIME30,R1)
;
		MOV.L	#TIME200,R0
		MOV.L	R0,@(I_WTIME200,R1)
;
		MOV.L	#TIME10000,R0
		RTS
		MOV.L	R0,@(I_WTIME10000,R1)
;
; *******************************************************************************
; * TITLE / SETUP								*
; * FUNCTION / CALCULATE AND SET WORK FREQUENCY, BRR, WAIT LOOP TIMES		*
; * INPUT  / -									*
; * OUTPUT / R2 = RESULT SEND TO HOST (OK=ACK, NG=BELL)				*
; *******************************************************************************
SETUPCMD	.EQU	$
		STS	PR,@-R15
;
		BSR	RECEIVE_DATA		; RECEIVE DATA FROM HOST
		NOP
		CMP/EQ	#NG,R0
		BT	SETUPERR
;
		BSR	FREQ_CHECK		; CHECK FERQUENCY INPUT, CKM/CKP RATIO
		NOP
		CMP/EQ	#OK,R0
		BF	SETUPERR		; FREQUENCY INPUT OR CKM/CKP RATIO ERROR
;
		BSR	CALCULATE_BRR		; CALCULATE BRR
		NOP
		CMP/EQ	#OK,R0
		BF	SETUPERR		; BRR MARGIN ERROR
;
		BSR	WAITLOOP_CAL		; CALCULTE AND SET WAIT LOOPS
		NOP
;
		BSR	TRS1BYTE
		MOV.B	#ACK,R2
;
SETUPCMD10	MOV.B	@(SCISSR,GBR),R0
		TST	#TEND,R0		; CHECK TRANSMISSION END
		BT	SETUPCMD10
;
		MOV.B	#H'00,R0		; DISNABLE SCI
		MOV.B	R0,@(SCISCR,GBR)
;
		MOV.L	#WORKBRR,R1		; SET BRR REGISTER
		MOV.B	@R1,R0
		MOV.B	R0,@(SCIBRR,GBR)
;
		BSR	SCI_INIT		; INITIALIZE SCI AGAIN
		NOP
;
SETUPCMD20	BSR	RCV1BYTE		; WAIT ACK CODE FROM HOST
		NOP
		CMP/EQ	#ACK,R0
		BF	SETUPCMD20
		BSR	TRS1BYTE		; IF RECEIVE ACK CODE, SEND ACK TO HOST
		MOV.B	#ACK,R2
;
		LDS	@R15+,PR
		RTS
		NOP
;
SETUPERR	BSR	TRS1BYTE
		MOV.B	#BELL,R2		; SEND ERROR MESSENGE TO HOST
;
		LDS	@R15+,PR
		RTS
		NOP
;
; *******************************************************************************
; * TITLE / SETUP DATA RECEPTION						*
; * FUNCTION / RECEIVE BAUDRATE, FREQUENCY, CKM/CKP RATIO FROM HOST		*
; * INPUT  / R5 = BAUDRATE, FREQUENCY, CKM/CKP RATIO ADDRESS AT RAM		*
; * 	     R4 = RECEIVE DATA BYTE NUMBER					*
; * 	     R0 = RECEIVED DATA							*
; * OUTPUT / @BAUDRATE = BAUDRATE INPUT						*
; * 	     @WORKCLK  = FREQUENCY INPUT					*
; * 	     @CKM_RATIO = CKM RATIO 						*
; * 	     @CKP_RATIO = CKP RATIO 						*
; * 	     R0 = RESULT(OK, NG)						*
; *******************************************************************************
RECEIVE_DATA	.EQU	$
		STS	PR,@-R15
		MOV.L	#BAUDRATE,R5
		BSR	RCVNBYTE		; RECEIVE BAUDRATE(4 BYTES) AND WORK FREQUENCY(4 BYTES)
		MOV.B	#8,R4
;
		BSR 	RCV1BYTE		; RECEIVE NUMBER OF FREQUENCY RATIO
		NOP
		CMP/EQ	#RATIO_NUM,R0		; IF NOT RATIO_NUM, GO ERROR
		BF	RECEIVE_ERR
;
		SHLL	R0			; 2 BYTES FOR EACH RATIO
		MOV	R0,R4			; RECEIVE RATIO NUMBER*2 BYTES
		MOV.L	#CKM_RATIO,R5
		BSR	RCVNBYTE
		NOP
		MOV.B	#OK,R0			; DATA RECEIVE OK
		LDS	@R15+,PR
		RTS
		NOP
;
RECEIVE_ERR	MOV.B	#NG,R0			; RECEIVE NUMBER ERROR
		LDS	@R15+,PR
		RTS
		NOP
;
; *******************************************************************************
; * TITLE / CKM/CKP FREQUENCY, CKM/CKP BIT OF FREQCR SETTING			*
; * FUNCTION / SET CKM/CKP FREQUENCY						*
; * INPUT  / R1 = FREQUENCY INPUT						*
; * 	     R2 = CKM/CKP RATIO							*
; * OUTPUT / R3 = CKM/CKP FREQUENCY 						*
; * 	     R0 = RESULT(OK, NG)						*
; *******************************************************************************
FREQ_CHECK	.EQU	$
		MOV.L	#WORKCLK,R2		; FREQUENCY INPUT
		MOV.L	@R2,R1
;
		MOV.L	#MINKHZ,R0		; MINIMUM PERMITTED FREQUENCY
		CMP/HI	R1,R0
		BT	FREQ_ERROR
;
		MOV.L	#MAXKHZ,R0		; MAXIMUM PERMITTED FREQUENCY
		CMP/HI	R0,R1
		BT	FREQ_ERROR
;
		MOV.L	#CKM_FREQ,R3		; CKM FREQUENCY
		MOV.L	#CKM_RATIO,R2		; CKM RATIO INPUT
		MOV.W	@R2,R0
		CMP/EQ	#CKMRATIO,R0
		BF	FREQ_ERROR
;
		MULU.W	R0,R1
		STS	MACL,R2
		MOV.L	R2,@R3
;
		MOV.L	#CKP_FREQ,R3		; CKP FREQUENCY
		MOV.L	#CKP_RATIO,R2		; CKM RATIO INPUT
		MOV.W	@R2,R0
		CMP/EQ	#CKPRATIO,R0
		BF	FREQ_ERROR
;
		MULU.W	R0,R1
		STS	MACL,R2
		MOV.L	R2,@R3

		RTS
		MOV.B	#OK,R0			; RATIO AND FREQUENCY OK
;
FREQ_ERROR	RTS
		MOV.B	#NG,R0			; RATIO OR FREQUENCY ERROR
;
; *******************************************************************************
; * TITLE / BRR CALCULATION							*
; * FUNCTION / CALCULATE BRR, CHECK BRR ERROR MARGIN				*
; * INPUT  / R1 = CKP FREQUENCY							*
; * 	     R2 = BAUDRATE							*
; * OUTPUT / R6 = LOWER ERROR MARGIN BRR					*
; * 	     R3 = BRR VALUE							*
; * 	     R0 = RESULT(OK, NG)						*
; *******************************************************************************
CALCULATE_BRR	.EQU	$
		STS	PR,@-R15
		MOV.L	#BAUDRATE,R0		; BRR = (MHz*1000000)/(32*BAUD)-1
		MOV.L	@R0+,R2			; BRR*1000 = (KMHz*15625)/(BAUD/2)-1000
		SHAR.L	R2			; R2 = BAUD/2
;
		MOV.L	#CKP_FREQ,R0		; CKP FREQUENCY
		MOV.L	@R0,R1
		MOV.L	#15625,R3
		MULU	R1,R3
		STS	MACL,R1			; R1 = KMHz*15625
;
		BSR	DIVIDECAL		; R0 = (KMHz*15625)/(BAUD/2)
		NOP
;
		MOV.B	#10,R1			; ERROR MARGIN FOR 2 DECIMALS
		MUL.L	R1,R0
		STS	MACL,R1			; R1 = (BRR+1) * 10000
		MOV.L	R1,R8
;
		MOV.W	#10000,R2 
		BSR	DIVIDECAL		; R0 = BRR+1
		NOP
;
		MOV	R0,R3			; BRR MARGIN(%) =
		MOV	R0,R2			; (((MHz*1000000)/((BRR+1)*BAUD*32)-1)*100
		BSR	DIVIDECAL		; BRR MARGIN(%)*100 =
		MOV	R8,R1			; ((KMHz*15625)/(BAUD/2))*10-10000
;
		MOV.W	#10000,R7
		SUB.L	R7,R0
		MOV	R0,R5			; R5 = ERROR MARGIN OF BRR
;
		ADD	#1,R2
		BSR	DIVIDECAL
		MOV	R8,R1
;
		SUB.L	R7,R0
		NEG	R0,R6			; R6 = ERROR MARGIN OF (BRR + 1)
;
		MOV.W	#400,R7
		MOV.L	#WORKBRR,R9
		CMP/GT	R5,R6			; COMPARE TWO ERROR MAGRGIN
		BF	BRR_CAL10
		ADD	#-1,R3
		MOV.L	R5,R6			; SET LOWER ERROR MARGIN
;
BRR_CAL10	CMP/GE	R7,R6			; CHECK LOWER ERROR MARGIN
		BT	BRR_ERR			; IF > 4%, GO ERROR
		MOV.B	R3,@R9			; SET BRR
		MOV.B	#OK,R0			; BRR SET OK
;
		LDS	@R15+,PR
		RTS
		NOP
;
BRR_ERR		MOV.B	#NG,R0			; BRR SET ERROR
		LDS	@R15+,PR
		RTS
		NOP
;
; *******************************************************************************
; * TITLE / WAIT LOOP TIMES CALCULATION AND SETTING				*
; * FUNCTION / CALCULATE AND SET WAIT LOOP TIMES				*
; * INPUT  / R1 = CKM, CKP FREQUENCY						*
; * 	     R5 = ADDRESS OF WAIT LOOP TIMES IN RAM				*
; * OUTPUT / R0 = WAIT LOOP TIMES 						*
; *******************************************************************************
WAITLOOP_CAL	.EQU	$
		STS	PR,@-R15
		MOV.L	#CKM_FREQ,R1		; SET CKM FREQUENCY
		MOV.L	@R1,R4
		MOV.W	#4000,R2		; N(us) * CKM FREQUENCY/4000 + 1
;
		MOV.L	#WLOOP1,R5		; ADDRESS OF WLOOP1 IN RAM
		BSR	WLOOPCAL
		MOV.B	#1,R3			; SET 1 usec LOOP TIMES
		MOV.W	R0,@(I_WLOOP1,R5)
;
		BSR	WLOOPCAL
		MOV.B	#2,R3			; SET 2 usec LOOP TIMES
		MOV.W	R0,@(I_WLOOP2,R5)
;
		BSR	WLOOPCAL
		MOV.B	#4,R3			; SET 4 usec LOOP TIMES
		MOV.W	R0,@(I_WLOOP4,R5)
;
		BSR	WLOOPCAL
		MOV.B	#5,R3			; SET 5 usec LOOP TIMES
		MOV.W	R0,@(I_WLOOP5,R5)
;
		BSR	WLOOPCAL
		MOV.B	#10,R3			; SET 10 usec LOOP TIMES
		MOV.W	R0,@(I_WLOOP10,R5)
;
		BSR	WLOOPCAL
		MOV.B	#20,R3			; SET 20 usec LOOP TIMES
		MOV.W	R0,@(I_WLOOP20,R5)
;
		BSR	WLOOPCAL
		MOV.B	#50,R3			; SET 50 usec LOOP TIMES
		MOV.W	R0,@(I_WLOOP50,R5)
;
		BSR	WLOOPCAL
		MOV.B	#100,R3			; SET 100 usec LOOP TIMES
		MOV.W	R0,@(I_WLOOP100,R5)
;
		MOV.L	#CKP_FREQ,R1		; SET CKP FREQUENCY
		MOV.L	@R1,R4
		MOV.L	#1000,R2		; N(us) * CKP FREQUENCY/1000
;
		MOV.L	#WTIME10,R5
		BSR	WTIMECAL
		MOV.B	#10,R3			; SET OVER WRITE WAIT LOOP TIMES(10 usec)
		MOV.L	R0,@(I_WTIME10,R5)
;
		BSR	WTIMECAL
		MOV.B	#30,R3			; SET 1-6 WRITE WAIT LOOP TIMES(30 usec)
		MOV.L	R0,@(I_WTIME30,R5)
;
		MOV.W	#200,R3			; SET 7-1000 WRITE WAIT LOOP TIMES(200 usec)
		BSR	WTIMECAL
		NOP
		MOV.L	R0,@(I_WTIME200,R5)
;
		MOV.L	#10000,R3		; SET ERASE WAIT LOOP TIMES(1 msec)
		BSR	WTIMECAL
		NOP
		MOV.L	R0,@(I_WTIME10000,R5)
		LDS	@R15+,PR
		RTS
		NOP
;
; *******************************************************************************
; * TITLE / WAIT LOOP CALCULATION						*
; * FUNCTION / CALCULATE LOOP TIMES						*
; * INPUT  / R4 = CKM/CKP FREQUENCY						*
; * 	     R3 = WAIT TIME(usec)						*
; * OUTPUT / R0 = WAIT LOOP TIMES						*
; *******************************************************************************
WLOOPCAL	.EQU	$
		STS	PR,@-R15		; CALCULAT WLOOP TIMES
		BRA	W_CAL00
		MOV.B	#1,R6
;
WTIMECAL	STS	PR,@-R15		; CALCULAT WTIME TIMES
		MOV.B	#0,R6
W_CAL00		MULU	R3,R4
		STS	MACL,R1
		BSR	DIVIDECAL
		NOP
		ADD	R6,R0
		LDS	@R15+,PR
		RTS
		NOP
;
; *******************************************************************************
; * TITLE / DIVIDE CALCULATION							*
; * FUNCTION / DIVIDE BY SUBTRATION ROUTINE					*
; * INPUT  / R1 = DIVIDEND							*
; * 	     R2 = DIVIDOR							*
; * OUTPUT / R0 = QUOTIENT							*
; *******************************************************************************
DIVIDECAL	.EQU	$
		XOR	R0,R0
DIVIDECAL10	CMP/HI	R1,R2
		BT	DIVIDECAL20
		SUB	R2,R1
		BRA	DIVIDECAL10
		ADD	#1,R0
;
DIVIDECAL20	RTS
		NOP
;
; *******************************************************************************
; * TITLE / ERASING & WRITING 							*
; * FUNCTION / ERASE DESIGNATED BLOCK, RECEIVE AND WRITE DATA TO FLASH MEMORY	*
; * INPUT  / -									*
; * OUTPUT / R2 = ERASE & WRITE RESULT(ACK = OK, BELL = ERROR)			*
; *******************************************************************************
WCMD		.EQU    $
		STS	PR,@-R15
		BSR	RCV1BYTE		; RECEIVE ERASE BLOCK NUMBER
		NOP
		CMP/EQ	#0,R0			; IF ERASE BLOCK NUMBER = 0
		BT	WCMD_WRITE		; GO WRITE
;
		MOV.L	R0,R13
		MOV.L	R0,R4
		SHLL2	R4
		MOV.L	#W_BUF,R5
		BSR	RCVNBYTE		; RECEIVE ERASE BLOCK START ADDRESS
		NOP
;
		MOV.L	#W_BUF,R1		; ERASE BLOCK START ADDRSS
		MOV.L	#E_ADR_PTR,R10
		MOV.L	R1,@R10
NEXTBLOCK	MOV.L	#E_ADR_PTR,R10		; STORE TO ERASE BLOCK ADDRESS POINTER
		MOV.L	@R10,R1
		MOV.L	@R1+,R6
		MOV.L	R1,@R10
;
		BSR	BLK_CHECK		; CHECK RECEIVED BLOCK START ADDRESS
		NOP
		CMP/EQ	#OK,R0			; ERASE BLOCK START ADDRESS CHECK RESULT
		BF	WCMD_ERR		; ERASE BLOCK START ADDRESS ERROR
;
		MOV.L	#FLMCR1,R0		; ERASE BLOCK START ADDRESS < H'40000 SET FLMCR1
		MOV.L	#FLMCR_SEL,R10
		CMP/HS	R10,R6
		BF	WCMD10
		MOV.L	#FLMCR2,R0		; ERASE BLOCK START ADDRESS >= H'40000 SET FLMCR2
;
WCMD10		LDC	R0,GBR
		BSR	BLOCK_ERASE		; GO DESIGNATED BLOCK ERASE
		NOP
		CMP/EQ	#OK,R0			; CHECK ERASE RESULT
		BF	WCMD_ERR		; ERASE ERROR
;
		DT	R13
		BF	NEXTBLOCK		; ALL DESIGNATED BLOCKS ERASE OK
;
;--------------- 128 BYTES DATA PROGRAM ----------------------------------------
WCMD_WRITE	BSR	TRS1BYTE
		MOV.B	#ACK,R2			; SEND "ACK" TO HOST
;
		BSR	GET_WADR		; RECEIVE WRITE START ADDRESS AND DATA SIZE
		NOP
		CMP/EQ	#OK,R0
		BF	WCMD_ERR		; WRITE ADDRESS OR SIZE ERROR
		MOV.B	#0,R0
		MOV.L	#CHKSM,R10		; INITIALIZE CHECK SUM
		MOV.B	R0,@R10
;
WCMD_W10	BSR	XON_CHECK		; CHECK COMMAND
		NOP
		CMP/EQ	#ACK,R0			; IF COMMAND = ACK
		BT	WCMD_END		; STOP WRITE
;
		BSR 	GET_BUFFER		; ELSE RECEIVE AND STORE 128 BYTES WRITE DATA
		NOP
;
WCMD_W20	BSR 	FWRITE128		; WRITE 128 BYTES RECEIVED DATA
		NOP
		CMP/EQ	#OK,R0			; CHECK WRITE RESULT
		BF 	WCMD_ERR		; WRITE ERROR
;
		MOV.L	#W_ADR,R10		; SET WRITE ADDRESS
		MOV.L	@R10,R2
		MOV.W	#128,R3			; WRITE 128 BYTE DATA EACH TIME
		ADD	R3,R2
		MOV.L	R2,@R10			; RESET WRITE ADDRESS
;
		MOV.L	#RESTSIZE,R10
		MOV.L	@R10,R0			; WRITE DATA SIZE REMAINED
		SUB	R3,R0			; RESET WRITE DATA SIZE
		MOV.L	R0,@R10
		CMP/PL	R0
		BT 	WCMD_W10		; WRITE DATA SIZE REMAINED =0
;
;--------------- HOST CHECK -----------------------------------------------------
		BSR 	XON_CHECK		; GO CHECK COMMAND
		NOP
		CMP/EQ	#ACK,R0			; IF COMMAND = ACK
		BT	WCMD_END                ; STOP WRITE
;
		BSR 	RCV1BYTE		; RECEIVE CHECK SUM FORM HOST
		NOP
		MOV.L	#CHKSM,R10
		MOV.B	@R10,R4
		NOT	R4,R4
		EXTU.B	R4,R4
		CMP/EQ	R0,R4			; COMPARE CHECK SUM
		BF 	WCMD_ERR		; CHECKSUM ERROR
;
		BRA	WCMD_W30
		MOV.B	#ACK,R2			; SEND "ACK" TO HOST
;
;--------------- ERROR MESSAGE -------------------------------------------------
WCMD_ERR	MOV.B	#BELL,R2		; SEND "BELL" TO HOST
WCMD_W30	BSR	TRS1BYTE
		NOP
;--------------- GO TO WAIT "W" COMMAND  -----------------------------------------
WCMD_END	LDS	@R15+,PR		; END ROUTIN
		RTS
		NOP
;
; *******************************************************************************
; * TITLE / ERASE BLOCK START ADDRESS CHECK					*
; * FUNCTION / SET ERASE BLCOK BIT, ERASE VERIFY START/END ADDRESS		*
; * INPUT /  R6 = RECEIVED ERASE BLOCK ADDRESS					*
; * OUTPUT / R7 = ERASE BLOCK BIT						*
; * 	     @EVF_ST = ERASE BLOCK START ADDRESS				*
; * 	     @EVF_ED = ERASE BLOCK END ADDRESS					*
; * 	     R0 = RESULT(OK, NG)						*
; *******************************************************************************
BLK_CHECK	.EQU	$
		MOV.B	#H'01,R7		; INITIALIZE ERASE BLOCK NUMBER
		MOV.L	#BLOCKADR1,R8		; EBR1 START ADDRESS
		MOV.B	#MAXBLK1,R9		; MAX BLOCK NUMBER OF EBR1
		MOV.L	#EBR1,R11
;
		MOV.L	#CHK_ADR,R5		; CHECK EBR1 OR EBR2 ADDRESS
		CMP/GE	R5,R6
		BF	BLK_CHECK10
;
		MOV.L	#BLOCKADR2,R8		; EBR2 START ADDRESS
		MOV.B	#MAXBLK2,R9		; MAX BLOCK NUMBER OF EBR2
		MOV.L	#EBR2,R11
;
BLK_CHECK10	MOV.L	@R8+,R12
		CMP/EQ	R12,R6
		BT	BLK_CHECK20		; ADDRESS FOUND
;
		SHLL	R7			; CHECK NEXT BLOCK
		DT	R9
		BF	BLK_CHECK10
;
		RTS
		MOV.B	#NG,R0			; NOT FOUND, ERASE ADDRESS ERROR
;
BLK_CHECK20	MOV.L	#EVF_ST,R2
		MOV.L	R6,@R2
		MOV.L	#EVF_ED,R2
		MOV.L	@R8,R0
		MOV.L	R0,@R2
		RTS
		MOV.B	#OK,R0
;
; *******************************************************************************
; * TITLE / WRITE START ADDRESS AND DATA SIZE RECEPTION				*
; * FUNCTION / RECEIVE WRITE START ADDRESS AND WRITE DATA SIZE			*
; * INPUT  / R0 = WRITE ADDRESS							*
; * 	     R0 = WRITE DATA SIZE						*
; * OUTPUT / @W_ADR = WRITE ADDRESS 						*
; * 	     @RESTSIZE WRITE DATA SIZE						*
; * 	     R0 = RESULT(OK, NG)						*
; *******************************************************************************
GET_WADR	.EQU	$
		STS	PR,@-R15
		MOV.B	#8,R4
		MOV.L	#W_ADR,R5
		BSR	RCVNBYTE		; RECEIVE BAUDRATE DATA
		NOP
;
		MOV.L	#W_ADR,R10		; CHECK WRITE START ADDRESS
		MOV.L	@R10,R0
		AND	#ST_ADR,R0		; IF LOWEST 1 BYTE NOT H'80 OR H'00
		CMP/EQ	#0,R0
		BF/S	GET_WEND		; WRITE ADDRESS ERROR
		MOV.B	#NG,R0			; SET NG FLAG
;
		MOV.L	#RESTSIZE,R10
		MOV.L	@R10,R0
		CMP/EQ	#0,R0			; IF WRITE DATA SIZE = H'0000
		BT/S 	GET_WEND		; WRITE DATA SIZE ERROR
		MOV.B	#NG,R0			; SET NG FLAG
;
		MOV.B	#OK,R0			; ELSE SET OK FLAG
;
GET_WEND	LDS	@R15+,PR
		RTS
		NOP
;
; *******************************************************************************
; * TITLE / WRITE DATA RECEPTION						*
; * FUNCTION / RECEIVE 128 BYTES WRITE DATA TO WIRTE BUFFER, 			*
; *	       RESET WRITE DATA SIZE						*
; * INPUT  / @RESTSIZE = WRITE DATA SIZE REMAINED				*
; * 	     R11= WRITE DATA BUFFER ADDRESS					*
; * 	     R0 = WRITE DATA							*
; * OUTPUT / @W_BUF = 128 BYTES WRITE DATA					*
; * 	     @CHKSM = 1 BYTE CHECK SUM VALUE					*
; * 	     @RESTSIZE = WRITE DATA SIZE REMAINED				*
; *******************************************************************************
GET_BUFFER	.EQU	$
		STS	PR,@-R15
		MOV.L	#RESTSIZE,R8
		MOV.L	@R8,R1			; WRITE DATA SIZE REMAINED
		MOV.L	#W_BUF,R11		; WRITE DATA BUFFER ADDRESS
		MOV.L	#128,R10		; WRITE DATA BUFFER SIZE
		MOV.L	#CHKSM,R9		; WRITE DATA CHECK SUM
		MOV.B	@R9,R7
;
		CMP/HS	R10,R1			; IF WRITE DATA SIZE REMAINED > 128
		BT 	BUFFER10		; GO TO RECEIVE WRITE DATA 
;
		MOV.L	#H'FFFFFFFF,R3
		ADD	R11,R10
BUFFER00	MOV.L	R3,@-R10		; ELSE INITIALIZE BUFFER WITH H'FF
		CMP/HI	R11,R10
		BT	BUFFER00		; 128 BYTES DATA OK
		MOV.L	R1,R10
;
BUFFER10	BSR 	RCV1BYTE		; RECEIVE 1 BYTE WRITE DATA
		NOP
		MOV.B	R0,@R11			; STORE DATA TO WRITE BUFFER
		ADD	R0,R7			; CHECK SUM = CHECK SUM + WRITE DATA
		ADD	#1,R11
		DT	R10
		BF 	BUFFER10		; 128 BYTES DATA RECEIVED
;
		MOV.B	R7,@R9			; RESET CHECK SUM
		LDS	@R15+,PR
		RTS
		NOP
;
; *******************************************************************************
; * TITLE / N BYTES DATA RECEPTION						*
; * FUNCTION / RECEIVE N BYTES DATA FROM HOST					*
; * INPUT  / R5 = RECEIVED DATA STORE ADDRESS IN RAM				*
; * 	     R4 = RECEIVE DATA BYTE NUMBER					*
; * 	     R0 = RECEIVED DATA							*
; * OUTPUT / @R5 = RECEIVED DATA						*
; *******************************************************************************
RCVNBYTE	.EQU	$
		STS	PR,@-R15
RCVNBYTE10	BSR	RCV1BYTE		; RECEIVE 1 BYTE DATA
		NOP
		MOV.B	R0,@R5			; STORE RECEIVED DATA
		ADD	#1,R5
		DT	R4			; RECEIVE DATA SIZE - 1
		BF	RCVNBYTE10		; UNTIL DATA SIZE = 0
		LDS	@R15+,PR
		RTS
		NOP
;
; *******************************************************************************
; * TITLE / 1 BYTE DATA RECEPTION						*
; * FUNCTION / RECEIVE 1 BYTE DATA, CHECK SCI ERROR				*
; * INPUT /  -									*
; * OUTPUT / R0 = RDR 								*
; * 	     R2 = IF SCI ERROR, SEND BELL TO HOST				*
; *******************************************************************************
RCV1BYTE	.EQU	$
		MOV.L	#SCI_REG,R0		; SET SCI REGISTER TO GBR
		LDC	R0,GBR
RCV1BYTE10	MOV.B	@(SCISSR,GBR),R0
		TST	#OFP_ERR,R0		; CHECK SCI ERROR BIT
		BF	RCV_ERR
		TST	#H'40,R0
		BT	RCV1BYTE10
;
		MOV.B	@(SCIRDR,GBR),R0
		EXTU.B	R0,R0
		MOV	R0,R3
		MOV.B	@(SCISSR,GBR),R0
		AND	#H'BF,R0
		MOV.B	R0,@(SCISSR,GBR)
		MOV	R3,R0
		RTS
		NOP
;
RCV_ERR		BRA	RCV_ERR			; LIMITLESS LOOP
		NOP
;
; *******************************************************************************
; * TITLE / 1 BYTE DATA TRANSMISSION						*
; * FUNCTION / SEND 1 BYTE DATA TO HOST						*
; * INPUT /  -									*
; * OUTPUT / R0 = RDR 								*
; * 	     R2 = IF SCI ERROR, SEND BELL TO HOST				*
; *******************************************************************************
TRS1BYTE	.EQU	$
		MOV.L	#SCI_REG,R0		; SET SCI REGISTER TO GBR
		LDC	R0,GBR
		MOV.B	@(SCISSR,GBR),R0
		TST	#H'80,R0
		BT	TRS1BYTE
;
		MOV	R2,R0
		MOV.B	R0,@(SCITDR,GBR)
		MOV.B	@(SCISSR,GBR),R0
		AND	#H'7F,R0
		MOV.B	R0,@(SCISSR,GBR)
		RTS
		NOP
;
; *******************************************************************************
; * TITLE / XON CODE CHECK							*
; * FUNCTION / SEND XON CODE AND CHECK COMMAND CODE FROM HOST			*
; * INPUT /  R0 = RECEIVE COMMAND CODE(ACK = H'06, XON = H'11) FROM HOST	*
; * OUTPUT / R2 = SENT COMMAND CODE(XON = H'11) TO HOST				*
; *******************************************************************************
XON_CHECK	.EQU	$
		STS	PR,@-R15
		BSR 	TRS1BYTE		; SEND "XON" TO HOST
		MOV.B	#XON,R2
;
XON10		BSR 	RCV1BYTE		; RECEIVE 1 BYTE DATA FROM HOST
		NOP
		CMP/EQ	#ACK,R0			; IF DATA = "ACK"
		BT 	XON20			; STOP RECEIVE DATA
;
		CMP/EQ	#XON,R0			; IF DATA = "XON"
		BF 	XON10			; ELSE CONTINUE TO RECEIVE DATA

;--------------- RECEIVED "ACK" OR "XON" ----------------------------------------
XON20		LDS	@R15+,PR
		RTS
		NOP
;
; *******************************************************************************
; * TITLE / SCI INITIALIZATION							*
; * FUNCTION / ENABLE TRANSMISSION AND RECEPTION				*
; * INPUT / -									*
; * OUTPUT / -									*
; *******************************************************************************
SCI_INIT	.EQU	$
		MOV.L	#SCI_REG,R0		; SETTING SCI REGISTER TO GBR
		LDC	R0,GBR
		MOV	#0,R0
		MOV.B	R0,@(SCISCR,GBR)	; INITIALIZE SCR
		MOV.L	#PCCR,R0		; SET SCI ENABLE
		MOV.W	#H'05,R1
		MOV.W	R1,@R0
;
		MOV.L	#PCDR,R0
		MOV.W	#RXD,R1
SCI_INIT10	MOV.W	@R0,R2			; RXD2 PORT HIGH LEVEL CHECK(WAIT 1 BIT PERIOD)
		TST	R1,R2
		BT	SCI_INIT10
;
SCI_INIT20	MOV.W	@R0,R2			; RXD2 PORT LOW LEVEL CHECK(WAIT 1 BIT PERIOD)
		TST	R1,R2
		BF	SCI_INIT20
;
		MOV.B	#H'30,R0		; ENABLE SCI
		MOV.B	R0,@(SCISCR,GBR)
		RTS
		NOP
;
	.POOL
; *******************************************************************************
; * TITLE / 128 BYTES WRITE DATA WRITING					*
; * FUNCTION / WRITE AND VERIFY 128 BYTES WRITE DATA TO FLASH MEMORY 		*
; * INPUT  / W_BUF = 128 BYTES WRITE DATA BUFFER ADDRESS			*
; * 	     BUFF = 128 BYTES RETRY WRITE DATA BUFFER				*
; * 	     OWBUFF = 128 BYTES OVER WRITE DATA BUFFER				*
; * 	     GBR = FLMCR REGISTER						*
; * OUTPUT / R0 = RESULT(OK, NG)						*
; *******************************************************************************
FWRITE128	.EQU  $
		STS	PR,@-R15
		MOV.L	#RSTCSR,R1		; INITIALIZE WATCH DOG TIMER REGISTER
		MOV.W	#H'5A5F,R0
		MOV.W	R0,@R1
;
		MOV.B	#32,R4
		MOV.L	#W_BUF,R5		; WRITE DATA BUFFER ADDRESS
		MOV.L	#BUFF,R6		; RETRY DATA BUFFER ADDRESS
FWRTE00		MOV.L	@R5+,R0
		MOV.L	R0,@R6
		ADD	#4,R6
		DT	R4
		BF	FWRTE00			; TRANMMIT WRITE DATA BUFFER TO RETRY BUFFER
;
		MOV.L	#FLMCR1,R0		; WRITE ADDRESS UNDER H'40000 SET FLMCR1
		MOV.L	#W_ADR,R1
		MOV.L	@R1,R1
		MOV.L	#FLMCR_SEL,R2
		CMP/HS	R2,R1
		BF	FWRTE05
		MOV.L	#FLMCR2,R0		; WRITE ADDRESS >= H'40000 SET FLMCR1
;
FWRTE05		LDC	R0,GBR			; SET FLMCR REGISTER TO GBR
;
		MOV.L	#WLOOP1,R12
		MOV.W	@R12,R1
		MOV.B	#0,R0
		OR.B	#SWE,@(R0,GBR)		; SET SWE BIT
FWRTE10		DT	R1			; SWE BIT SET WAIT
		BF	FWRTE10
;
		MOV.L	#COUNT,R1
		XOR	R0,R0
		MOV.L	R0,@R1			; CLEAR WRITE COUNT
;
;--------------- PROGRAM VERIFY --------------------------------------------------
		BSR	FWRITEVF		; FIRST POGRAM VERIFY
		NOP
		CMP/EQ	#OK,R0
		BT	FWRTE40			; IF RESULT = OK, END PROGRAM
;
		CMP/EQ	#WNG,R0
		BT	FWRTE30			; IF RESULT = WNG, FLASH MEMORY ERROR
;
;--------------- 1,2,3,4,5,6 TIMES PROGRAM(30 usec) + OVER WRITE(10 usec) -------
FWRTE15		MOV.L	#BUFF,R2		; SET RETRY WRITE DATA
		MOV.L	#WTIME30,R12		; SET WRITE TIME(30 usec)
		MOV.L	@R12,R3
		BSR	FWRITE			; GO PROGRAM
		NOP
		BSR	FWRITEVF		; GO PROGRAM VERIFY
		NOP
		MOV.L	#VF_RET,R1
		MOV.L	R0,@R1
		MOV.L	#OWBUFF,R2		; SET OVER WRITE DATA
		MOV.L	#WTIME10,R12
		MOV.L	@R12,R3			; SET OVER WRITE TIME(10 usec)
		BSR	FWRITE			; GO PROGRAM(OVER WRITE)
		NOP
		MOV.L	#VF_RET,R1
		MOV.L	@R1,R0
		CMP/EQ	#OK,R0			; CHECK PROGRAM VERIFY RESULT
		BT	FWRTE40			; IF RESULT = OK, END PROGRAM
;
		CMP/EQ	#WNG,R0			; IF RESULT = WNG, FLASH MEMORY ERROR
		BT	FWRTE30
;
		MOV.L	#COUNT,R1		; WRITE COUNT + 1
		MOV.L	@R1,R0
		ADD	#1,R0
		MOV.L	R0,@R1			; RESET WRITE COUNT
		MOV.L	#OW_COUNT,R1
		CMP/EQ	R1,R0			; CHECK WRITE COUNT
		BF	FWRTE15			; LOWER 6 TIMES
;
;--------------- 7 - 1000 TIMES PROGRAM(200 usec) ------------------------------------
FWRTE20		MOV.L	#BUFF,R2		; SET RETRY DATA
		MOV.L	#WTIME200,R12		; SET WRITE TIME(200 usec)
		MOV.L	@R12,R3
		BSR	FWRITE			; GO PROGRAM
		NOP
		BSR	FWRITEVF		; GO PROGRAM VERIFY
		NOP
		CMP/EQ	#OK,R0			; CHECK PROGRAM VERIFY RESULT
		BT	FWRTE40			; IF RESULT = OK, END PROGRAM
;
		CMP/EQ	#WNG,R0			; ELSE CHECK PROGRAM RESULT
		BT	FWRTE30			; IF RESULT = WNG, FLASH MEMORY ERROR
;
		MOV.L	#COUNT,R1		; ELSE WRITE COUNT + 1
		MOV.L	@R1,R0
		ADD	#1,R0
		MOV.L	R0,@R1			; RESET WRITE COUNT
		MOV.L	#MAXWT,R1
		CMP/EQ	R1,R0			; CHECK WRITE COUNT
		BF	FWRTE20			; IF COUNT = MAX WRITE TIMES, PROGRAM ERROR
;
;-------------- PROGRAM ERROR PROCESS --------------------------------------------------------
FWRTE30		MOV.L	#WLOOP100,R12
		MOV.W	@R12,R1
		MOV.B	#0,R0
		AND.B	#SWE_N,@(R0,GBR)	; CLEAR SWE BIT
FWRTE35		DT	R1			; SET SWE BIT CLEAR WAIT
		BF	FWRTE35
;
		MOV.B	#NG,R0			; SET NG FLAG
		LDS	@R15+,PR
		RTS
		NOP
;
;-------------- PROGRAM OK PROCESS  -------------------------------------------------------------
FWRTE40		MOV.L	#WLOOP100,R12
		MOV.W	@R12,R1
		MOV.B	#0,R0
		AND.B	#SWE_N,@(R0,GBR)	; CLEAR SWE BIT
FWRTE45		DT	R1			; SET SWE CLEAR WAIT
		BF	FWRTE45
;
		MOV.B	#OK,R0			; SET OK FLAG
		LDS	@R15+,PR
		RTS
		NOP
	.POOL
; *******************************************************************************
; * TITLE / PROGRAM VERIFY							*
; * FUNCTION / VERIFY FLASH MEMORY DATA, MAKE RETRY DATA AND OVER WRITE DATA	*
; * INPUT  / R1 = RETRY WRITE DATA BUFFER ADDRESS	 			*
; * 	     R2 = WRITE DATA BUFFER ADDRESS					*
; * 	     R3 = OVER WRITE DATA BUFFER ADDRESS				*
; * 	     R4 = WRITE ADDRESS OF FLASH MEMORY					*
; * 	     GBR = FLMCR REGISTER						*
; * OUTPUT / @R1 = RETRY WRITE DATA						*
; * 	     @R2 = WRITE DATA							*
; * 	     @R3 = OVER WRITE DATA						*
; * 	     R0 = RESULT(OK, NG, WNG)						*
; *******************************************************************************
FWRITEVF	.EQU	$
		MOV.L	#H'FFFFFFFF,R5		; DUMMY WRITE DATA(FOR ADDRESS LATCH)
		MOV.L	#BUFF,R1		; RETRY DATA BUFFER
		MOV.L	#W_BUF,R2		; WRITE DATA BUFFER
		MOV.L	#W_ADR,R4
		MOV.L	@R4,R4			; WRITE ADDRESS
;--------------- OVER WRITE DATA BUFFER-------------------------------------------
		MOV.L	#OWBUFF,R3		; OVER WRITE DATA BUFFER
;-----------------------------------------------------------------------------------
;
		MOV.L	#WLOOP4,R12
		MOV.W	@R12,R6	
		MOV.B	#0,R0
		OR.B	#PV,@(R0,GBR)		; SET PV BIT
FWVF10		DT	R6			; PV BIT SET WAIT
		BF	FWVF10
;
FWVF20		MOV.L	#WLOOP2,R12
		MOV.W	@R12,R6
		MOV.L	R5,@R4			; DUMMY WRITE(FOR WRITE ADDRESS LATCH)
FWVF30		DT	R6			; LATCH WAIT
		BF	FWVF30
;
		MOV.L	@R4+,R0			; READ FLASH MEMORY DATA
;--------------- MAKE OVER WRITE DATA --------------------------------------
		MOV.L	@R1,R7
		OR	R0,R7			; OVER DATA(WRITE DATA BIT=READ DATA BIT=0)
		MOV.L	R7,@R3			; STORE TO OVER WRITE DATA BUFFER
		ADD	#4,R3
;----------------------------------------------------------------------------------
		NOT	R0,R0
		MOV.L	@R2,R7
		OR	R0,R7			; RETRY DATA(WRITE DATA BIT=0, READ DATA BIT=1)
		MOV.L	R7,@R1			; SET RETRY WRITE DATA
		ADD	#4,R1
		MOV.L	@R2+,R7
		TST	R7,R0
		BF	FWVF70			; FLASH MEMORY ERROR(WRITE DATA BIT=1, READ DATA BIT=0)
;
		MOV.L	#W_BUF+128,R6
		CMP/EQ	R6,R2
		BF	FWVF20			; 128 BYTES DATA OK
;
		MOV.L	#WLOOP2,R12
		MOV.W	@R12,R6	
		MOV.B	#0,R0
		AND.B	#PV_N,@(R0,GBR)		; CLEAR PV BIT
FWVF40		DT	R6			; PV BIT CLEAR WAIT
		BF	FWVF40
;
		MOV.B	#NG,R0			; SET NG FLAG
		MOV.L	#BUFF,R1		; SET RETRY WRITE DATA BUFFER
FWVF50		MOV.L	@R1+,R6
		CMP/EQ	R5,R6
		BF	FWVF60			; PROGRAM VERIFY ERROR
;
		MOV.L	#BUFF+128,R6
		CMP/EQ	R6,R1
		BF	FWVF50			; 128 BYTES DATA CHECK OK
;
		MOV.B	#OK,R0			; SET OK FLAG
FWVF60		RTS
		NOP
;
;-------------- FLASH MEMORY ERROR PROCESS ---------------------------------
FWVF70		MOV.L	#WLOOP2,R12
		MOV.W	@R12,R6	
		MOV.B	#0,R0
		AND.B	#PV_N,@(R0,GBR)		; CLEAR PV BIT
FWVF80		DT	R6			; PV BIT CLEAR WAIT
		BF	FWVF80
;
		RTS
		MOV.B	#WNG,R0			; SET FLASH MEMORY ERROR FLAG
	.POOL
; *******************************************************************************
; * TITLE / PROGRAMMING(WRITING) 						*
; * FUNCTION / PROGRAM(WRITE) FLASH MEMORY					*
; * INPUT  / @W_ADR = WRITE ADDRESS OF FLASH MEMORY				*
; * 	     @R2 =RETRY DATA							*
; * 	     @R9 = P BIT SET WAIT TIME(10, 30 OR 200 usec)			*
; * 	     GBR = FLMCR REGISTER						*
; * OUTPUT /-									*
; *******************************************************************************
FWRITE		.EQU	$
		MOV.L	#TSTR,R10		; SET TIMER START REGISTER
;
		MOV.L	#W_ADR,R1
		MOV.L	@R1,R1			; WRITE ADDRESS
;
		MOV.L	#128,R4
FWRT10		MOV.B	@R2+,R0			; RETRY DATA(1 BYTE)
		MOV.B	R0,@R1			; DUMMY WRITE(1BYTE)
		ADD	#1,R1
		DT	R4
		BF	FWRT10			; 128 BYTES DATA OK
;
		MOV.L	#TCSR,R11		; SET WATCH DOG TIMER COUNT
		MOV.W	#WRITE_WDT,R0
		MOV.W	R0,@R11
		MOV.L	#WLOOP50,R12
		MOV.W	@R12,R4	
		MOV.B	#0,R0
		OR.B	#PSU,@(R0,GBR)	 	; SET PSU BIT
FWRT20		DT	R4			; PSU BIT SET WAIT
		BF	FWRT20
;
		XOR	R0,R0
		MOV.L	#TCNT,R9
		MOV.L	R0,@R9			; CLEAR TIMER COUNT
;--------------- PROGRAM WAIT --------------------------------------------------
		MOV.B	#H'01,R0
		MOV.B	R0,@R10			; TIMER COUNT START
;
		NOP				; FOR TIMER REVISION(6 STEPS)
		NOP
		NOP
		NOP
		NOP
		NOP
;
		MOV.B	#0,R0
		OR.B	#P,@(R0,GBR)		; SET P BIT(WRITE START)
FWRT40		MOV.L	@R9,R4
		CMP/GE	R3,R4			; P BIT SET WAIT(WRITE TIME)
		BF 	FWRT40			; 10, 30, OR 200 usec 
;
		AND.B	#P_N,@(R0,GBR)		; CLEAR P BIT(WRITE STOP)
		XOR	R0,R0
		MOV.B	R0,@R10			; STOP TIMER COUNT
;-------------------------------------------------------------------------------
		MOV.L	#WLOOP5,R12
		MOV.W	@R12,R4	
FWRT50		DT	R4			; P BIT CLEAR WAIT
		BF	FWRT50
;
		MOV.L	#WLOOP5,R12
		MOV.W	@R12,R4	
		MOV.B	#0,R0
		AND.B	#PSU_N,@(R0,GBR)	; CLEAR PSU BIT
FWRT60		DT	R4			; PSU BIT CLEAR WAIT
		BF	FWRT60
;
		MOV.L	#TCSR,R11
		MOV.W	#H'A558,R0
		MOV.W	R0,@R11			; STOP WATCH DOG TIMER COUNT
;
		RTS
		NOP
	.POOL
; *******************************************************************************
; * TITLE / DESIGNATED BLOCK ERASING						*
; * FUNCTION / ERASE 1 DESIGNATED BLOCK OF FLASH MEMORY				*
; * INPUT  / GBR = FLMCR REGISTER						*
; * OUTPUT / R0 = RESULT(OK=H'00,NG=H'01)					*
; *******************************************************************************
BLOCK_ERASE	.EQU	$
		STS	PR,@-R15
		MOV.L	#RSTCSR,R1		; INITIALIZE WATCHDOG TIMER
		MOV.W	#H'5A5F,R0
		MOV.W	R0,@R1
;
		MOV.L	#TSTR,R10		; SET TIMER REGISTER
;
		MOV.L	#WLOOP1,R14
		MOV.W	@R14,R4	
		MOV.B	#0,R0
		OR.B	#SWE,@(R0,GBR)		; SET SWE BIT
BLKER10		DT	R4			; SWE BIT SET WAIT
		BF	BLKER10
;
		MOV.L	#COUNT,R1
		XOR	R0,R0			; CLEAR ERASE COUNT
		MOV.L	R0,@R1
;---------------  ERASE VERIFY --------------------------------------------------
BLKER20		BSR	ERASEVF			; GO ERASE VERIFY
		NOP
;
		TST	R7,R7			; IF RESULT = OK, END ERASE
		BT	BLKER40
;
;--------------- ERASE AND ERASE VERIFY -----------------------------------------
BLKER30		BSR	FERASE			; GO ERASE
		NOP
;
		BSR	ERASEVF			; GO ERASE VERIFY
		NOP
;
		TST	R7,R7			; IF RESULT = OK, END ERASE
		BT	BLKER40
;
		MOV.L	#COUNT,R1		; ERASE COUNT +1
		MOV.L	@R1,R0
		ADD	#1,R0
		MOV.L	R0,@R1			; RESET ERASE COUNT
		MOV.L	#MAXET,R1
		CMP/HS	R1,R0			; CHECK ERASE COUNT
		BF	BLKER30			; IF COUNT = MAX ERASE TIMES, ERASE ERROR
		MOV.B	#NG,R3			; SET NG FLAG
		BRA	BLKER50
		NOP
;
BLKER40		MOV.B	#OK,R3
BLKER50		MOV.L	#WLOOP100,R14
		MOV.W	@R14,R4	
		MOV.B	#0,R0
		AND.B	#SWE_N,@(R0,GBR)	; CLEAR SWE BIT
BLKER60		DT	R4
		BF	BLKER60			; SWE BIT CLEAR WAIT
;
		MOV	R3,R0
		LDS	@R15+,PR
		RTS
		NOP
;
	.POOL
; *******************************************************************************
; * TITLE / ERASE VERIFY							*
; * FUNCTION / VERIFY FLASH MEMORY DATA OF DESIGNATED BLOCK			*
; * INPUT  / R1 = ERASE BLOCK START ADDRESS					*
; * 	     R2 = ERASE BLOCK END ADDRESS					*
; * 	     GBR = FLMCR REGISTER						*
; * OUTPUT / R0 = RESULT(OK, NG)						*
; *******************************************************************************
ERASEVF		.EQU	$
		MOV.L	#H'FFFFFFFF,R5		; SET DUMMY WRITE DATA
		MOV.L	#WLOOP20,R14
		MOV.W	@R14,R3	
		MOV.B	#0,R0
		OR.B	#EV,@(R0,GBR)		; SET EV BIT
VRF10		DT	R3			; EV BIT SET WAIT
		BF	VRF10
;
VRF20		MOV.L	#EVF_ST,R0		; BLOCK START ADDRESS
		MOV.L	@R0,R1
		MOV.L	#EVF_ED,R0
		MOV.L	@R0,R2			; BLOCK END ADDRESS
;
VRF30		MOV.L	R5,@R1			; DUMMY WRITE(FOR ADDRESS LATCH)
		MOV.L	#WLOOP2,R14
		MOV.W	@R14,R3	
VRF40		DT	R3			; LATCH WAIT
		BF	VRF40
;
		MOV.L	@R1+,R0
		CMP/EQ	R5,R0			; FLASH MEMORY DATA VERIFY
		BF	VRF50			; IF NOT ERASED, END VERIFY
;
		CMP/HI	R1,R2			; ALL ADDRESS CHECK OK
		BT	VRF30
;
		MOV.B	#0,R7			; IF OK, CLEAR ERASED BIT
VRF50		MOV.L	#WLOOP2,R14 
		MOV.W	@R14,R3	
		MOV.B	#0,R0
		AND.B	#EV_N,@(R0,GBR)		; CLEAR EV BIT
;
VRF60		DT	R3			; EV CLEAR WAIT
		BF	VRF60
;
		RTS
		NOP
	.POOL
; *******************************************************************************
; * TITLE / ERASING 								*
; * FUNCTION / ERASE DESIGNATED BLOCK OF FLASH MEMORY				*
; * INPUT  / R7 = ERASE BIT OF EBR						*
; * 	     GBR = FLMCR REGISTER						*
; * OUTPUT / -			 						*
; *******************************************************************************
FERASE		.EQU	$
		MOV.B	R7,@R11			; SET EBR REGISTER
		MOV.L	#WLOOP100,R14
		MOV.W	@R14,R9
;
		MOV.L	#TCSR,R12		; SET WATCH DOG TIMER COUNT
		MOV.W	#ERASE_WDT,R0
		MOV.W	R0,@R12
;
		MOV.B	#0,R0
		OR.B	#ESU,@(R0,GBR)		; SET ESU BIT
FERS10		DT	R9
		BF	FERS10			; ESU BIT SET WAIT
;
		MOV.L	#WTIME10000,R14
		MOV.L	@R14,R9			; SET ERASE TIME(10 msec)
		XOR	R0,R0
		MOV.L	#TCNT,R3
		MOV.L	R0,@R3			; CLEAR TIMER COUNT
;--------------- E BIT SET WAIT -------------------------------------------------
		MOV.B	#H'01,R0
		MOV.B	R0,@R10			; TIMER COUNT START
;
		NOP				; TIMER REVISION BY 6 STATES
		NOP
		NOP
		NOP
		NOP
		NOP
;
		MOV.B	#0,R0
		OR.B	#E,@(R0,GBR)		; SET E BIT(ERASE START)
FERS20		MOV.L	@R3,R2
		CMP/GE	R9,R2			; E BIT SET WAIT(ERASE TIME)
		BF	FERS20
;
		AND.B	#E_N,@(R0,GBR)		; CLEAR E BIT(ERASE STOP)
		XOR	R0,R0
		MOV.B	R0,@R10			; STOP TIMER COUNT
;--------------------------------------------------------------------------------
		MOV.L	#WLOOP10,R14
		MOV.W	@R14,R3	
FERS30		DT	R3
		BF	FERS30			; E BIT CLEAR WAIT 
;
		MOV.L	#WLOOP10,R14
		MOV.W	@R14,R3	
		MOV.B	#0,R0
		AND.B	#ESU_N,@(R0,GBR)	; CLEAR ESU BIT
FERS40		DT	R3			; ESU CLEAR WAIT
		BF	FERS40
;
		MOV.L	#TCSR,R12		; STOP WATCH DOG TIMER COUNT
		MOV.W	#H'A558,R0
		MOV.W	R0,@R12
;
		MOV.L	#H'00,R0
		MOV.B	R0,@R11			; CLEAR ERASED BLOCK BIT OF EBR
;
		RTS
		NOP
;
;********************************************************************************
; * TITLE / SUM CHECK								*
; * FUNCTION / SUM ALL DATA OF FLASH MEMORY AS LONG DATA AND SEND TO HOST	*
; * INPUT  / R0 = START ADDRESS OF FLASH MEMORY					*
; * 	     R1 = START ADDRESS OF FLASH MEMORY					*
; * OUTPUT / R3 = CHECK SUM VALUE 						*
; *******************************************************************************
CHECKSUM	.EQU	$
		STS	PR,@-R15
		MOV.L	#START_ADDRESS,R0	; SET START ADDRESS OF FLASH MEMORY
		MOV.L	#END_ADDRESS,R1		; SET END ADDRESS OF FLASH MEMORY
;
		MOV.L	#H'00000000,R3		; INITIALIZE SUM VALUE
		MOV.L	#H'00000000,R4		; INITIALIZE WORK AREA
;
CHECKSUM10	MOV.B	@R0+,R4			; READ FLASH MEMORY DATA BY BYTE
		EXTU.B	R4,R4
		ADD	R4,R3			; SUM READ DATA
		CMP/HS	R0,R1			; ALL FLASH MEMORY DATA READ
		BT	CHECKSUM10
;
		MOV.L	R3,R2			; SEND SUM VALUE(4 BYTE) TO HOST
;
		SWAP.W	R2,R2
		BSR	TRS1BYTE		; SEND UPPER 1 BYTE OF UPPER WORD
		SWAP.B	R2,R2
;
		BSR	TRS1BYTE		; SEND LOWER 1 BYTE OF UPPER WORD
		SWAP.B	R2,R2
;
		SWAP.W	R2,R2
		BSR	TRS1BYTE		; SEND UPPER 1 BYTE OF LOWER WORD
		SWAP.B	R2,R2
;
		BSR	TRS1BYTE		; SEND LOWER 1 BYTE OF LOWER WORD
		SWAP.B	R2,R2
		LDS	@R15+,PR
		RTS
		NOP
;
	.POOL
; MEMORRY BLOCK TABLE 
; START ADOORESS OF MOMORY BLOCK
	.ALIGN	4
BLOCKADR1	.EQU	$
		.DATA.L		H'00000000	; EB0		 4 KBYTE
		.DATA.L		H'00001000	; EB1		 4 KBYTE
		.DATA.L		H'00002000	; EB2		 4 KBYTE
		.DATA.L		H'00003000	; EB3		 4 KBYTE
		.DATA.L		H'00004000	; EB4		 4 KBYTE
		.DATA.L		H'00005000	; EB5		 4 KBYTE
		.DATA.L		H'00006000	; EB6		 4 KBYTE
		.DATA.L		H'00007000	; EB7		 4 KBYTE
		.DATA.L		H'00008000	; END ADDRESS OF EBR1
BLOCKADR2	.EQU	$
		.DATA.L		H'00008000	; EB8		32 KBYTE
		.DATA.L		H'00010000	; EB9		64 KBYTE
		.DATA.L		H'00020000	; EB10		64 KBYTE
		.DATA.L		H'00030000	; EB11		64 KBYTE
		.DATA.L		H'00040000	; EB12		64 KBYTE
		.DATA.L		H'00050000	; EB13		64 KBYTE
		.DATA.L		H'00060000	; EB14		64 KBYTE
		.DATA.L		H'00070000	; EB15		64 KBYTE
		.DATA.L		H'00080000	; END ADDRESS OF EBR2
;
		.END