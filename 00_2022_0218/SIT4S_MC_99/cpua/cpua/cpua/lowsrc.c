/***********************************************************************/
/*                                                                     */
/*  FILE        :lowsrc.c                                              */
/*  DATE        :Fri, May 31, 2002                                     */
/*  DESCRIPTION :Program of I/O Stream                                 */
/*  CPU TYPE    :SH7750                                                */
/*                                                                     */
/*  This file is generated by Hitachi Project Generator (Ver.2.1).     */
/*                                                                     */
/***********************************************************************/
                  



/************************************************************************/
/*		       lowsrc.c:					  							*/
/*----------------------------------------------------------------------*/
/*         SH-series simulator debugger interface routine		  		*/
/*   - Only standard I/O files (stdin, stdout, stderr) are supported    */
/************************************************************************/
#include <string.h> 
#include <stdio.h>
#include <stddef.h>
#include "lowsrc.h"

/* file number */

#define STDIN  0                       /* Standard input (console)        */
#define STDOUT 1                       /* Standard output (console)       */
#define STDERR 2                       /* Standard error output (console) */

#define FLMIN  0                       /* Minimum file number             */
#define FLMAX  3                       /* Maximum number of files         */

/* file flag */

#define O_RDONLY 0x0001                /* Read only                       */
#define O_WRONLY 0x0002                /* Write only                      */
#define O_RDWR   0x0004                /* Both read and write             */

/* special character code */

#define CR 0x0d                        /* Carriage return                 */
#define LF 0x0a                        /* Line feed                       */



const int _nfiles = IOSTREAM;
struct _iobuf _iob[IOSTREAM];
unsigned char sml_buf[IOSTREAM];


/**************************************************************************/
/* Declaration of reference function                                      */
/* Reference of assembly program in which the simulator debugger input or */
/* output characters to the console					  					  */
/**************************************************************************/
extern void charput(char);              /* One character input            */
extern char charget(void);              /* One character oputput          */

/**************************************************************************/
/* Definition of static variable:					  					  */
/* Definition of static variables used in low-level interface routines    */
/**************************************************************************/

char flmod[FLMAX];                   /* Open file mode specification area */

                                     /*                           by sbrk */
/**************************************************************************/
/*       open:file open							  						  */
/*          Return value:File number (Pass)								  */
/*                       -1          (Failure)							  */
/**************************************************************************/
int open(char *name,                    /* File name			  */
     int mode)							/* File mode			  */
{
#if 0
/*************************************************************************** çÌèú  A.Shima
    /* Check mode depending on file name and return file numbers          */

     if(strcmp(name,"stdin")==0){       /* Standard input file	 	  */
            if((mode&O_RDONLY)==0)
                     return -1;
	    flmod[STDIN]=mode;
	    return STDIN;
     }

     else if (strcmp(name,"stdout")==0){ /* Standard output file          */
            if((mode&O_WRONLY)==0)
                     return -1;
	    flmod[STDOUT]=mode;
	    return STDOUT;
     }

     else if (strcmp(name,"stderr")==0){ /* Standard error file           */
            if((mode&O_WRONLY)==0)
                     return -1;
	    flmod[STDERR]=mode;
	    return STDERR;
     }

     else
            return -1;                   /* Error			  */
***************************************************************************/
#endif
}

/**************************************************************************/
/*   close:File close													  */
/*	   Return value:0 (pass)											  */
/*	                -1 (Failure)										  */
/**************************************************************************/
int close(int fileno)                      /* File number		  */
{
      if(fileno<FLMIN || FLMAX<fileno)     /* File number range check     */
           return -1;

      flmod[fileno]=0;			   /* File mode reset		  */
      return 0;
}

/**************************************************************************/
/* read:Data read     								 					  */
/*	Return value:Number of read characters (Pass)						  */
/*	             -1                        (Failure)					  */
/**************************************************************************/
int read(int  fileno,                      /* File number		  */
        char *buf,                         /* Destination buffer address  */
        unsigned int  count)               /* Number of read characters   */
{
      unsigned int i;

   /*Check mode according to file name and stores each character in buffer*/

      if(flmod[fileno]&O_RDONLY||flmod[fileno]&O_RDWR){
	    for(i=count; i>0; --i){
		  *buf=charget();
		  if(*buf==CR)           /*Line feed character replacement*/
			*buf=LF;
		  buf++;
	    }
	    return count;
       }
       else
            return -1;
}

/**************************************************************************/
/* write:Data write   		 											  */
/*	Return value:Number of write characters (Pass)						  */
/*	             -1                         (Failure)					  */
/**************************************************************************/
int write(int  fileno,                     /* File number		  */
        char *buf,                         /* Destination buffer address  */
        unsigned int  count)               /* Number of write characters  */
{
       unsigned int i;
       char c;

       /* Check mode according to file name and output each character     */

       if(flmod[fileno]&O_WRONLY || flmod[fileno]&O_RDWR){
       	    for(i=count; i>0; --i){
		  c=*buf++;
		  charput(c);
	    }
            return count;
       }
       else
            return -1;
}

/**************************************************************************/
/* lseek:Definition of file read/write position							  */
/*	Return value:Offset from the top of file read/whrte position(Pass)	  */
/*	             -1              (Failure)								  */
/*	(lseek is not supported in the console input/output)				  */
/**************************************************************************/
long lseek(int  fileno,                    /* File number		  */
	   long offset,			   /* Read/write position	  */
	   int  base)			   /* Origin of offset		  */
{
     return -1;
}


/****************************************************************************/
/* _INIT_IOLIB                                                              */
/*	Initialize C library Functions, if necessary.			    */
/*	Define USES_SIMIO on Assembler Option.				    */
/****************************************************************************/
void _INIT_IOLIB(void)
{
/*************************************************************************** çÌèú  A.Shima
FILE *fp;

	for( fp = _iob; fp < _iob + _nfiles; fp++ )
	 {
		fp->_bufptr = NULL;
		fp->_bufcnt = 0;
		fp->_buflen = 0;
		fp->_bufbase = NULL;
		fp->_ioflag1 = 0;
		fp->_ioflag2 = 0;
		fp->_iofd = 0;
	 }

	if(freopen( "stdin", "r", stdin )==NULL)
		stdin->_ioflag1 = 0xff;
	stdin->_ioflag1 |= _IOUNBUF;
	if(freopen( "stdout", "w", stdout )==NULL)
		stdout->_ioflag1 = 0xff;
	stdout->_ioflag1 |= _IOUNBUF;
	if(freopen( "stderr", "w", stderr )==NULL)
		stderr->_ioflag1 = 0xff;
	stderr->_ioflag1 |= _IOUNBUF;
***************************************************************************/
}

/****************************************************************************/
/* _CLOSEALL                                                                */
/****************************************************************************/

void _CLOSEALL(void)
{
int i;

	for( i=0; i < _nfiles; i++ )
		if( _iob[i]._ioflag1 & (_IOREAD | _IOWRITE | _IORW ) )
			fclose( & _iob[i] );
}


