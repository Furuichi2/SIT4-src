/***********************************************************************/
/*                                                                     */
/*  FILE        :cpua.c                                                */
/*  DATE        :Mon, Jun 24, 2002                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :SH7750                                                */
/*                                                                     */
/*  This file is generated by Hitachi Project Generator (Ver.1.1).     */
/*                                                                     */
/***********************************************************************/
                  


#ifdef __cplusplus
//#include <ios>					// Remove the comment when you use ios                  
//int ios_base::Init::init_cnt;		// Remove the comment when you use ios
#endif
#ifdef __cplusplus
extern "C" {
#endif
void main(void);
#ifdef __cplusplus
}
#endif


#include	"cm_equ1.h" 
#include	"ssc_wram.h"


extern	void INT_EI(void);		// hwsetup.src

extern	void SR_INIT_SET(void);		// p4a_com1.src(共通演算)
extern	void SR_MAIN_SET(void);		// p4a_com1.src(共通演算)

//

extern	void ASM_DMK1_SOFT_INIT(void);//p4a_k.src
extern	void ASM_DMY1_SOFT_INIT(void);//p4a_y.src
//extern	void c_dmk1_soft_init(void);//p4c_k.c(割込解除前にする)
//extern	void c_dmy1_soft_init(void);//p4c_y.c(割込解除前にする)

//extern	void c_dmk1_data_main(void);	//ssc_k.c
//extern	void c_dmy1_data_main(void);	//ssc_y.c
//extern	void c_k1_ctrl_main(void);	//ssc_k.c
//extern	void c_y1_ctrl_main(void);	//ssc_y.c

extern	void ASM_VUP_MAIN();	//メインスキャン
extern	void ASM_Y1_CTRL_MAIN();	//メインスキャン
extern	void ASM_DMK1_DATA_INIT();

extern	void SEQ_INIT(void);		//ssa_seqm.src

extern	void IOGA_OUT_INIT(void);	//ssa_dio.src
extern	void IOGA_DI_LOAD(void);	//ssa_dio.src
//extern	void SEQ_CB_WKINRAM_SET(void);	//ssa_dio.src

extern	void POS_LSI_START(void);	//ssa_dio.src
extern	void POS_LSI_LATCH(void);	//ssa_dio.src

extern	void SEQ_RUN_MAIN(void);	//ｼｰｹﾝｽ処理
//extern	void SEQ_CB_DP_WR(void);	//クラッチで使用しているデータをDPRAMへ転送

extern	void RM_RDENB_ON(void);		//ssa_dio.src リモート RDENB ON
extern	void ROM_SYSPAR_CMP_CHK(void);	//ssa_erry.inc シスパラ比較

extern	void draw_smple(void);

//	2002-12-17
extern	U2b	CPUBA_HD_INDT1;
extern	void CPUBA_HAND_INPORT_LOAD(void);

//	2008-08-01
extern	REMOTE_INDT_READ(void);		//; リモート入力読み込み(元々有り)
extern	SQ_CARD_IN_REF1(void);		//2008-08-01




//	2013-12-11 [mc]
extern	void CPUD_START_CHK(void);
extern	U2b CPUD_START_OK;
extern	U2b SPL_ERR_INIT_WAIT_TIM;//5秒 2015-02-07




void data_init1(void)
{
	ASM_DMK1_DATA_INIT();		//ｼｽﾊﾟﾗ/設定/ﾃﾞｰﾀ転送:ﾏｽﾀのみの処理
	ASM_DMY1_DATA_INIT();		//


//	c_dmk1_data_init();		//ssc_k.c:位置決めのｲﾆｼｬﾙ処理(ﾏｽﾀ/OPTION同一):ｱﾄﾞﾚｽ設定
//	c_dmy1_data_init();		//ssc_y.c
}

#define		init_wt2_tim	50	//2ms*50=100ms

void data_init2(void)
{

	SEQ_INIT();				//ssa_seqm.src

	data_init2_timer = init_wt2_tim;	//

	while(data_init2_timer){
		WDT_Rifresh();			//

		REMOTE_INDT_READ();		//; リモート入力読み込み
		SQ_CARD_IN_REF1();		//2008-08-01

		IOGA_DI_LOAD();			//ssa_dio.src
		SEQ_CB_WKINRAM_SET();		//ssa_dio.src
		POS_LSI_START();		//ssa_dio.src
		POS_LSI_LATCH();		//ssa_dio.src
	}

	SPL_ERR_INIT_WAIT_TIM=5000;//5秒 2015-02-07

	RM_RDENB_ON();				//ssa_dio.src リモート RDENB ON
//	ROM_SYSPAR_CMP_CHK();		//ssa_erry.inc シスパラ比較



}


extern	ASM_K1_CTRL_MAIN(void);
extern	S2b	CMP_ERR_STSA_INF4;
void TestFunc(void);

void main(void)
{
//;	*******************************************
//;	***	割込み許可前1回処理		***
//;	*******************************************

	IOGA_OUT_INIT();		//ssa_dio.src

//"FIRST"
	ASM_DMK1_SOFT_INIT();		//cb_src\k_src\ssa_k.src
	ASM_DMY1_SOFT_INIT();		//cb_src\y_src\ssa_y.src


//	c_dmk1_soft_init();		//cb_src\k_src\ssc_k.c(割込解除前にする)
//	c_dmy1_soft_init();		//cb_src\y_src\ssc_y.c(割込解除前にする)

	SR_INIT_SET();			//cb_src\comon\ssa_com1.src

	INT_EI();

//	=============================================== //
//	===	タイムアウト付	2002-12-17 ﾊﾝﾄﾞｼｪｲｸ待ち		//
//	==============================================  //
	data_init2_timer =30000;//30.000*2=60秒
	while(data_init2_timer){
		WDT_Rifresh();		//2002-12-17

		CPUBA_HAND_INPORT_LOAD();//CPUBA_HD_INDT1;<=
		CPUD_START_CHK();
		if(CPUD_START_OK){//CPUD 移動
			if(CPUBA_HD_INDT1&cBIT15){//CPUB起動[dpram参照ok]
				data_init2_timer =0;
			}
		}

		//2013-12 mc CPUBA_HAND_INPORT_LOAD();//CPUBA_HD_INDT1;<=
		//2013-12 mc if(CPUBA_HD_INDT1&cBIT15){//"H" END
		//2013-12 mc 	data_init2_timer =0;
		//2013-12 mc }
	}





//;	*******************************************
//;	***	割込み許可後1回処理		***
//;	*******************************************
	data_init1();			//ｲﾆｼｬﾙﾃﾞｰﾀｾｯﾄ

//;	*******************************************
//;	***	SH2からの動作許可後処理		***
//;	*******************************************
	SR_MAIN_SET();			//cb_src\comon\ssa_com1.src

	data_init2();			//ｲﾆｼｬﾙﾃﾞｰﾀｾｯﾄ


//;	*******************************************
//;	***	MAINｽｷｬﾝ処理			***
//;	*******************************************
	while(1){
	
		WDT_Rifresh();		//

///////		IOGA_DI_LOAD();			//ssa_dio.src
///////		SEQ_CB_WKINRAM_SET();		//ssa_dio.src

//		c_dmk1_data_main();		//ssc_k.c
//		c_dmy1_data_main();		//ssc_y.c
		ASM_K1_CTRL_MAIN();
////		c_k1_ctrl_main();		//ssc_k.c
//		c_y1_ctrl_main();		//ssc_y.c

		ASM_Y1_CTRL_MAIN();		//メインスキャン

///////		SEQ_CB_DP_WR();			//クラッチで使用しているデータをDPRAMへ転送

		ASM_VUP_MAIN();

//
//		TestFunc();

	}

}



/*	*******************************************		*/
/*	***										***		*/
/*	***										***		*/
/*	***										***		*/
/*	***										***		*/
/*	***										***		*/
/*	***										***		*/
/*	***										***		*/
/*	***										***		*/
/*	***										***		*/
/*	***										***		*/
/*	***										***		*/
/*	***										***		*/
/*	*******************************************		*/
/*	4byte*4byte=8byte								*/
/*	4byte*4byte/4byte=4byte							*/
/*	8byte/4byte=4byte								*/
/*	8byte+8byte										*/
/*	8byte-8byte										*/
/*	cmp 8byte										*/
/*	intel 											*/
/*	+0(LL),1(LM),2(LH),3(ML)						*/
/*	+4(MH),5(HL),6(HM),7(HH)						*/
/*	INTEL/MOTで使用できること　ansはintelだけど		*/

/*	*******************************************************		*/
/*	***													***		*/
/*	***		4byte(31bit)*4byte(31bit)=8byte(62bit)		***		*/
/*	***													***		*/
/*	***													***		*/
/*	*******************************************************		*/
void intel_Mul_S4b_S4b_ansS8b(signed long mul_dat1,signed long mul_dat2,signed long *data8b){
	signed char shin=0;
	unsigned long dat1_L,dat1_H;
	unsigned long dat2_L,dat2_H;

	/* 途中の計算　4回の掛け算 */
	unsigned long dat_1L2L,dat_1H2L,dat_1L2H,dat_1H2H;
	unsigned short dat[4];
	unsigned long wk4b1,wk4b2;

	if(mul_dat1<0){
		mul_dat1=0-mul_dat1;
		shin +=1;
	}
	dat1_H=mul_dat1/0x10000;
	dat1_L=mul_dat1-(dat1_H*0x10000);


	if(mul_dat2<0){
		mul_dat2=0-mul_dat2;
		shin -=1;
	}
	dat2_H=mul_dat2/0x10000;
	dat2_L=mul_dat2-(dat2_H*0x10000);

	dat_1L2L=dat1_L*dat2_L;
	dat_1H2L=dat1_H*dat2_L;
	dat_1L2H=dat1_L*dat2_H;
	dat_1H2H=dat1_H*dat2_H;

	wk4b1=dat_1L2L/0x10000;
	dat[0]=dat_1L2L-wk4b1*0x10000;		/* LL(word) bit0~bit15 */

	wk4b1=wk4b1+dat_1H2L;
	if(wk4b1<dat_1H2L){	/* 桁上げが発生した */
		dat_1H2H=dat_1H2H+0x10000;		/* bit32~bit47の足し算 */
	}

	wk4b1=wk4b1+dat_1L2H;
	if(wk4b1<dat_1L2H){						/* 桁上げが発生した */
		dat_1H2H=dat_1H2H+0x10000;			/* bit32~bit47の足し算 */
	}
	wk4b2=wk4b1/0x10000;
	dat[1]=wk4b1-wk4b2*0x10000;				/* LH(word) bit16~bit31 */

	wk4b2=wk4b2+dat_1H2H;
	wk4b1=wk4b2/0x10000;
	dat[2]=wk4b2-wk4b1*0x10000;				/* bit32~bit47 */
	dat[3]=wk4b1;							/* bit48~bit63 */

	if(shin){
		dat[0]=~dat[0];
		dat[1]=~dat[1];
		dat[2]=~dat[2];
		dat[3]=~dat[3];
		dat[0]=dat[0]+1;
		if(dat[0]==0){	//桁上げ発生
			dat[1]=dat[1]+1;
			if(dat[1]==0){
				dat[2]=dat[2]+1;
				if(dat[2]==0){
					dat[3]=dat[3]+1;
				}
			}
		}
	}


	data8b[0]=dat[1]*0x10000+dat[0];
	data8b[1]=dat[3]*0x10000+dat[2];

}

/*	*******************************************************		*/
/*	***													***		*/
/*	***		8byte(63bit)*4byte(31bit)=4byte(31bit)		***		*/
/*	***													***		*/
/*	***													***		*/
/*	*******************************************************		*/
/*	割り算がオーバフロした場合はデータに0を返す */
S4b intel_Div_S8b_S4b_ansS4b(signed long *data8b,signed long div_dat){
	signed char shin=0;
	signed char overf=0;
	int i,cnt;
	unsigned long dat;
	unsigned long dat_L,dat_H;

	dat_L=data8b[0];
	dat_H=data8b[1];
	if(0x80000000<=dat_H){
		dat_L= ~dat_L;
		dat_H= ~dat_H;
		dat_L +=1;
		if(dat_L==0){
			dat_H +=1;
		}
		shin +=1;
	}

	if(div_dat<0){
		div_dat=0-div_dat;
		shin -=1;
	}

	if(div_dat==0){overf=1;}
	if(div_dat<=dat_H){overf=1;}

	if(overf==0){
		dat=0;

		dat_H=dat_H<<1;
		if(dat_L&0x80000000){
			dat_H |= 1;
		}else{
			dat_H &= 0xfffffffe;
		}
		dat_L=dat_L<<1;

		for(i=0;i<31;i++){

			if(div_dat<=dat_H){
				dat_H=dat_H-div_dat;
				dat |=1;
			}
			
			dat=(dat<<1);

			dat_H=dat_H<<1;
			if(dat_L&0x80000000){
				dat_H |=1;
			}else{
				dat_H &= 0xfffffffe;
			}
			dat_L=dat_L<<1;
		}

		if(div_dat<=dat_H){
			dat_H=dat_H-div_dat;
			dat |=1;
		}

	}
	if(shin){
		dat=0-dat;
	}

	return(dat);

}

/*	*******************************************************		*/
/*	***													***		*/
/*	***													***		*/
/*	***													***		*/
/*	*******************************************************		*/
void intel_S8bAddS8b_ansS8b(signed long *src_8b,signed long *add_8b,signed long *ansdata8b){
	unsigned long dat1_L,dat1_H;
	unsigned long dat2_L,dat2_H;
	unsigned long dat3_L,dat3_H;

	dat1_L=src_8b[0];
	dat1_H=src_8b[1];

	dat2_L=add_8b[0];
	dat2_H=add_8b[1];

	dat3_H=0;
	dat3_L=dat1_L+dat2_L;
	if(dat3_L<dat1_L){
		dat3_H=1;
	}
	dat3_H=dat3_H+dat2_H+dat1_H;
	ansdata8b[0]=dat3_L;
	ansdata8b[1]=dat3_H;


}
void intel_S8bSubS8b_ansS8b(signed long *src_8b,signed long *sub_8b,signed long *ansdata8b){
	unsigned long dat1_L,dat1_H;
	unsigned long dat2_L,dat2_H;
	unsigned long dat3_L,dat3_H;

	dat1_L=src_8b[0];
	dat1_H=src_8b[1];

	dat2_L=sub_8b[0];
	dat2_H=sub_8b[1];

	dat3_H=0;
	dat3_L=dat1_L-dat2_L;
	if(dat3_L<dat1_L){
		dat3_H=1;
	}
	dat3_H=dat1_H-dat2_H-dat3_H;
	ansdata8b[0]=dat3_L;
	ansdata8b[1]=dat3_H;
}


/*	*******************************************************		*/
/*	***													***		*/
/*	***													***		*/
/*	***													***		*/
/*	*******************************************************		*/
void intel_CastExtU_4b_8b(long data ,signed long *ansdata8b){
	ansdata8b[0]=data;
	ansdata8b[1]=0;
}
void intel_CastExtS_4b_8b(long data ,signed long *ansdata8b){
	ansdata8b[0]=data;
	if(data&0x80000000){
		ansdata8b[1]=0xffffffff;
	}else{
		ansdata8b[1]=0;
	}
}

signed char intel_CmpS8b(signed long *src_8b,signed long *cmp_8b){
	signed char ans;	/* 0:data1=data2  1:data1>data2 -1:data1<data2 */
	if(src_8b[1]==cmp_8b[1]){
		if(src_8b[0]==cmp_8b[0]){
				ans=0;
		}else{
			if(src_8b[0]>cmp_8b[0]){
				ans=1;
			}else{
				ans=-1;
			}
		}
	}else{
		if(src_8b[1]>cmp_8b[1]){
			ans=1;
		}else{
			ans=-1;
		}
	}

	return(ans);
}

/*	*******************************************************		*/
/*	***													***		*/
/*	***													***		*/
/*	***													***		*/
/*	*******************************************************		*/
signed long intel_S4b_mul_S4b_Div_S4b_ansS4b(signed long mul_dat1,signed long mul_dat2,signed long div_dat){
	signed long data8b[2];
	signed long ansdata=0;
	if(div_dat){
		intel_Mul_S4b_S4b_ansS8b(mul_dat1,mul_dat2,&data8b[0]);
		ansdata=intel_Div_S8b_S4b_ansS4b(&data8b[0],div_dat);
	}

	return(ansdata);

}


/*	*******************************************************		*/
/*	***													***		*/
/*	***		8byte(63bit)*4byte(31bit)=4byte(31bit)		***		*/
/*	***													***		*/
/*	***													***		*/
/*	*******************************************************		*/
unsigned long Test1InData1;
unsigned long Test1InData2;
signed long Test1Out[2];
signed char Testuseful;
long Test_abnomalCnt;
long Test_nomalCnt;
unsigned long Test2OutData;



void TestFunc(void){
	long i,j;

	Testuseful=0;
	Test1InData1=0x1;
	Test1InData2=0x1;

	intel_Mul_S4b_S4b_ansS8b(Test1InData1,Test1InData2,&Test1Out[0]);
	Test2OutData=intel_Div_S8b_S4b_ansS4b(&Test1Out[0],Test1InData2);

	if(Testuseful){
		Testuseful=0;
		Test_abnomalCnt=0;
		Test_nomalCnt=0;

		Test1InData1=0x1;

		for(j=0;j<2000;j++){
			Test1InData2=0x1;
			for(i=0;i<200000;i++){
				intel_Mul_S4b_S4b_ansS8b(Test1InData1,Test1InData2,&Test1Out[0]);
				Test2OutData=intel_Div_S8b_S4b_ansS4b(&Test1Out[0],Test1InData2);
				if(Test2OutData!=Test1InData1){
					Test_abnomalCnt +=1;
				}else{
					Test_nomalCnt +=1;
				}
				Test1InData2=Test1InData2+1234;
			}
			
			Test1InData1=Test1InData1+456789;
		}
	
	
	}


}
//	確認ok箇所
//    Test1InData1    0x0B14CF24 (185913124)
//    Test1InData2    0x0D2B1CA7 (220929191)
//<-> Test1Out        {...}
// |____ [0]          0x2047107C (541528188)
// |____ [1]          0x0091EC41 (9563201)
//    Test2OutData    0x0B14CF24 (185913124)
//    Testuseful      '\0' 0x00 (0)
//    Test_abnomalCnt 0x00000000 (0)
//    Test_nomalCnt   0x04DCCC1B (81579035)

void abort(void)
{
	
}