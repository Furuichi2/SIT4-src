;	***************************************************
;	***						***
;	***						***
;	***	位置決め				***
;	***						***
;	***						***
;	***************************************************
	.LIST	OFF
	.INCLUDE	"cm_equ1.equ"		; //共通定義:必ず実行ﾌﾟﾛｸﾞﾗﾑにｲﾝｸﾙｰﾄﾞする事
	.INCLUDE	"shn_cmd1.mac"		; //
	.INCLUDE	"ssa_kmc1.mac"		; //
	.INCLUDE	"ssa_pfom.equ"		; //equ定義
	.INCLUDE	"ssa_khad.equ"		; //equ定義
	.INCLUDE	"ssa_wrmk.ext"		; //
	.INCLUDE	"ssa_krom.ext"		; //
	.INCLUDE	"ssa_ver1.equ"		; //
	.INCLUDE	"dp_label.ext"		; //

_TBLCURV		.DEFINE		"_CMPILE_YES"	;(SYSPARAMでｶｰﾌﾞ有/無)

;;;	============= 2013-03-07=======================
;;	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
;;_TBLCURV		.DEFINE		"_CMPILE_YES"	;CPUAは常にYESY:曲線ﾃｰﾌﾞﾙ(CPUAと同じ)
;;	.AELSE
;;		.AIF	_CPUB_TBLCURV EQ _CMPILE_YES	;CPUBの指定
;;
;;_TBLCURV		.DEFINE		"_CMPILE_YES"	;YES:曲線ﾃｰﾌﾞﾙ(CPUAと同じ)
;;
;;		.AELSE
;;
;;_TBLCURV		.DEFINE		"_CMPILE_NO"	;NO:直線タイプ
;;		.AENDI	
;;	.AENDI
;	================================================


	.IMPORT	_PAR_WTSEL_USE			

	.LIST	ON

	.SECTION	P,CODE			;


_SGL_CMPERR_CNTMAX	.EQU	20	;2;(600回確認済み) 2005-04-14(4/18)
_PLS_ERR_HABPLS1	.EQU	2000	;2000pls


_SYNC_ERR_HABPLS1	.EQU	6000	;2000pls(連続の異常範囲)
_SYNC_ERR_HOSHAB	.EQU	2000	;500pls(この範囲にある時補正はしない) 1msec=MAX500pls
_SYNC_ERR_HOSHAB_M	.EQU	100	;100pls(この範囲にある時補正はしない)

_SYNC_GEN_HOS_ERR	.EQU	100	;<==1000
_SYNC_GEN_HOS_HAB	.EQU	1	;<==10
_SYNC_GEN_HOS_ADD	.EQU	1	;

_LSI_RETRY_ERR_MAX	.EQU	3	;
_LSI_CMP_ERR_MAX	.EQU	10	;


_LSI_G_HOS_SPD		.EQU	15	;500K=65535 250K=32767 1%=327 0.1%=32 (15代わったら)
_DBG_XOR_SIG		.EQU	BIT3*H'10000	;

;;2015-07-07 移動 _OVRLIDE_LATE_MAX	.EQU	100		;1~100% 2006-09-19
_GENSOK_LNGTH_MAX	.EQU	30*500000	;30秒×500,000HZ=E4,E1C0 2006-09-19
_ACC_UNIT		.EQU	1000		;1msec 

_CMP_ERR_SPEC_ENB	.DEFINE	"_CMPILE_NO"	;//noなら新ｱｸｾｽ部のLSI異常を見ない
_OBJ_PLS_CTL_TYP	.DEFINE	"_CMPILE_YES"	;//


;	***********************************
;	***	2010-10-05		***
;	***********************************
_X_SET_PV_ABS_TO_OBJ			.DEFINE	"_dum_SET_PV_ABS_TO_OBJ"	;
_X_LINK_PV_ABSPLS			.DEFINE	"_LINK_RL_OBJ_ABSPLS"		;

	.IMPORT	_PV_POWER_ON_CNT			;
	.IMPORT	_CPU_CTRL_CLK				;

	.IMPORT	_SVP_MACINE_SEL1
	.IMPORT	_CHK_DNM_SPEC_MOD1


;	//	***********************************
;	//	***	EXTERN 宣言 PROGRAM	***
;	//	***********************************


	.IMPORT		_CPOS_INI1_DTMOV1;ssa_dtmk.src
	.IMPORT		_CPOS_INI1_DTMOV2;ssa_dtmk.src
	.IMPORT		_CPOS_ROT_NUM_SET;ssa_dtmk.src
	.IMPORT		_CPOS_ABS_POS_SET;ssa_dtmk.src
	.IMPORT		_CPOS_SPD_DTMOV
	.IMPORT		_CPOS_TIM_DTMOV

	.IMPORT		_HLDCAM_ABS_POS_SET		;ssa_dtmk.src 2014-08-30
	.IMPORT		_HLDCAM_BANK2_ABS_POS_SET	;ssa_dtmk.src 2014-08-30


	.IMPORT		_DIG_LNGTH_CALC1;ssa_sca1.src
;;;;	.IMPORT		_POS_INC_TO_OUT_CHG_MOD 使用されない
;;;;	.IMPORT		_POS_OUT_TO_INC_CHG　使用されない

	.IMPORT		_ORGIN_MODE_INI		;ssa_else.src
	.IMPORT		_ORGIN_MODE_SMP		;
	.IMPORT		_ORGIN_MODE_END		;
;;;;;	.IMPORT		_ORGIN2_MODE_END	;
	
	.IMPORT		_LOT_SIG_SET		;

	.IMPORT		_CYCLE_TIME_REFLASH_START
	.IMPORT		_CYCLE_TIME_REFLASH_END
	.IMPORT		_CYCLE_TIME_REFLASH_CLR

	.IMPORT		_NOW_INC_DIG_MAK	;DTMK

	.IMPORT	_DAT_MOSTPOS_SIG_CLR
	.IMPORT	_DAI_MOSTPOS_SMPINI
	.IMPORT	_DAI_MOSTPOS_SMPLE
	.IMPORT	_DAI_MOSTPOS_CMPARE

	.IMPORT	_DAI_FULL_SCALE_SMP_INI	;
	.IMPORT	_DAI_FULL_SCALE_SMPLE	;
	.IMPORT	_DAI_FULL_SCALE_SMP_END	;

	.IMPORT	_ORG_END_SIG_CLR;

	.IMPORT	_CMPAB_NEAR_END_PROC	;
	.IMPORT	_CMPAB_STEP_END_PROC	;

	.IMPORT	_CMPSTP_CTRL_REDY_CLR;//準備完了にしたい
	.IMPORT	_CMPSTP_CTRL_BUSY_CLR;//準備未完了にしたい
	.IMPORT	_CMPSTP_POS_START_CLR;//起動したい
	.IMPORT	_CMPSTP_SFTY_AUTO_CLR;//AUTOにしたい/安全一工程,連続ｶｳﾝﾀ
	.IMPORT	_CMPSTP_NEAR_ZERO_CLR;//ﾆｱｾﾞﾛ処理を行いたい
	.IMPORT	_CMPSTP_CNT_STOP_CLR;//連続停止
	.IMPORT	_CMPSTP_STEP_END_CLR;//位置決め完了としたい
	.IMPORT	_CMPCYC_START_CLR;//1ｻｲｸﾙ開始時/運転開始時(途中中断)
	.IMPORT	_CMPCYC_END_CLR;//1ｻｲｸﾙ開始時/運転開始時(途中中断)
	
	.IMPORT	_CMPEMG_EXQ_FLG_CLR;
	.IMPORT	_POS_CMP_1STEP_START_INI

	.IMPORT	_STOP_LTH_OUT
	.IMPORT	_LOT_SIG_FLG_CLR			;通常の連続
	.IMPORT	_STOPPING_TIM_STOP_INI

	.IMPORT	_POS_OVER_RUN_CHK1	;[S01m 2003-04-03]

	.IMPORT		_BRK_ERR_WORK_CLR1		;ERR1.SRC
;;;2013-02-05未使用	.IMPORT		_BRK_ERR_CHK_START1		;
;;;2013-02-05未使用	.IMPORT		_BRK_ERR_CHK_START2		;
;;;2013-02-05未使用	.IMPORT		_BRK_ERR_CHK_START3		;
	.IMPORT		_BRK_ERR_CHK_START4		;

	.IMPORT		_SET_NZ_TIM_DAT
	.IMPORT		_NZ_TIM_CHK1

;	======= 2004-12-20 ==
	.IMPORT		_BANK2_CPOS_ABS_POS_SET	;2004-12-20 ssa_dtmk
	.IMPORT		_BANK2_TO_BANK1_MOV	;

;	======= 2006-07-28 ==
	.IMPORT	_DND_POS_START_DAT_INI

	.AIF	_CB_CPU_SEL EQ	_CB_CPUA

	.IMPORT	_VIB_PLS_OUT_ON		;2010-08-23加振動制御 ssa_kjyu.inc
	.IMPORT	_VIB_PLS_OUT_OF		;2010-08-23加振動制御 ssa_kjyu.inc

	.IMPORT	_API_IVW_CYC_START			;2010-09-21
	.IMPORT	_API_IVW_CYC_END			;2010-09-21

;;;;;2012-10-19	.IMPORT	_OVERH_CYC_START			;2012-09-25
	.IMPORT	_OVERH_CYC_END				;2012-09-25

	.AENDI

	.IMPORT	_API_BREAK_VALV_FLG_ON
	.IMPORT	_API_BREAK_VALV_FLG_OF

;	//	***********************************
;	//	***	EXTERN 宣言 MEMORY,HARD	***
;	//	***********************************
	.IMPORT		_LONG_BIT_TBL0
	.IMPORT		_SQ_CBWK_TOP
;	====================================
	.GLOBAL		_SH4_HD_CTRL_REDY	;準備完了にしたい
	.GLOBAL		_SH2_HD_CTRL_REDY	;準備完了にしたい
	.GLOBAL		_SH4_HD_CTRL_BUSY	;準備未完了にしたい
	.GLOBAL		_SH2_HD_CTRL_BUSY	;準備未完了にしたい
	.GLOBAL		_SH4_HD_POS_START	;起動したい
	.GLOBAL		_SH2_HD_POS_START	;起動したい
	.GLOBAL		_SH4_HD_SFTY_AUTO	;AUTOにしたい/安全一工程,連続ｶｳﾝﾀ
	.GLOBAL		_SH2_HD_SFTY_AUTO	;AUTOにしたい/安全一工程,連続ｶｳﾝﾀ
	.GLOBAL		_SH4_HD_NEAR_ZERO	;ﾆｱｾﾞﾛ処理を行いたい
	.GLOBAL		_SH2_HD_NEAR_ZERO	;ﾆｱｾﾞﾛ処理を行いたい
	.GLOBAL		_SH4_HD_CNT_STOP	;連続停止<工夫必要>
	.GLOBAL		_SH2_HD_CNT_STOP	;連続停止<工夫必要>
	.GLOBAL		_SH4_HD_STEP_END	;位置決め完了としたい
	.GLOBAL		_SH2_HD_STEP_END	;位置決め完了としたい

;	==== 2003-07-09 ===
	.GLOBAL		_PAR_ORGDRV_MOD		;原点復帰方法変更
	.GLOBAL		_PAR_ORGDRV_CNT		;原点復帰回数0=1回 1=2回

	.GLOBAL		_PAR_INSERT_SMPTM	;2012-09-25
	.GLOBAL		_CB_SYS_PARAM000	;2012-09-25
	.GLOBAL		_PAR_INCSPD_UPLMT	;
	.GLOBAL		_PAR_STOPTIM_SEL	;

	.GLOBAL		_PVP_A_LOT_CNT1		;
	.GLOBAL		_PVP_B_LOT_CNT1		;
	.GLOBAL		_PVP_A_LOT_CNT2		;
	.GLOBAL		_PVP_B_LOT_CNT2		;
	.GLOBAL		_PVP_A_LOT_CNT3		;
	.GLOBAL		_PVP_B_LOT_CNT3		;
	.GLOBAL		_PVP_A_LOT_CNT4		;
	.GLOBAL		_PVP_B_LOT_CNT4		;
	.GLOBAL		_PVP_A_LOT_CNT5		;
	.GLOBAL		_PVP_B_LOT_CNT5		;

	.IMPORT		_PVP_CB_A_VER		;
	.IMPORT		_SH4_GPOINT_LNG		;
	.IMPORT		_SH2_GPOINT_LNG		;

	.IMPORT		_KJPHOS_SMPINI		;2004-07-05
	.IMPORT		_KJPHOS_SMPLING_END1	;2004-07-05

	.IMPORT		_ORIGIN_POS_CHK_INI2	;2011-03-23 待機点移動完了

	.IMPORT		_UP_ACCERR_START_INI	;2011-08-29

	.IMPORT		_PVPAB_KAJLIV_TTL		;//荷重生（TON）(1word)


	.IMPORT		_POS_HOLD_FLG_STR2CLR		;2014-09-12

;	//	***********************************
;	//	***	PUBLIC 宣言 PROGRAM	***
;	//	***********************************
	.EXPORT		_INT_POS_CTRL		;-->ssa_k.src
	.EXPORT		_INT_POS_DATA_REF	;-->ssa_k.src

	.EXPORT		_EMG_POS_FLG_PROC
	.EXPORT		_EXQ_POS_FLG_PROC

	.EXPORT		_MN_POS_CTRL_START		;===>ssa_ctrl
	.EXPORT		_MN_POS_CTRL_ACT		;===>ssa_ctrl

	.EXPORT		_FWD_REV_STSIG_OFF	;SSA_CTRL1 2004-01-26
	.EXPORT		_POS_LSI_SLOW_STOP	;SSA_CTRL1 2004-01-26

	.EXPORT	_POS_LSI_START_INITAL		;SPEED,LATE
	.EXPORT	_POS_LSI_TOP_SPEED_SET	;SPEED
	.EXPORT	_LENGH_ADD_CALC		;
	.EXPORT	_LENGH_ADD_CALC_SV_TYPE	;

	.EXPORT	_POS_LENGTH_ADD_DATA	;
	.EXPORT	_POS_PLS_OUTPUT_DATA	;位置決めLSIｱｸｾｽ(毎ｽｷｬﾝ)
	.EXPORT	_FWD_REV_START		;起動
	.EXPORT	_LOD_POS_STS_REG	;
	.EXPORT	_LOD_POS_STS_REG_POR	;
	.EXPORT	_FWD_REV_STSIG_OFF_SPEC	;
	
	.EXPORT	_SET_PV_ABS_TO_OBJ	;20060919
	.EXPORT	_CHG_LSI_LATE_TO_PLS	;20060919
	.EXPORT	_OVERLID_DEF_SET	;20060919

	.IMPORT	_DIG01_CHG_DN_DATA_MAKE	;[20091007下振子]

	.IMPORT		_DIG36000_CHG_RENEA1		;360.00度-->0.001mm
	.IMPORT	_SVP_UPAREA_SPD0	;0.1%　戻り速度

;	------
	.IMPORT	_CYCLE_SPD1		;

	.IMPORT	_INC_RST_WORK_CLR	;

;;;	_BRK_SADOU_CHG EQ _CMPILE_YES
;	------ 2015-09-06(H2W 2015-03-15,H1F 2015-07-14)-------
;	-------- 2015-07-14------
	.IMPORT	_PAR_MYUBRK_TIM1	;[H1F=未作or無][H2W=2015-03-16 行程終了時　ﾐｭｰﾃﾝｸﾞ切替時間]
	.IMPORT	_PAR_MYUBRK_TIM2	;[H1F=未作or無][H2W=2015-03-16 終了時　ﾐｭｰﾃﾝｸﾞ切替時間]
	.IMPORT	_PAR_MYU_BRK_SEL	;[H1F=未作or無][H2W=2015-03-16 0:　1:ﾐｭｰﾃﾝｸﾞ時=BRK:LOCK]
	.IMPORT	_PAR_SELF_WAIT_TM	;P22ｾﾙﾌﾁｪｯｸまたは位置決めからﾛｯｸ開始遅延時間(停止確認用)

;	***************************************************
;	***						***
;	***						***
;	***						***
;	***		位置決めＬＳＩアクセス		***
;	***						***
;	***						***
;	***						***
;	***************************************************
;	?加減速時間の演算と指令周波数の演算
;	P27の指令ﾊﾟﾙｽREGのADDとP39の正確な位置決めができませんはなに？
;	"_poslsi1_top"
;	*ﾊﾟﾙｽ列の払い出しは指令ﾊﾟﾙｽｶｳﾝﾀの減算量
;	*速度周波数の演算
;	*ベース周波数=1?
;	*加速時間
;	*急停止の時間
;	***********************************
;	***				***
;	***	ﾊｰﾄﾞｳｴｱｲﾆｼｬﾙ		***
;	***				***
;	***********************************
;	25MHZ*1/N*1/LATE=65535
	.IMPORT	_poslsi1_top
;;;;_PLS_OUTPUT_MAX		.EQU	H'7FFF	;
_PLS_OUTPUT_MAX		.EQU	H'00FFFFFF;128倍までは余裕あり
_PLSI_CH1		.equ	0
_PLSI_CH2		.equ	h'30

_PLS_BitComdL		.equ	h'0	;R/W
;;_PLS_BitComdH		.equ	h'2	;R/W
_PLS_BitInfoL		.equ	h'4	;R
;;_PLS_BitInfoH		.equ	h'6	;R
_PLS_TopFreqL		.EQU	H'8	;R/W ﾄｯﾌﾟ周波数
;;_PLS_TopFreqH		.EQU	H'A	;R/W
_PLS_BasFreqL		.EQU	H'C	;R/W ﾍﾞｰｽ周波数
;;_PLS_BasFreqH		.EQU	H'E	;R/W
_PLS_NowFreqL		.EQU	H'10	;R/W 現在周波数
;;_PLS_NowFreqH		.EQU	H'12	;R/W
_PLS_OutPposL		.EQU	H'14	;R/W 指令ﾊﾟﾙｽ数(これに払い出したいﾃﾞｰﾀを入れる:残量ｶｳﾝﾀでもある)
;;_PLS_OutPposH		.EQU	H'16	;R/W
_PLS_GNpointL		.EQU	H'18	;R/W 減速点
;;_PLS_GNpointH		.EQU	H'1A	;R/W
_PLS_AccLate1		.EQU	H'1C	;R/W 通常運転加減速(減速指令時)
_PLS_AccLate2		.EQU	H'1E	;R/W 急停止加減速(急停止指令時)
_PLS_SpedLate		.EQU	H'20	;R/W 周波数のLATE
_PLS_OutcntPS		.EQU	H'22	;R/W 指令ﾊﾟﾙｽｶｳﾝﾀ(1回の起動での払出ﾊﾟﾙｽ数up-cnt)
_PLS_NowPos1L		.equ	h'24
;;_PLS_NowPos1H		.equ	h'26
_PLS_NowPos2		.equ	h'28
_PLS_CtrlReg		.equ	h'2A


_PLSI_CH_COM		.EQU	0
_PLS_LTCHReg		.EQU	H'7E	;LATCH

;	*******************************************
;	***					***
;	***	DE LATCH			***
;	***	32BIT ﾃﾞｰﾀを読み込む時のラッチ	***
;	***					***
;	*******************************************
	.MACRO	PLS_READ_LATCH		;ﾚｼﾞｽﾀ破壊せず
	PUSH_REG1 R0						;
	MOV.L	#_poslsi1_top+_PLSI_CH_COM+_PLS_LTCHReg,R0	;
	MOV.W	@R0,R0						;
	POP_REG1 R0						;
	.ENDM

;	***************************************************
;	***	*CSを一旦上げてWAITを作成する為		***
;	***************************************************
	.MACRO	POS_LSI_WORD_DUM_LOD	;ﾚｼﾞｽﾀ破壊せず
	PUSH_REG1 R0
	MOV.L	#_PVP_CB_A_VER,R0	;
	MOV.W	@R0,R0
	POP_REG1 R0
	.ENDM

	.MACRO	POSLSI_RD_WR_WAIT_NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	.ENDM

	.MACRO	TIM_CNT_ADD MEM,LG,ADR_REG,DAT_REG,LATE
	MOV.L	#\MEM,\ADR_REG		;
	MOV.\LG	@\ADR_REG,\DAT_REG	;
	ADD	#\LATE,\DAT_REG		;
	MOV.\LG	\DAT_REG,@\ADR_REG	;
	.ENDM

	.MACRO	eSHi_SET_MEM_MOV SRC,L1,DST,L2
	PUSH_REG1 R0
	PUSH_REG1 R1
	MOV.L	#\SRC,R1	;
	MOV.\L1	@R1,R0		;
	MOV.L	#\DST,R1	;
	MOV.\L2	R0,@R1		;
	POP_REG1 R1
	POP_REG1 R0
	.ENDM

	.MACRO	eSHi_SET_REG_MOV DST,L1,SETREG,WKREG1
	PUSH_REG1 \WKREG1		;
	MOV.L	#\DST,\WKREG1		;
	MOV.\L1	\SETREG,@\WKREG1	;
	POP_REG1 \WKREG1		;
	.ENDM

	.MACRO	eSHi_SET_IM_MOV DST,L1,WKREG1,WKREG2,IMD
	PUSH_REG1 \WKREG1		;
	PUSH_REG1 \WKREG2		;
	MOV.W	#\IMD,\WKREG2		;
	MOV.L	#\DST,\WKREG1		;
	MOV.\L1	\WKREG2,@\WKREG1	;
	POP_REG1 \WKREG2		;
	POP_REG1 \WKREG1		;
	.ENDM



;	*******************************************
;	***	WRITEｱｸｾｽ開始時にON(H)		***
;	*******************************************

	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
	.IMPORT	_PDTRA
	.AENDI

	.MACRO	DEBUG_LSI_ACS_ON2_BIT BITDT

	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
;;	(波形測定時)
	PUSH_REG1 R0
	PUSH_REG1 R1
	PUSH_REG1 R2
	MOV.L	#_PDTRA,R1			;
	MOV.W	@R1,R0				;
	MOV.W	#\BITDT,R2			;
	OR	R2,R0				;
	MOV.W	R0,@R1				;

	POP_REG1 R2
	POP_REG1 R1
	POP_REG1 R0
	.AENDI

	.ENDM

	.MACRO	DEBUG_LSI_ACS_OF2_BIT BITDT

	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
;;	(波形測定時)
	PUSH_REG1 R0
	PUSH_REG1 R1
	PUSH_REG1 R2
	MOV.L	#_PDTRA,R1			;
	MOV.W	@R1,R0				;
	MOV.W	#LWORD ~\BITDT,R2		;
	AND	R2,R0				;
	MOV.W	R0,@R1				;
	POP_REG1 R2
	POP_REG1 R1
	POP_REG1 R0
	.AENDI

	.ENDM



;	***********************************
;	***				***
;	***	起動時呼ばれる		***
;	***				***
;	***********************************
;
;	・データのラッチ
	.IMPORT	_CPUB_HENSA_FLG_CLR		;2012-02-08
;
	.ALIGN	4				;
_MN_POS_CTRL_START:		;ssa_pos1.src
	SUB_START


;	----------2014-11-10------------
	XOR	R2,R2
	MOV.L	#_CPOS_CTL_MATH,R1			;
	MOV.W	@R1,R0					;
	TST	#_DMATH_DNDRIV,R0			;往復?
	TST_BIT_OF MN_POSCTL_ST050			;違う

	MOV.L	#_MODE_SEL,R1				;
	MOV.W	@R1,R0					;
	TST	#(_W1OPT+_W1CNT+_W1SGL+_W1INC),R0	;
	TST_BIT_OF MN_POSCTL_ST050			;

	MOV.B	#BIT0,R2				;対象運転開始

MN_POSCTL_ST050						;
	MOV.L	#_MOVE_MODE_MATH_LATCH,R1		;//0:(ふりこ以外 または 段取・原点モード)1:(ふりこでﾓｰｼｮﾝしていた)
	MOV.W	R2,@R1					;
;	--------------------------------------------------

;	-------- 2013-02-08-------
;;;;;	MOV.L	#_CPOS_CTL_MATH,R1		;
;;;;;	MOV.W	@R1,R0				;
;;;;;	TST	#_DMATH_DNDRIV,R0		; 往復?
;;;;;	TST_BIT_OF MN_POSCTL_ST200		;

	FAR_JSR	#_CPUB_HENSA_FLG_CLR,R0		;

;;;;;MN_POSCTL_ST200:				;

;	--------------- 2014-09-12 [HLD後の起動なので再演算しない]-------
;;;;収集が付かないのでSET_PV_ABS_TO_OBJの中で抜ける	MOV.L	#_POS_HOLD_RDY_EXITF,R1		;
;;;;収集が付かないので	MOV.W	@R1,R0				;
;;;;収集が付かないので	TST	#BIT0,R0			;
;;;;収集が付かないので	TST_BIT_ON MN_POSCTL_START_050		;

;	======== 20060919 ======================
;	CPUBは自分の払いだした量だけ動作しない。そのため位置がづれるので、停止後はからなず必要
;;;;;;	FAR_JSR	#_X_SET_PV_ABS_TO_OBJ,R0
;	=======================================

;;;;収集が付かないので	M_BRA	MN_POSCTL_START_060		;
;;;;収集が付かないので
;;;;収集が付かないのでMN_POSCTL_START_050:
;;;;収集が付かないので	NOP
;;;;収集が付かないのでMN_POSCTL_START_060:

	FAR_JSR	#_PRESET_PV_ABS_TO_OBJ,R0	;





;	--------------2013-02-15 寸動制限------------
	FAR_JSR	#_INC_UPLIMT_CALC,R0	;


;	=== 2005-04-14-E(4/18) ====
	FAR_JSR	#_SGL_CMP_ERR_DT_CLR,R0

;	----- [2009-10-07下振子]-----
	FAR_JSR	#_DNM_CYCLE_START,R0	;

	FAR_JSR	#_CPOS_INI1_DTMOV1,R0		;//運転ﾃﾞｰﾀﾗｯﾁ
	FAR_JSR	#_DND_POS_START_DAT_INI,R0	;2006-07-28

	FAR_JSR	#_LSI_REST_PLS_CHK_START_CLR,R0	;
	FAR_JSR	#_GPOSIN_HOS_DRV_INI,R0

	XOR	R2,R2
	MOV.L	#_INT_DND_CTL_STEP,R1;
	MOV.W	R2,@R1
	MOV.L	#_INT_DND_STEP_FLG,R1	;//(上死点復帰の工程管理)
	MOV.W	R2,@R1
;;;	================= なぜこのフラグがＯＦＦしていない？ =======
	XOR	R0,R0				;(1ｻｲｸﾙ完了時にOFFしていないとならない信号なのに)
	MOV.L	#_INT_POS_CTL_FLAG,R1		;
	MOV.W	R0,@R1				;

;	=== 2004-12-20 ===
	MOV.L	#_CNT_STOP_CTRL_FLG,R1	;//BIT0,BIT1:差し引き終了
	MOV.W	R0,@R1				;

	FAR_JSR	#_CNTREST_HOS_RESET,R1	;

;	=== 2004-01-26 CCS===
	XOR	R0,R0
	MOV.L	#_CCS_BTTN_OFF,R1		;両手ON以外の状態が運転中にあった。必ずいつか止める
	MOV.W	R0,@R1				;


;	====== 一旦停止信号OFF=====
	MEM1_BIT0_F_ADCLR MEM=(_SQ_CBWK_TOP+_WKSQCB206),LG=W,BIT=(~BIT9),WKRG1=R1,WKRG2=R4

	FAR_JSR	#_CMPCYC_START_CLR,R0		;
	FAR_JSR	#_CMPSTP_CNT_STOP_CLR,R0	;起動時のみ連続停止クリア（後はサイクル完了時も）
	FAR_JSR	#_POS_CMP_1STEP_START_INI,R0	;

	FAR_JSR	#_MOTION_CYCLE_START,R0		;

	FAR_JSR	#_POS_LSI_WORK_STOP2,R0

	XOR	R0,R0			;
	MOV.L	#_INT_CYC_DRV_STS,R1	;
	MOV.W	R0,@R1			;
	MOV.L	#_STOP_LATCH,R1		;//BIT0:ｽﾄｯﾌﾟ釦
	MOV.W	R0,@R1			;
	MOV.L	#_STOP_LATCH_B,R1	;//BIT0:ｽﾄｯﾌﾟ釦
	MOV.W	R0,@R1			;
	MOV.L	#_INT_CLS_CTL_FLG,R1	;//BIT0=1 START 起動時ｸﾘｱ
	MOV.W	R0,@R1			;
	MOV.L	#_LOT_CNT_TO_MOD,R1	;
	MOV.W	R0,@R1			;

;;	FAR_JSR	#_CPOS_INI1_DTMOV1,R0	;//運転ﾃﾞｰﾀﾗｯﾁ

	MOV.L	#_MODE_SEL,R1						;
	MOV.W	@R1,R0							;
	TST	#(_W1OPT+_W1CNT+_W1SGL+_W1INC),R0			;
	TST_BIT_OF MN_POSCTL_START_110					;
	M_BRA	MN_POSCTL_START_500					;寸動,安一,連続
MN_POSCTL_START_110:

;	=== 待機点作成(最寄)  :上死点復帰の場合は360ｴﾝｺｰﾀﾞから算出する	;
	TST	#(_W1DUP),R0						;
	TST_BIT_ON MN_POSCTL_START_200					;強制上昇

;	=== 段取モード========
	FAR_JSR	#_MN_DNDINC_START,R0		;2006-07-28 ｲﾆｼｬﾙｻﾌﾞﾙｰﾁﾝ化
	M_BRA	MN_POSCTL_START_800		;

;;	-- 2006-07-28 ｲﾆｼｬﾙｻﾌﾞﾙｰﾁﾝ化--
;;	MOV.L	#_SETX_POS_CTL_MATH,R1		;
;;	MOV.W	@R1,R0				;
;;	CMP/EQ	#_DMATH_REVRSE,R0		;DRIVE MATH 反転
;;	BF	MN_POSCTL_START_150		;
;;
;;	====== 反転/段取寸動===
;;	FAR_JSR	#_DND_LNK_STEP_CHECK1,R0	;//<どの工程から開始するか> CHEAK
;;	FAR_JSR	#_DND_LNKPLS_OBJMAK1,R1		;ｽﾃｯﾌﾟに応じて待機点1/目標位置/待機点2 _POS_DRV_DIRECT
;;	M_BRA	MN_POSCTL_START_180		;
;;
;;MN_POSCTL_START_150:
;;	====== 回転/段取寸動===
;;	+/-MAX位置を目標とする					;
;;	=== 方向判別/速度設定/目標位置:STARTは割込でかける	;
;;	FAR_JSR	#_DNDINC_DIRECT_MAKE1,R1			;ANS R0(=POS_RDV_DIRECT)
;;	MOV.L	#_POS_DRV_DIRECT,R1				;起動時(SV-LEVEL)
;;	MOV.W	@R1,R0
;;	FAR_JSR	#_LINK_P_M_MAX,R4				;Input R0:BIT0 DIRECT
;;MN_POSCTL_START_180:
;;	FAR_JSR	#_DNDINC_SPD_SET,R4				;
;;	M_BRA	MN_POSCTL_START_800				;


;	===================================
;	===	(原点復帰開始処理)	===
;	===================================
;2008-09-16(論理変更　ﾚﾍﾞﾙ動作も活かす)
MN_POSCTL_START_200:							;
	MOV.L	#_ORGIN_END_FLG1,R1		;//電源投入の１回ON:OFFはない
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;
	TST_BIT_OF MN_POSCTL_START_220		;１回も原点復帰していない

;	--------[2014-09-18]-----------
	MOV.L	#_ORG_ELSE_NOMAL_FLG1,R1
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;
	TST_BIT_OF MN_POSCTL_START_220		;1:ﾓｰｼｮﾝ運転可能=待機動作もｻｰﾁ無し可能

;	--------------------------------

	MOV.L	#_ORGIN_MOD2_SEL,R1		;//0:ｻｰﾁ動作 1:待機点動作
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_OF MN_POSCTL_START_220		;(論理変更)

	MOV.L	#_CB_SEQ_CB_SEL341,R1		;341
	MOV.W	@R1,R0				;
	MOV.W	#BIT15,R4			;
	TST	R4,R0				;
	TST_BIT_OF MN_POSCTL_START_220		;待機点目標位置決め指令(ｽﾗｲﾄﾞ調整後はｼｰｹﾝｽで判断)

	FAR_JSR	#_ORGIN_OBJ_POS_CTRL_ST1,R0	;(原点復帰ではなく待機点位置決め)
						;待機点範囲ならやらない(そうしないと...１回転するほうとしないほうがでる)
						;
	M_BRA	MN_POSCTL_START_800		;

;;;;----------- 2008-09-16 論理変更
;;;;2006-11-21
;;;;MN_POSCTL_START_200:							;
;;;;	MOV.L	#_CB_SEQ_CB_SEL341,R1		;341
;;;;	MOV.W	@R1,R0				;
;;;;	MOV.W	#BIT15,R4			;
;;;;	TST	R4,R0				;
;;;;	TST_BIT_OF MN_POSCTL_START_220		;待機点目標位置決め指令(ｽﾗｲﾄﾞ調整後はｼｰｹﾝｽで判断)
;;;;
;;;;	============ 2006-07-28=========
;;;;	MOV.L	#_ORGIN_MOD2_SEL,R1		;//0:ｻｰﾁ動作 1:待機点動作
;;;;	MOV.W	@R1,R0				;
;;;;	TST	R0,R0				;
;;;;	TST_BIT_OF MN_POSCTL_START_220		;(論理変更)
;;;;
;;;;	MOV.L	#_ORGIN_END_FLG1,R1		;//電源投入の１回ON:OFFはない
;;;;	MOV.W	@R1,R0				;
;;;;	TST	#BIT0,R0			;
;;;;	TST_BIT_OF MN_POSCTL_START_220		;１回も原点復帰していない
;;;;
;;;;	FAR_JSR	#_ORGIN_OBJ_POS_CTRL_ST1,R0	;(原点復帰ではなく待機点位置決め)
;;;;						;待機点範囲ならやらない(そうしないと...１回転するほうとしないほうがでる)
;;;;						;
;;;;	M_BRA	MN_POSCTL_START_800		;



;----------- 2006-11-21 論理変更
;;;MN_POSCTL_START_200:							;
;;;	============ 2006-07-28=========
;;;	MOV.L	#_ORGIN_MOD2_SEL,R1		;//0:ｻｰﾁ動作 1:待機点動作
;;;	MOV.W	@R1,R0				;
;;;	TST	R0,R0				;
;;;	TST_BIT_ON MN_POSCTL_START_210		;
;;;
;;;	============2004-05-24=========================
;;;	MOV.L	#_CB_SEQ_CB_SEL341,R1		;341
;;;	MOV.W	@R1,R0				;
;;;	MOV.W	#BIT15,R4			;
;;;	TST	R4,R0				;
;;;	TST_BIT_OF MN_POSCTL_START_220		;待機点目標位置決め指令(ｽﾗｲﾄﾞ調整後はｼｰｹﾝｽで判断)
;;;MN_POSCTL_START_210:							;
;;;	MOV.L	#_ORGIN_END_FLG1,R1		;//電源投入の１回ON:OFFはない
;;;	MOV.W	@R1,R0				;
;;;	TST	#BIT0,R0			;
;;;	TST_BIT_OF MN_POSCTL_START_220		;１回も原点復帰していない
;;;
;;;	FAR_JSR	#_ORGIN_OBJ_POS_CTRL_ST1,R0	;(原点復帰ではなく待機点位置決め)
;;;						;待機点範囲ならやらない(そうしないと...１回転するほうとしないほうがでる)
;;;						;
;;;	M_BRA	MN_POSCTL_START_800		;

;	----------------- ｻｰﾁﾀｲﾌﾟ-----------------------
MN_POSCTL_START_220:				
	MOV.L	#_ORIGN_OBJ_CTL_FLG,R1		;2004-05-24
	XOR	R0,R0				;
	MOV.W	R0,@R1				;

;	===============================================
;	==== 上死点復帰・待機点復帰====
;	今の位置から上死点＋３度を目指す
;	今の位置から上死点−３度を目指す
	FAR_JSR	#_LINK_UPPLS_A_OBJMAK1,R1	;
	FAR_JSR	#_DNDUPS_SPD_SET,R4		;
	FAR_JSR	#_ORG_END_SIG_CLR,R0		;
	M_BRA	MN_POSCTL_START_800		;

MN_POSCTL_START_500:				;
	FAR_JSR	#_CPOS_INI1_DTMOV2,R0		;

;;;	================= なぜこのフラグがＯＦＦしていない？ =======
;;	XOR	R0,R0				;(1ｻｲｸﾙ完了時にOFFしていないとならない信号なのに)
;;	MOV.L	#_INT_POS_CTL_FLAG,R1		;
;;	MOV.W	R0,@R1				;

;(急停止の場合はSV_POS_CTL_SEPは0ではない ok!)
;(ｻｲｸﾙ停止では、回転数を演算する必要はない)

;
;	=== 待機点作成(方向あり)====
	MOV.L	#_SV_POS_CTL_STEP,R1		;
	MOV.W	@R1,R0				;(+1だけでいいのか/つくり直す必要があるのか)

	TST	R0,R0				;
	TST_BIT_ON MN_POSCTL_START_600		;(ﾘｾｯﾄ時に待機点を決定する)
;;;;;;;;;;STEP=0:非常停止後の起動
;;;;;;;;;;2014-09-19	----------- [2009-10-07下振子]
;;;;;;;;;;2014-09-19	MOV.L	#_CPOS_CTL_MATH,R1		;
;;;;;;;;;;2014-09-19	MOV.W	@R1,R0				;
;;;;;;;;;;2014-09-19	TST	#_DMATH_DNDRIV,R0		; 往復?
;;;;;;;;;;2014-09-19	TST_BIT_OF MN_POSCTL_START_520		;
;;;;;;;;;;2014-09-19	MOV.L	#_DNM_DIR_SET_FLG,R1		;(この論理はよくない)
;;;;;;;;;;2014-09-19	MOV.W	@R1,R0				;
;;;;;;;;;;2014-09-19	TST	R0,R0				;
;;;;;;;;;;2014-09-19	TST_BIT_ON MN_POSCTL_START_540		;DNM_DIR_NOW_FLG
;;;;;;;;;;2014-09-19MN_POSCTL_START_520:				;
;;;;;;;;;;2014-09-19 目標位置から演算するから不要に思える.待機点を跨ぐなら別

;	------------ これがいまのところインターロックではたらいていなそう(20091007コメント)----------
	MOV.L	#_INT_CYC_DRV_STS,R1		;SV=0非常停止またはｻｲｸﾙ停止(BIT0=1:ｻｲｸﾙ停止)
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;
	TST_BIT_ON MN_POSCTL_START_540		;(これがうまくとれていない ｻｲｸﾙ停止時は演算しない)

;	---------- 非常停止後の起動-----------
	FAR_JSR	#_NEXT_CYCL_START2,R0			;(((((何の起動??)))))
	FAR_JSR	#_START_CNT_BANK2_MAK_CHK,R0		;(BANK1ROT番号+1)


;


	M_BRA	MN_POSCTL_START_600			;

;	-------遮光停止でこれをやった場合で　待機点を越えていたら以外にだめ？(コメント20091007)--------
;	遮光による停止、またはサイクルＥＮＤ後の自動起動

MN_POSCTL_START_540:					;
	MOV.L	#_LINK_OBJROT_NUM_ZR,R1			;//NOW ROTATION 番号
	MOV.L	@R1,R2					;+0
	FAR_JSR	#_NEXT_CYCL_START1,R0			;(連続時は転送でも良いがとりあえずこのまま残す)
	FAR_JSR	#_START_CNT_BANK2_MAK_CHK,R0		;(BANK1ROT番号+1)
MN_POSCTL_START_600:				;
	NOP					;何もしないくて良いはず
	NOP					;
	NOP					;
MN_POSCTL_START_800:				;


	MOV.W	#BIT0,R0			;起動
	MOV.L	#_MNWR_POS_CMD,R1		;
	MOV.W	R0,@R1				;


;	--------2009-04-01 起動したらフラグクリア[原点時の]
	MEM1_BIT0_F_ADCLR MEM=_ORIGN_180ARA_FLG,LG=W,BIT=(~BIT5),WKRG1=R4,WKRG2=R1	;原点起動で使用
	MEM1_BIT0_F_ADCLR MEM=_SQ_CBWK_TOP+_WKSQCB207,LG=W,BIT=(~BIT5),WKRG1=R4,WKRG2=R1


;	--------2011-05-11　起動時　本当は.160度手前.....----
	FAR_JSR	#_CNT_BEF_LOT_SIGCHK,R0		;ｻﾌﾞﾙｰﾁﾝ 2011-05-11


;	-2012-05-30 反転
	FAR_JSR	#_FULCLS_MAXOVER_CLR,R0

;	----------- 荷重行程変更ｸﾘｱ-----------------
	.AIF	_KJYU_CLS EQ	_CMPILE_YES	;YES:反転ﾓｰﾄﾞで荷重でのｸﾛｰｽﾞを行う
	FAR_JSR	#_FCLS_KJYU_STEPCHG_CLR,R0	;2015-03-15[R01:2014-03-20]
	FAR_JSR	#_KAJYU_ELSE_STS_CLR,R0		;
	.AENDI

;	-------- 2015-11-17 ---------
	FAR_JSR	#_API_ACCLW_DRV_START1,R0

	SUB_END
	M_RTS


;	***********************************
;	***	運転中に呼ばれる	***
;	***********************************
;	FAR_JSR	#_MN_POS_CTRL_ACT,R1		;<00:運転継続中>
;						;<寸動等の停止 -->準備未完了へ "FF">
;						;<ｻｲｸﾙ終了->ｾﾙﾌﾁｪｯｸへ          "55">
;
;	・１回転分のデータを作成するだけ
;	・位置決め完了を見るだけ
;
	.ALIGN	4				;
_MN_POS_CTRL_ACT:				;ssa_pos1.src
	SUB_START

	MOV.L	#_INT_CYC_DRV_STS,R1		;
	MOV.W	@R1,R0				;
	TST	#BIT6,R0			;工程終了
	TST_BIT_OF MN_POS_CTLACT_100		;(位置決め完了 NO!)
	M_BRA	MN_POS_CTLACT_800		;

MN_POS_CTLACT_100:				;


;;;	_BRK_SADOU_CHG EQ _CMPILE_YES
;	------------2015-09-06 ﾌﾞﾚｰｷ作動(H2W 2015-03-16,H1F 2015-07-14)-----------------
	MOV.L	#(_PAR_MYU_BRK_SEL-_CB_SYS_PARAM000+_W_PARAM_TOP),R1			;[H1F=未作or無][H2W=2015-03-16 0:　1:ﾐｭｰﾃﾝｸﾞ時=BRK:LOCK]
	MOV.W	@R1,R0					;
	CMP/EQ	#1,R0
	BF	MN_POS_CTLACT_130			;

;	-------------2015-09-06 (2015-07-14)-------------------------
;	ｲﾝﾎﾟｼﾞｼｮﾝから位置決め完了(ﾌﾞﾚｰｷまでの遅延)
	FAR_JSR	#_POS_ENDWAIT_TIM_SET,R0		;[安一,連続のAUTO それ以外でとるか]
	M_BRA	MN_POS_CTLACT_150					;

MN_POS_CTLACT_130:					;
;	--------------2015-09-06(2015-07-14)------------------------
	FAR_JSR	#_POS_ENDMYUT_TIM_SET,R0		;終了から動力遮断するorﾐｭｰﾃﾝｸﾞにする時間
;	-------------------------------------------------
MN_POS_CTLACT_150:					;






	MOV.L	#_CPOS_CTL_MATH,R1		;
	MOV.W	@R1,R0				;
	TST	#(_DMATH_CNTROT+_DMATH_DNDRIV),R0		;[20091007下振子]
	TST_BIT_OF DAI_CHK01_200		;
	FAR_JSR	#_DAI_FULL_SCALE_SMPLE,R0	;2003-02-03
DAI_CHK01_200:

	FAR_JSR	#_MOST_DISP_DAT_SMP,R0		;
	M_BRA	MN_POS_CTLACT_CONTINUE		;

MN_POS_CTLACT_800:
	XOR	R0,R0				;ｻｲｸﾙ停止
	MOV.L	#_MNWR_POS_CMD,R1		;ﾊﾟﾙｽ払出即停止
	MOV.W	R0,@R1				;

;;;	_BRK_SADOU_CHG EQ _CMPILE_YES
;	--------2015-09-06(2015-07-14)----------------
	MOV.L	#_POS_END_WAIT_TIM,R1		;
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_ON MN_POS_CTLACT_CONTINUE	;(位置決め完了を待つ---遮光時は動力遮断状態だから大丈夫)
;	-----------------------------------------


	MOV.L	#_INT_CYC_DRV_STS,R1	;//BIT0:CYCLE　END()
	MOV.W	@R1,R0
	TST	#BIT0,R0			;(わざとｻｲｸﾙ停止にしない)
	TST_BIT_ON MN_POS_CTLACT_CYCLE_END	;
	M_BRA	MN_POS_CTLACT_STOP_END		;


MN_POS_CTLACT_CONTINUE:
	XOR	R0,R0
	M_BRA	MN_POS_CTLACT_EXIT

MN_POS_CTLACT_STOP_END:
	MOV	#-1,R0
	M_BRA	MN_POS_CTLACT_EXIT
MN_POS_CTLACT_CYCLE_END:
	MOV	#H'55,R0	;CYCLE END
MN_POS_CTLACT_EXIT:
	SUB_END
	M_RTS




;	***********************************
;	***				***
;	***	2015-09-06		***
;	***	2015-07-14		***
;	***				***
;	***********************************
;	ﾌﾞﾚｰｷとﾐｭ-ﾃﾝｸﾞ連動
;;;	_BRK_SADOU_CHG EQ _CMPILE_YES
_POS_ENDWAIT_TIM_SET
	SUB_START


;	--------------------------------------------
	MOV.L	#(_PAR_MYUBRK_TIM2-_CB_SYS_PARAM000+_W_PARAM_TOP),R1	;[PNO.95][H2W=2015-03-16 寸動終了時ﾀｲﾏ]
	MOV.W	@R1,R2				;

	MOV.L	#_MODE_SEL,R1			;
	MOV.W	@R1,R0				;
	TST	#(_W1OPT+_W1CNT+_W1SGL),R0	;
	TST_BIT_OF POS_ENDWAIT_TIMSET_END	;

	MOV.L	#_dq1_cb_out1,R1		;//+0:制御出力(203)
	MOV.W	@R1,R0				;
	MOV.W	#_WOATO,R4			;AUTO
	TST	R4,R0				;
	TST_BIT_OF POS_ENDWAIT_TIMSET_END	;[AUTOじゃない]

;	----------- 1ｻｲｸﾙ停止時用 2015-07-14--------
	MOV.L	#(_PAR_MYUBRK_TIM1-_CB_SYS_PARAM000+_W_PARAM_TOP),R1	;[H2W=2015-03-14 行程終了時　ﾐｭｰﾃﾝｸﾞ切替時間]
	MOV.W	@R1,R2				;[PNO.94]
						;

POS_ENDWAIT_TIMSET_END
	MOV.L	#_POS_END_WAIT_TIM,R1		;[位置決め完了遅延時間==動力遮断を伸ばす時間]
	MOV.W	R2,@R1



	SUB_END
	M_RTS



;	***********************************
;	***				***
;	***	2015-07-14		***
;	***				***
;	***********************************
;	ﾌﾞﾚｰｷとﾐｭ-ﾃﾝｸﾞ連動しない
;	P22　ﾊﾟﾙｽ出力完了~ﾌﾞﾚｰｷをかけても良い時間
;	ﾐｭｰﾃﾝｸﾞ中はﾐｭｰﾃﾝｸﾞ継続時間
;	ﾐｭｰﾃﾝｸﾞしない状態では動力遮断時間
;
;	今までは遮光を検知しない時間=ﾐｭｰﾃﾝｸﾞ継続時間相当
;

_POS_ENDMYUT_TIM_SET:
	SUB_START

	MOV.L	#(_PAR_SELF_WAIT_TM-_CB_SYS_PARAM000+_W_PARAM_TOP),R1	;P22ｾﾙﾌﾁｪｯｸまたは位置決めからﾛｯｸ開始遅延時間(停止確認用)
	MOV.W	@R1,R2			;
	XOR	R3,R3


	MOV.L	#_MODE_SEL,R1		;寸動・安全一工程・連続・OPT
	MOV.W	@R1,R0			;
	TST	#_W1SGL,R0		;
	TST_BIT_OF POS_ENDMYUTTIM_STOP	;[見る必要ないのだが]

	MOV.L	#_UP_HOLD_FLG,R1	;上昇ﾎｰﾙﾄﾞ状態(自動可能状態):ﾓｰｼｮﾝﾓｰﾄﾞでこの信号はON/OFFする
	MOV.W	@R1,R0			;
	TST	#BIT1,R0		;
	TST_BIT_OF POS_ENDMYUTTIM_STOP	;[見る必要ないのだが]

	MOV.L	#_FR_CYL_MASK_FLG,R1	;//上昇無効中"1"
	MOV.W	@R1,R0			;
	TST	#(BIT1+BIT0),R0		;
	TST_BIT_OF POS_ENDMYUTTIM_STOP	;


;	---	ﾐｭｰﾃﾝｸﾞする	---
POS_ENDMYUTTIM_KEEP:
	MOV	R2,R0			;
	MOV	R3,R2			;
	MOV	R0,R3			;

;	---	ﾐｭｰﾃﾝｸﾞじゃない	---
POS_ENDMYUTTIM_STOP
	MOV.L	#_POS_END_MYUTIG_STOPTIM,R1	;//終了後この時間であれば動力遮断する時間
	MOV.W	R2,@R1				;
	MOV.L	#_POS_END_MYUTIG_KEEPTIM,R1	;//終了後上昇無効を継続する時間
	MOV.W	R3,@R1				;



	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	2015-07-14		***
;	***				***
;	***	一応ｸﾘｱしておく		***
;	***********************************
_POS_END_MYUTIG_TIMER_CLR
	SUB_START
	XOR	R0,R0
	MOV.L	#_POS_END_MYUTIG_STOPTIM,R1;	//終了後この時間であれば動力遮断する時間
	MOV.W	R0,@R1
	
	MOV.L	#_POS_END_MYUTIG_KEEPTIM,R1;	//終了後上昇無効を継続する時間
	MOV.W	R0,@R1

	MOV.L	#_POS_END_WAIT_TIM,R1;		//[位置決め完了遅延時間==動力遮断を伸ばす時間]
	MOV.W	R0,@R1
	SUB_END
	M_RTS


;;;LENGTH_ADD[2]=LINK_SV_OBJ_ABSPLS[2]-LINK_RL_OBJ_ABSPLS[2];//abs停止目標位置-ﾘｱﾙﾀｲﾑ目標絶対位置
;	***********************************
;	***				***
;	***	ﾓｰﾄﾞに関わるｻﾌﾞﾙｰﾁﾝ	***
;	***				***
;	***********************************



;;;;;;@@@@@@@@@@

;	***********************************
;	***				***
;	***	上死点復帰		***
;	***	速度設定		***
;	***				***
;	***********************************
	.ALIGN	4				;
_DNDUPS_SPD_SET:
	SUB_START
	MOV.L	#_SET1_UPAREA_SPD1,R1	;
	MOV.L	@R1,R2			;
	MOV.L	#_LINK_SV_OBJ_SPDPLS,R1	;//目標速度
	MOV.L	R2,@R1			;
	SUB_END
	M_RTS

	.ALIGN	4				;
_DNDUPS_CLEEP_SPD_SET:
	SUB_START
	MOV.L	#_SET1_UPCLEEP_SPD,R1	;
	MOV.L	@R1,R2			;
	MOV.L	#_LINK_SV_OBJ_SPDPLS,R1	;//目標速度
	MOV.L	R2,@R1			;
	SUB_END
	M_RTS



;	***********************************
;	***				***
;	***	2006-07-28		***
;	***				***
;	***********************************
	.ALIGN	4				;
_MN_DNDINC_START:
	SUB_START
	MOV.L	#_TEP_MODE_DRV,R1		;//起動時に判定
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_OF DNDINC_ST_100		;

	FAR_JSR	#_MN_TEP_START,R0
	M_BRA	DNDINC_ST_END				;

DNDINC_ST_100:
	MOV.L	#_CPOS_DND_STOP_SW,R1		;
	MOV.W	@R1,R0				;
	TST	#(BIT1+BIT0),R0			;停止有り?
	TST_BIT_OF DNDINC_ST_520		;

	MOV.L	#_SETX_POS_CTL_MATH,R1			;
	MOV.W	@R1,R0					;
	CMP/EQ	#_DMATH_REVRSE,R0			;DRIVE MATH 反転
	BF	DNDINC_ST_350				;

;	====== 反転/段取寸動===
	FAR_JSR	#_DND_LNK_STEP_CHECK1,R0		;//<どの工程から開始するか> CHEAK
	FAR_JSR	#_DND_LNKPLS_OBJMAK1,R1			;ｽﾃｯﾌﾟに応じて待機点1/目標位置/待機点2 _POS_DRV_DIRECT
	M_BRA	DNDINC_ST_380				;

DNDINC_ST_350:
;	====== 回転/段取寸動===
;	+/-MAX位置を目標とする					;
;	=== 方向判別/速度設定/目標位置:STARTは割込でかける	;
	FAR_JSR	#_DNDINC_DIRECT_MAKE1,R1			;ANS R0(=POS_RDV_DIRECT)
	FAR_JSR	#_DNDINC_STEP_MAKE,R1				;
	FAR_JSR	#_DNDINC_MAKE_OBJPOS,R1				;

DNDINC_ST_380:
	FAR_JSR	#_DNDINC_SPD_SET,R4				;
	M_BRA	DNDINC_ST_END					;


;	-------- 今までのソフトをそのまま流す-------------
DNDINC_ST_520:
	MOV.L	#_SETX_POS_CTL_MATH,R1		;
	MOV.W	@R1,R0				;
	CMP/EQ	#_DMATH_REVRSE,R0		;DRIVE MATH 反転
	BF	DNDINC_ST_550		;

;	====== 反転/段取寸動===
	FAR_JSR	#_DND_LNK_STEP_CHECK1,R0	;//<どの工程から開始するか> CHEAK
	FAR_JSR	#_DND_LNKPLS_OBJMAK1,R1		;ｽﾃｯﾌﾟに応じて待機点1/目標位置/待機点2 _POS_DRV_DIRECT
	M_BRA	DNDINC_ST_580		;

DNDINC_ST_550:
;	====== 回転/段取寸動===
;	+/-MAX位置を目標とする					;
;	=== 方向判別/速度設定/目標位置:STARTは割込でかける	;
	FAR_JSR	#_DNDINC_DIRECT_MAKE1,R1			;ANS R0(=POS_RDV_DIRECT)
	MOV.L	#_POS_DRV_DIRECT,R1				;起動時(SV-LEVEL)
	MOV.W	@R1,R0
	FAR_JSR	#_LINK_P_M_MAX,R4				;Input R0:BIT0 DIRECT
DNDINC_ST_580:
	FAR_JSR	#_DNDINC_SPD_SET,R4				;
DNDINC_ST_END:
	SUB_END
	M_RTS



;	***********************************
;	***				***
;	***	段取寸動(回転仕様)	***
;	***	方向			***
;	***	目標位置abs		***
;	***				***
;	***********************************
;	ANS R0		BIT0
;			BIT1=1:EQU ｲｺｰﾙ時は逆転から始める
;	ｼｰｹﾝｽﾋﾞｯﾄから決定
;	(増加方向ならMAX)
;	(減少方向ならMIN)
;
	.ALIGN	4				;
_DNDINC_DIRECT_MAKE1:
	SUB_START
	MOV.L	#_CTL_ENC360,R0			;//360.0度(いまのところ不要)
	MOV.W	@R0,R1				;
	MOV.L	#_STR_ENC3600_DIG,R4		;//運転開始時の360.0角度
	MOV.W	R1,@R4				;

	MOV.L	#_CB_SEQ_CB_SEL341,R1		;341
	MOV.W	@R1,R0				;
	AND	#BIT0,R0			;(BIT0=0正転　BIT0=1逆転)

	MOV.L	#_POS_DRV_DIRECT,R1		;起動時(SV-LEVEL)
	MOV.W	R0,@R1
	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	段取寸動(反転仕様)	***
;	***	方向			***
;	***	目標位置abs		***
;	***				***
;	***********************************
;	<1>EXQ,EMG後の運転なら180を通らない方向待機点に向かう方向で,
;	   待機点を目指して運転開始
;	   待機点まで辿りついたら、一旦停止する。<FLG=0-->1>
;
;	<2>FLG=1
;	   下降から開始する.下限位置を目指す
;	   下限位置まで辿りついたら、一旦停止する。<FLG=1-->2>
;
;	<3>FLG=2
;	   上昇から開始する.待機位置を目指す
;	   待機位置まで辿りついたら、一旦停止する。<FLG=2-->1>
;
;
;
;	*******************************************
;	***					***
;	***	運転釦による起動		***
;	***	INT_DND_NEG_STEPを作成		***
;	***					***
;	*******************************************
	.ALIGN	4				;
_DND_LNK_STEP_CHECK1:
	SUB_START
;	------- 2007-01-23-----
	MOV.L	#_CB_SEQ_CB_SEL342,R1				;342
	MOV.W	@R1,R0						;
	TST	#BIT3,R0					;342.3
	TST_BIT_OF DND_LNK_STEP_CK1_100				;OFF(往復運転　今までの)

	MOV	#1,R2						;
	MOV.L	#_CB_SEQ_CB_SEL341,R1				;341.0=0 上昇
	MOV.W	@R1,R0						;
	TST	#BIT0,R0					;
	TST_BIT_OF DND_LNK_STEP_CK1_050				;
	MOV	#2,R2						;
DND_LNK_STEP_CK1_050:						;
	MOV.L	#_INT_DND_NEG_STEP,R1				;
	MOV.W	R2,@R1						;

DND_LNK_STEP_CK1_100:
;	---------------------------

	SUB_END
	M_RTS

	.ALIGN	4				;
_DND_LNKPLS_OBJMAK1:
	SUB_START
	MOV.L	#_INT_DND_NEG_STEP,R1		;
	MOV.W	@R1,R0				;
	CMP/EQ	#1,R0				;
	BT	DND_LNKPLS_OBJ_DNPOS1		;下死点を目標に動作
	CMP/EQ	#2,R0				;
	BT	DND_LNKPLS_OBJ_UPPOS1		;待機点を目標に動作

;	=== 方向を判別して待機点を目指す ===
DND_LNKPLS_OBJ_UPPOS1:
DND_LNKPLS_OBJ_UPPOS0:
;;;ｵﾘｷﾞﾅﾙｿﾌﾄ	MOV.L	#_SETX_UPAREA_PLS,R0			;//4;待機点
	MOV.L	#_SET1_UPAREA_PLS1,R0			;//4;上死点固定(上死点)
	MOV.L	@R0,R2					;
;	==== 2004-05-23====
	MOV.L	#_PAR_WTSEL_USE,R0			
	MOV.W	@R0,R0					;
	CMP/EQ	#1,R0					;待機点選択使用時は上死点ではない
	BF	DND_LNKPLS_OBJ_CHG050			;
	MOV.L	#_SETX_UPAREA_PLS,R0			;//4;上死点固定(上死点)
	MOV.L	@R0,R2					;
DND_LNKPLS_OBJ_CHG050:
;	===================

	FAR_JSR	#_LNKPLS_OBJ_DAT_MAK1,R0		;
	M_BRA	DND_LNKPLS_OBJMK1_END			;

DND_LNKPLS_OBJ_DNPOS1:
	MOV.L	#_SETX_DNAREA_JG_PLS,R0			;
	MOV.L	@R0,R2					;
	FAR_JSR	#_LNKPLS_OBJ_DAT_MAK1,R0		;
DND_LNKPLS_OBJMK1_END:
	SUB_END
	M_RTS

;	*******************************************
;	***					***
;	***		Input R2		***
;	***		ﾘﾝｸ(内部制御)ﾊﾟﾙｽ	***
;	***					***
;	*******************************************
;	MOV.L	#_SETX_DNAREA_JG_PLS,R4			;反転設定不可範囲LINK-PLS
;	MOV.L	@R4,R2					;
;
	.ALIGN	4				;
_LNKPLS_OBJ_DAT_MAK1:
	SUB_START
	FAR_JSR	#_X_SET_PV_ABS_TO_OBJ,R0		;

	PUSH_REG1 R2


	FAR_JSR	#_NOW_INC_DIG_MAK,R0			;

	POP_REG1 R2
;	=== 目標角度(R2) ====

;;	MOV.L	#_SETX_UPAREA_PLS,R0			;//4;待機点
;;	MOV.L	@R0,R2					;

	MOV.L	#_LINK_NOWROT_OFSPLS_P,R4		;
	MOV.L	@R4,R1					;現在 ***.* pls
							;目標 ***.* pls
	MOV.L	#_SETX_UPDN_CHK_DN_PLS,R4		;180.0pls(下死点角度 180.0)
	MOV.L	@R4,R3					;
;
;	===== R3~R2の範囲にR1がいれば正転===
	DIG_AREA_CHK STREG=R3,EDREG=R2,PVREG=R1,ANSREG=R0	;
	XOR	R3,R3
	TST	R0,R0
	TST_BIT_ON LNKPLS_OBJ_DAT_MK1_150		;
	MOV	#-1,R3
LNKPLS_OBJ_DAT_MK1_150:					;R2

	TST	R3,R3					;正転
	TST_BIT_ON LNKPLS_OBJ_DAT_MK1_300		;逆転 JUMP
;	==== 正転方向でいく ====
	SUB	R1,R2					;
	CMP/PZ	R2
	BT	LNKPLS_OBJ_DAT_MK1_500			;R2 >= 0(R2は符号付距離)
	MOV.L	#_LINK_1ROT_PLS,R5			;
	MOV.L	@R5,R4					;
	ADD	R4,R2					;
	CMP/PZ	R2 
	BT	LNKPLS_OBJ_DAT_MK1_500		;
	XOR	R2,R2					;
	M_BRA	LNKPLS_OBJ_DAT_MK1_500			;

LNKPLS_OBJ_DAT_MK1_300:				;R2
	SUB	R1,R2					;300-270
	NEG	R2,R2					;
	CMP/PZ	R2
	BT	LNKPLS_OBJ_DAT_MK1_400			;R2 >= 0(R2は符号付距離)
	MOV.L	#_LINK_1ROT_PLS,R5			;
	MOV.L	@R5,R4					;
	ADD	R4,R2					;
	CMP/PZ	R2 
	BT	LNKPLS_OBJ_DAT_MK1_400			;
	XOR	R2,R2					;
LNKPLS_OBJ_DAT_MK1_400:				;
	NEG	R2,R2					;
LNKPLS_OBJ_DAT_MK1_500:				;
	XOR	R5,R5					;
	MOV	R2,R6					;
	CMP/PZ	R2					;
	BT	LNKPLS_OBJ_DAT_MK1_600			;
	MOV	#-1,R5					;
LNKPLS_OBJ_DAT_MK1_600:					;

	MOV.L	#_LINK_RL_OBJ_ABSPLS,R4			;//ﾘｱﾙﾀｲﾑ目標絶対位置(ﾊﾞｯｸﾗｯｼなし)	;
	MOV.L	@R4+,R1					;
	MOV.L	@R4,R2					;
	PUSH_REG1 R1
	PUSH_REG1 R2
	ADD8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;

	MOV.L	#_LINK_SV_OBJ_ABSPLS,R4				;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	R1,@R4						;
	MOV.L	R2,@(1*4,R4)					;目標位置ｾｯﾄ
	POP_REG1 R6
	POP_REG1 R5
	
	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2
	XOR	R3,R3
	CMP/PZ	R1				;
	BT	LNKPLS_OBJ_DAT_MK1_750		;
	MOV	#BIT0,R3			;
LNKPLS_OBJ_DAT_MK1_750:				;
	MOV.L	#_POS_DRV_DIRECT,R1		;起動時(SV-LEVEL)
	MOV.W	R3,@R1				;

	MOV.L	#_POSLSI_DRIV_SHIN,R1	;//BIT0
	MOV.W	@R1,R0			;
	AND	#LOW ~BIT0,R0		;
	OR	R3,R0			;
	MOV.W	R0,@R1			;

	SUB_END
	M_RTS
















;	***********************************
;	***				***
;	***	段取寸動		***
;	***	速度設定		***
;	***				***
;	***********************************
	.ALIGN	4				;
_DNDINC_SPD_SET:
	SUB_START

;	--------2011-09-20-
	PUSH_REG1 R0	;2011-09-20


	MOV.L	#_SET1_DNDINC_SPD1,R1	;
	MOV.L	@R1,R2			;

;	---------------------------
	MOV.L	#_CB_SEQ_CB_COM349,R1		;
	MOV.W	@R1,R0				;
	TST	#BIT6,R0			;
	TST_BIT_OF DNDINC_SPDSET_100		;

	MOV.L	#_WPARX_BRKTST_DNDLMT,R1	;
	MOV.L	@R1,R0				;

	CMP/HS	R0,R2				;R0<R2
	BF	DNDINC_SPDSET_100		;NO JUMP(R2=<R0)
	MOV	R0,R2				;
DNDINC_SPDSET_100:
;	---------------------------

	MOV.L	#_LINK_SV_OBJ_SPDPLS,R1	;//目標速度
	MOV.L	R2,@R1			;

	POP_REG1 R0	;2011-09-20

	SUB_END
	M_RTS

;	*******************************************
;	***					***
;	***	今の回転上の上死点+3．0を目指す	***
;	***	本当は最寄の上死点の+3を目指す	***
;	*******************************************
;	今の回転の上死点が現在位置から見て、+180度以上相当のパルスなら -1回転
;					    -180度以下相当のパルスなら +1回転
	.IMPORT	_POSCHG_LINK_ABSPLS_ROTNUMBER				;R1,R2(R1=0/FFFFのみ)
	.IMPORT	_POSCHG_LINK_ROTNUM_PLS					;




;	*******************************************
;	***					***
;	***	今の回転上の上死点-3．0を目指す	***
;	***	本当は最寄の上死点の+3を目指す	***
;	*******************************************
;	今の回転の上死点が現在位置から見て、+180度以上相当のパルスなら -1回転
;					    -180度以下相当のパルスなら +1回転
;;	.IMPORT	_POSCHG_LINK_ABSPLS_ROTNUMBER				;R1,R2(R1=0/FFFFのみ)
;;	.IMPORT	_POSCHG_LINK_ROTNUM_PLS					;
	.ALIGN	4				;
_LINK_UPPLS_A_OBJMAK1:
	SUB_START


	FAR_JSR	#_NOW_INC_DIG_MAK,R0			;

;	=== 目標角度 ====
	MOV.L	#_SET1_UPAREA_PLS1,R0			;//4;上死点固定(1回目は上死点)
	MOV.L	@R0,R2					;これは反転でも回転で待機点選択有りでも同じ
	MOV.L	#_ORG_FIRST_OBJPLS,R0			;[-ﾏｲﾅｽﾃﾞｰﾀ]
	MOV.L	@R0,R1					;
	ADD	R1,R2					;
	MOV.L	#_LINK_1ROT_PLS,R5			;
	MOV.L	@R5,R4					;

;;;2011-03-22[0度不具合]	CMP/HI	R2,R4					;R2 < R4
	CMP/GE	R2,R4					;R2 < R4
	BT	LINK_UPPLS_A_OBJMK1_100			;
	SUB	R4,R2					;
LINK_UPPLS_A_OBJMK1_100:				;R2

;	------ 2011-03-22--------
	CMP/PZ	R2
	BT	LINK_UPPLS_A_OBJMK1_110			;
	ADD	R4,R2					;
LINK_UPPLS_A_OBJMK1_110:				;





	MOV.L	#_LINK_NOWROT_OFSPLS_P,R4		;
	MOV.L	@R4,R1					;現在 ***.* pls
							;目標 ***.* pls
	MOV.L	#_SETX_UPDN_CHK_DN_PLS,R4		;180.0pls(下死点角度 180.0)
	MOV.L	@R4,R3					;

;	===========2008-04-28 =======
;;;	MOV.L	#_SQ_CBWK_TOP+_WKSQCB207,R0		;

	MOV.L	#_ORIGN_180ARA_FLG,R0	;
	MOV.W	@R0,R0					;
	TST	#BIT5,R0				;
	TST_BIT_ON LINK_UPPLS_A_OBJMK1_145		;逆転固定
;	================================


;	===== R3~R2の範囲にR1がいれば正転===
	DIG_AREA_CHK STREG=R3,EDREG=R2,PVREG=R1,ANSREG=R0	;
	XOR	R3,R3
	TST	R0,R0
	TST_BIT_ON LINK_UPPLS_A_OBJMK1_150		;
LINK_UPPLS_A_OBJMK1_145:				;R2
	MOV	#-1,R3
LINK_UPPLS_A_OBJMK1_150:				;R2

	TST	R3,R3					;正転
	TST_BIT_ON LINK_UPPLS_A_OBJMK1_300		;逆転 JUMP
;	==== 正転方向でいく ====
	SUB	R1,R2					;
	CMP/PZ	R2
	BT	LINK_UPPLS_A_OBJMK1_500			;R2 >= 0(R2は符号付距離)
	MOV.L	#_LINK_1ROT_PLS,R5			;
	MOV.L	@R5,R4					;
	ADD	R4,R2					;
	CMP/PZ	R2 
	BT	LINK_UPPLS_A_OBJMK1_500		;
	XOR	R2,R2					;
	M_BRA	LINK_UPPLS_A_OBJMK1_500			;

LINK_UPPLS_A_OBJMK1_300:				;R2
	SUB	R1,R2					;300-270
	NEG	R2,R2					;
	CMP/PZ	R2
	BT	LINK_UPPLS_A_OBJMK1_400			;R2 >= 0(R2は符号付距離)
	MOV.L	#_LINK_1ROT_PLS,R5			;
	MOV.L	@R5,R4					;
	ADD	R4,R2					;
	CMP/PZ	R2 
	BT	LINK_UPPLS_A_OBJMK1_400		;
	XOR	R2,R2					;
LINK_UPPLS_A_OBJMK1_400:				;
	NEG	R2,R2					;
LINK_UPPLS_A_OBJMK1_500:				;
	XOR	R5,R5
	MOV	R2,R6					;
	CMP/PZ	R2					;
	BT	LINK_UPPLS_A_OBJMK1_600			;
	MOV	#-1,R5					;
LINK_UPPLS_A_OBJMK1_600:				;


	MOV.L	#_LINK_RL_OBJ_ABSPLS,R4					;//ﾘｱﾙﾀｲﾑ目標絶対位置(ﾊﾞｯｸﾗｯｼなし)	;
	MOV.L	@R4+,R1							;
	MOV.L	@R4,R2							;
	PUSH_REG1 R1
	PUSH_REG1 R2
	ADD8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;

	MOV.L	#_LINK_SV_OBJ_ABSPLS,R4				;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	R1,@R4						;
	MOV.L	R2,@(1*4,R4)					;目標位置ｾｯﾄ
	POP_REG1 R6
	POP_REG1 R5
	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2
	XOR	R3,R3
	CMP/PZ	R1				;+
	BT	LINK_UPPLS_A_OBJMK1_700		;
	MOV	#BIT0,R3
LINK_UPPLS_A_OBJMK1_700:				;
	MOV.L	#_POS_DRV_DIRECT,R1		;起動時(SV-LEVEL)
	MOV.W	R3,@R1				;

	MOV.L	#_POSLSI_DRIV_SHIN,R1	;//BIT0
	MOV.W	@R1,R0			;
	AND	#LOW ~BIT0,R0		;
	OR	R3,R0			;
	MOV.W	R0,@R1			;

	SUB_END
	M_RTS


;	***************************************************
;	***						***
;	***	１回目の目標位置+6.0を目指す		***
;	***						***
;	***************************************************
	.ALIGN	4				;
_LINK_UPPLS_A_OBJMAK2:
	SUB_START
	FAR_JSR	#_X_SET_PV_ABS_TO_OBJ,R0			;20060919

	MOV.L	#_LINK_SV_OBJ_ABSPLS,R4				;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	@R4,R1						;
	MOV.L	@(1*4,R4),R2					;目標位置ｾｯﾄ
	MOV.L	#_ORG_SECOND_OBJPLS,R4				;
	MOV.L	@R4,R6						;
	XOR	R5,R5						;
	CMP/PZ	R6
	BT	LINK_UPPLS_A_OBJMK2_030				;あり得ない
	ADD	#-1,R5						;
LINK_UPPLS_A_OBJMK2_030:						;
	FAR_JSR	#_ADDR56_R12_ANS_R12_LIMIT_MAX_MIN,R0		;

	MOV.L	#_LINK_SV_OBJ_ABSPLS,R4				;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	R1,@R4						;
	MOV.L	R2,@(1*4,R4)					;目標位置ｾｯﾄ

	MOV.L	#_LINK_RL_OBJ_ABSPLS,R4;//ﾘｱﾙﾀｲﾑ目標絶対位置(ﾊﾞｯｸﾗｯｼなし)	;
	MOV.L	@R4+,R5								;
	MOV.L	@R4,R6								;
	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2
	XOR	R3,R3
	CMP/PZ	R1				;
	BT	LINK_UPPLS_A_OBJMK2_050		;
	MOV	#BIT0,R3			;
LINK_UPPLS_A_OBJMK2_050:				;
	MOV.L	#_POS_DRV_DIRECT,R1		;起動時(SV-LEVEL)
	MOV.W	R3,@R1				;

	MOV.L	#_POSLSI_DRIV_SHIN,R1	;//BIT0
	MOV.W	@R1,R0			;
	AND	#LOW ~BIT0,R0		;
	OR	R3,R0			;
	MOV.W	R0,@R1			;

	SUB_END
	M_RTS

;	***************************************************
;	***						***
;	***	今の回転上の待機点を目指す		***
;	***	本当は正転する待機点を目指す		***
;	***************************************************
;	ｱﾙｺﾞﾘｽﾞﾑ:今の回転の待機点が負方向なら、１回転した待機点に変更し、
;
	.ALIGN	4				;
_LINK_UPPLS_A_OBJMAK3:
	SUB_START


	FAR_JSR	#_X_SET_PV_ABS_TO_OBJ,R0		;20060919


	FAR_JSR	#_NOW_INC_DIG_MAK,R0			;

;	----------- 2014-09-18 -----------------
	FAR_JSR	#_LINK_UPPLS_OBJ_SELECT1,R0		;


;;2014-09-18　SELECT1へ移動;	-------2012-10-19 別目的　ふりこ退避
;;2014-09-18　SELECT1へ移動	MOV.L	#_CB_SEQ_CB_COM349,R1		;
;;2014-09-18　SELECT1へ移動	MOV.W	@R1,R0				;
;;2014-09-18　SELECT1へ移動	TST	#BIT5,R0			;
;;2014-09-18　SELECT1へ移動	TST_BIT_OF LINK_UPPLS_A_OBJMK3_050	;R2
;;2014-09-18　SELECT1へ移動
;;2014-09-18　SELECT1へ移動	MOV.L	#_WPARX_ELSE_ORGPLS,R0			;//4;好きなとこ
;;2014-09-18　SELECT1へ移動	MOV.L	@R0,R2					;
;;2014-09-18　SELECT1へ移動	M_BRA	LINK_UPPLS_A_OBJMK3_110B		;R2
;;2014-09-18　SELECT1へ移動
;;2014-09-18　SELECT1へ移動LINK_UPPLS_A_OBJMK3_050:
;;2014-09-18　SELECT1へ移動;	-----------------------------
;;2014-09-18　SELECT1へ移動
;;2014-09-18　SELECT1へ移動	MOV.L	#_BRKTST_SW_IN,R1		;制動試験
;;2014-09-18　SELECT1へ移動	MOV.W	@R1,R0				;
;;2014-09-18　SELECT1へ移動	TST	#BIT0,R0			;
;;2014-09-18　SELECT1へ移動	TST_BIT_OF LINK_UPPLS_A_OBJMK3_100A	;R2
;;2014-09-18　SELECT1へ移動
;;2014-09-18　SELECT1へ移動	MOV.L	#_WPARX_BRKTST_ORGPLS,R0		;//4;待機点X
;;2014-09-18　SELECT1へ移動	MOV.L	@R0,R2					;
;;2014-09-18　SELECT1へ移動	M_BRA	LINK_UPPLS_A_OBJMK3_110B		;R2
;;2014-09-18　SELECT1へ移動
;;2014-09-18　SELECT1へ移動
;;2014-09-18　SELECT1へ移動;	=== 目標角度 ====
;;2014-09-18　SELECT1へ移動LINK_UPPLS_A_OBJMK3_100A:				;R2
;;2014-09-18　SELECT1へ移動	MOV.L	#_SETX_UPAREA_PLS,R0			;//4;待機点
;;2014-09-18　SELECT1へ移動	MOV.L	@R0,R2					;
;;2014-09-18　SELECT1へ移動LINK_UPPLS_A_OBJMK3_110B:				;R2
;;;2011-05-11	MOV.L	#_SETX_UPAREA_PLS,R0			;//4;待機点
;;;2011-05-11	MOV.L	@R0,R2					;


;	===========2008-04-28 =======
	MOV.L	#_ORIGN_180ARA_FLG,R0			;
	MOV.W	@R0,R0					;
	AND	#BIT5,R0				;

	FAR_JSR	#_UPPLS1_OBJMAK_COMMON,R4		;input R2(目標),R0=0(自動判別) R0!=0(BIT5=1)逆転固定

	SUB_END
	M_RTS



;	*******************************************
;	***					***
;	***	待機点位置決めの目標位置選択	***
;	***					***
;	*******************************************
;	2014-09-18 ｻﾌﾞﾙｰﾁﾝ化しただけ
;
;	ANS R0=0:強制書き換え無し R2=待機点
;	ANS R0=1:強制書き換え有り R2=変更目標
;
;
_LINK_UPPLS_OBJ_SELECT1
	SUB_START

;	-------2012-10-19 別目的　ふりこ退避
	MOV.L	#_CB_SEQ_CB_COM349,R1		;
	MOV.W	@R1,R0				;
	TST	#BIT5,R0			;
	TST_BIT_OF LINK_UPPLS_OBJ_SEL_050	;R2

	MOV.L	#_WPARX_ELSE_ORGPLS,R0			;//4;好きなとこ
	MOV.L	@R0,R2					;
	M_BRA	LINK_UPPLS_OBJ_SEL_110B		;R2

LINK_UPPLS_OBJ_SEL_050:
;	-----------------------------

	MOV.L	#_BRKTST_SW_IN,R1		;制動試験
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;
	TST_BIT_OF LINK_UPPLS_OBJ_SEL_100A	;R2

	MOV.L	#_WPARX_BRKTST_ORGPLS,R0		;//4;待機点X
	MOV.L	@R0,R2					;
	M_BRA	LINK_UPPLS_OBJ_SEL_110B		;R2


;	=== 目標角度(通常の待機点) ====
LINK_UPPLS_OBJ_SEL_100A:				;R2
	MOV.L	#_SETX_UPAREA_PLS,R0			;//4;待機点
	MOV.L	@R0,R2					;
	XOR	R0,R0					;強制書換無し
	M_BRA	LINK_UPPLS_OBJ_SEL_END			;

LINK_UPPLS_OBJ_SEL_110B:				;
	MOV.B	#-1,R0					;強制書換有り

LINK_UPPLS_OBJ_SEL_END:				;R2

	SUB_END
	M_RTS




;	***************************************************
;	***						***
;	***	待機位置決めの方向判別＋目標＋方向	***
;	***	R2:目標位置ｵﾌｾｯﾄﾊﾟﾙｽ相当の角度		***
;	***	R0=0自動判別　R0=BIT5逆転固定		***
;	***						***
;	***************************************************
;
;input R2(目標),R0=0(自動判別) R0!=0(BIT5=1)逆転固定


_UPPLS1_OBJMAK_COMMON:
	SUB_START

	MOV.L	#_LINK_NOWROT_OFSPLS_P,R4		;
	MOV.L	@R4,R1					;現在 ***.* pls
							;目標 ***.* pls
	MOV.L	#_SETX_UPDN_CHK_DN_PLS,R4		;180.0pls(下死点角度 180.0)
	MOV.L	@R4,R3					;


;;;;	TST	#BIT5,R0			;
	TST	R0,R0				;
	TST_BIT_ON UPPLS1_OBJMAK_COM_145	;逆転固定(1回起動した場合は0になるのでｻｰﾁ完了時は0)

;	===== R3[下死点]~R2[待機点]の範囲にR1がいれば正転===
	DIG_AREA_CHK STREG=R3,EDREG=R2,PVREG=R1,ANSREG=R0	;
	XOR	R3,R3
	TST	R0,R0
	TST_BIT_ON UPPLS1_OBJMAK_COM_150		;
UPPLS1_OBJMAK_COM_145:				;R2
	MOV	#-1,R3
UPPLS1_OBJMAK_COM_150:				;R2

	TST	R3,R3					;正転
	TST_BIT_ON UPPLS1_OBJMAK_COM_300		;逆転 JUMP
;	==== 正転方向でいく ====
	SUB	R1,R2					;
	CMP/PZ	R2
	BT	UPPLS1_OBJMAK_COM_500			;R2 >= 0(R2は符号付距離)
	MOV.L	#_LINK_1ROT_PLS,R5			;
	MOV.L	@R5,R4					;
	ADD	R4,R2					;
	CMP/PZ	R2 
	BT	UPPLS1_OBJMAK_COM_500		;
	XOR	R2,R2					;
	M_BRA	UPPLS1_OBJMAK_COM_500			;

UPPLS1_OBJMAK_COM_300:				;R2
	SUB	R1,R2					;300-270
	NEG	R2,R2					;
	CMP/PZ	R2
	BT	UPPLS1_OBJMAK_COM_400			;R2 >= 0(R2は符号付距離)
	MOV.L	#_LINK_1ROT_PLS,R5			;
	MOV.L	@R5,R4					;
	ADD	R4,R2					;
	CMP/PZ	R2 
	BT	UPPLS1_OBJMAK_COM_400			;
	XOR	R2,R2					;
UPPLS1_OBJMAK_COM_400:				;
	NEG	R2,R2					;
UPPLS1_OBJMAK_COM_500:				;
	XOR	R5,R5					;
	MOV	R2,R6					;
	CMP/PZ	R2					;
	BT	UPPLS1_OBJMAK_COM_600			;
	MOV	#-1,R5					;
UPPLS1_OBJMAK_COM_600:				;


	MOV.L	#_LINK_RL_OBJ_ABSPLS,R4					;//ﾘｱﾙﾀｲﾑ目標絶対位置(ﾊﾞｯｸﾗｯｼなし)	;
	MOV.L	@R4+,R1							;
	MOV.L	@R4,R2							;
	PUSH_REG1 R1
	PUSH_REG1 R2
	ADD8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;

	MOV.L	#_LINK_SV_OBJ_ABSPLS,R4				;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	R1,@R4						;
	MOV.L	R2,@(1*4,R4)					;目標位置ｾｯﾄ
	POP_REG1 R6
	POP_REG1 R5
	
	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2
	XOR	R3,R3
	CMP/PZ	R1				;
	BT	UPPLS1_OBJMAK_COM_750		;
	MOV	#BIT0,R3			;
UPPLS1_OBJMAK_COM_750:				;
	MOV.L	#_POS_DRV_DIRECT,R1		;起動時(SV-LEVEL)
	MOV.W	R3,@R1				;

	MOV.L	#_POSLSI_DRIV_SHIN,R1	;//BIT0
	MOV.W	@R1,R0			;
	AND	#LOW ~BIT0,R0		;
	OR	R3,R0			;
	MOV.W	R0,@R1			;

	SUB_END
	M_RTS




;	***************************************************
;	***						***
;	***	シーケンスによる運転方向の決定		***
;	***						***
;	***************************************************
;	Input 	R0 ==0 正転
;		R0 !=0(BIT13)逆転
;	2004-07-01
;
	.ALIGN	4				;
_LINK_DIR_OBJMAK3:
	SUB_START

	PUSH_REG1 R0


	FAR_JSR	#_X_SET_PV_ABS_TO_OBJ,R0			;20060919

	FAR_JSR	#_NOW_INC_DIG_MAK,R0			;

;	=== 目標角度() ====
	MOV.L	#_SETX_UPAREA_PLS,R0			;//4;待機点
	MOV.L	@R0,R2					;
	MOV.L	#_LINK_NOWROT_OFSPLS_P,R4		;
	MOV.L	@R4,R1					;現在 ***.* pls
							;目標 ***.* pls

	POP_REG1 R0					;
	
	TST	R0,R0					;
	TST_BIT_ON LINK_DIR_OBJMK3_300			;
;	==== 正転方向でいく ====
	SUB	R1,R2					;
	CMP/PZ	R2
	BT	LINK_DIR_OBJMK3_250				;R2 >= 0(R2は符号付距離)
	MOV.L	#_LINK_1ROT_PLS,R5			;
	MOV.L	@R5,R4					;
	ADD	R4,R2					;
	CMP/PZ	R2 
	BT	LINK_DIR_OBJMK3_250			;
	XOR	R2,R2					;
LINK_DIR_OBJMK3_250:					;
	FAR_JSR	#_OBJ_NEAR_CHK1,R0			;ANS R0!=0 NEAR ZERO
	TST	R0,R0					;
	TST_BIT_OF LINK_DIR_OBJMK3_280			;NOT NEAR ZERO JUMP
	XOR	R2,R2					;
LINK_DIR_OBJMK3_280:
	M_BRA	LINK_DIR_OBJMK3_500				;

;	====逆転方向でいく=====
LINK_DIR_OBJMK3_300:					;R2
	SUB	R1,R2					;
	NEG	R2,R2					;
	CMP/PZ	R2					;
	BT	LINK_DIR_OBJMK3_400				;R2 >= 0(R2は符号付距離)
	MOV.L	#_LINK_1ROT_PLS,R5			;
	MOV.L	@R5,R4					;
	ADD	R4,R2					;
	CMP/PZ	R2 
	BT	LINK_DIR_OBJMK3_400			;
	XOR	R2,R2					;
LINK_DIR_OBJMK3_400:					;R2 ≦NERA-ZERO or  1REV-NEAR≦R2なら R2=0とする

	FAR_JSR	#_OBJ_NEAR_CHK1,R0			;ANS R0=0 NOT NEAR ZERO
	TST	R0,R0					;
	TST_BIT_OF LINK_DIR_OBJMK3_450			;
	XOR	R2,R2					;
LINK_DIR_OBJMK3_450:					;

	NEG	R2,R2					;
LINK_DIR_OBJMK3_500:					;R2:+/-
	XOR	R5,R5					;
	MOV	R2,R6					;
	CMP/PZ	R2					;
	BT	LINK_DIR_OBJMK3_600			;
	MOV	#-1,R5					;
LINK_DIR_OBJMK3_600:					;


	MOV.L	#_LINK_RL_OBJ_ABSPLS,R4					;//ﾘｱﾙﾀｲﾑ目標絶対位置(ﾊﾞｯｸﾗｯｼなし)	;
	MOV.L	@R4+,R1							;
	MOV.L	@R4,R2							;
	PUSH_REG1 R1
	PUSH_REG1 R2
	ADD8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;
	MOV.L	#_LINK_SV_OBJ_ABSPLS,R4				;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	R1,@R4						;
	MOV.L	R2,@(1*4,R4)					;目標位置ｾｯﾄ
	POP_REG1 R6
	POP_REG1 R5
	
	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2
	XOR	R3,R3
	CMP/PZ	R1				;
	BT	LINK_DIR_OBJMK3_750		;
	MOV	#BIT0,R3			;
LINK_DIR_OBJMK3_750:				;
	MOV.L	#_POS_DRV_DIRECT,R1		;起動時(SV-LEVEL)
	MOV.W	R3,@R1				;

	MOV.L	#_POSLSI_DRIV_SHIN,R1	;//BIT0
	MOV.W	@R1,R0			;
	AND	#LOW ~BIT0,R0		;
	OR	R3,R0			;
	MOV.W	R0,@R1			;

	SUB_END
	M_RTS

;	***************************************************
;	***						***
;	***	今の回転上の待機点を目指す		***
;	***	本当は正転する待機点を目指す		***
;	***************************************************
;	ｱﾙｺﾞﾘｽﾞﾑ:今の回転の待機点が負方向なら、１回転した待機点に変更し、
;
	.ALIGN	4				;
_LINK_UPPLS_DNDRIV:
	SUB_START

	FAR_JSR	#_NOW_INC_DIG_MAK,R0			;

;	----------- 2014-09-18 -----------------
	FAR_JSR	#_LINK_UPPLS_OBJ_SELECT1,R0		;
	TST	R0,R0					;
	TST_BIT_OF LINK_UPPLSDN_DRV050			;強制書き換えなし
	M_BRA	LINK_UPPLSDN_DRV130			;


LINK_UPPLSDN_DRV050:
	PUSH_REG1 R2					;
	FAR_JSR	#_AREACHK_0DIG_TO_180,R0		;ANS:R0
	POP_REG1 R2					;R2;右側待機点

	TST	R0,R0					;
	TST_BIT_ON LINK_UPPLSDN_DRV130			;0~180度：右半球

	MOV.L	#_ORIGN_180ARA_FLG,R0			;
	MOV.W	@R0,R0					;
	TST	#BIT5,R0				;
	TST_BIT_ON LINK_UPPLSDN_DRV130			;181~182度：右半球


	MOV.L	#_DNM_SETX_UPAREA_PLS,R0		;//4;左半球待機点
	MOV.L	@R0,R2					;
	M_BRA	LINK_UPPLSDN_DRV130			;


;	--------------- INPUT:R2----------
LINK_UPPLSDN_DRV130:
	XOR	R0,R0					;
	M_BRA	LINK_UPPLSDN_DRV140
LINK_UPPLSDN_DRV135:
	MOV.B	#BIT5,R0				;

LINK_UPPLSDN_DRV140:

	FAR_JSR	#_UPPLS1_OBJMAK_COMMON,R4


	SUB_END
	M_RTS


_AREACHK_0DIG_TO_180:
	SUB_START

	MOV.L	#_SET1_UPAREA_DIG1,R0
	MOV.W	@R0,R1			;0度相当

	MOV.L	#_INC_ENC360,R0		;ｸﾗﾝｸ変換前角度
	MOV.W	@R0,R2			;

	MOV.W	#_UPDN_DIRJG_DIG,R3	;

	FAR_JSR	#_DIG_AREA_CHK0,R0	;R1<= R2 <= R3 THEN R0=1


	SUB_END
	M_RTS


;	***********************************
;	***				***
;	***	R2：移動距離		***
;	***				***
;	***********************************
;	ANS R0
;	MOV.L	#_LINK_1ROT_PLS,R5			;
;	MOV.L	@R5,R4					;
;LINK_DIR_OBJMK3_400:					;
;	R2 ≦NEAR(1)  or  1REV-NEAR≦R2(-1)
;	NEAR<R2<1REV-NEAR THEN R0=0

	.ALIGN	4				;
_OBJ_NEAR_CHK1:
	SUB_START
	XOR	R0,R0
	MOV.L	#_SET1_OBJARA_INPXPLS,R5		;
	MOV.W	@R5,R4					;
	MOV.W	#D'100,R5				;min 100pls
	CMP/GE	R5,R4					;
	BT	OBJ_NEAR_CK_030				;
	MOV	R5,R4					;
OBJ_NEAR_CK_030:					;

	CMP/GT	R4,R2					;
	BT	OBJ_NEAR_CK_050				;R4 < R2 JUMP
	MOV	#1,R0					;R2≦R4
	M_BRA	OBJ_NEAR_CK_EXT				;ﾆｱｾﾞﾛ幅

OBJ_NEAR_CK_050:
	MOV.L	#_LINK_1ROT_PLS,R5			;
	MOV.L	@R5,R5					;
	SUB	R4,R5					;
	CMP/GT	R2,R5					;R2<R5(1ROT-)
	BT	OBJ_NEAR_CK_EXT				;
	MOV	#-1,R0					;
OBJ_NEAR_CK_EXT:
	SUB_END
	M_RTS

	


;	*******************************************
;	***	回転ﾊﾟﾙｽR1,R2+ｵﾌｾｯﾄR5,R6	***
;	***	LIMIT MAX/MIN			***
;	*******************************************
;	Input R1,R2,R5,R6
;	Output R1,R2 
;	Keep R5,R6
	.ALIGN	4				;
_ADDR56_R12_ANS_R12_LIMIT_MAX_MIN:
	SUB_START
	ADD8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2		;
	MAX_MIN8B	DT_REGH=R1,DT_REGL=R2,WKRG1=R0,WKRG2=R4,		;
+			MAX_H=_CALC_PLS_PMAX_H32,MAX_L=_CALC_PLS_PMAX_L32,	;
+			MIN_H=_CALC_PLS_MMIN_H32,MIN_L=_CALC_PLS_MMIN_L32	;
	SUB_END
	M_RTS


;	***********************************
;	***				***
;	***	最大正転値・最小値	***
;	***				***
;	***********************************
;	Input R0 BIT0=0正転 BIT0=1逆転
	.ALIGN	4				;
_LINK_P_M_MAX:
	SUB_START

	MOV.L	#_CALC_PLS_PMAX_H32,R1	;
	MOV.L	#_CALC_PLS_PMAX_L32,R2	;

	TST	#BIT0,R0		;
	TST_BIT_OF LINK_PM_MX50
	MOV.L	#_CALC_PLS_MMIN_H32,R1	;
	MOV.L	#_CALC_PLS_MMIN_L32,R2	;

LINK_PM_MX50:			;
	MOV.L	#_LINK_SV_OBJ_ABSPLS,R4		;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	R1,@R4				;
	MOV.L	R2,@(1*4,R4)			;目標位置ｾｯﾄ
	SUB_END
	M_RTS

;	***************************************************
;	***						***
;	***	はじめから待機点目標位置への位置決め	***
;	***	2004-05-24(ﾒｲﾝ側での目標位置作成)	***
;	***						***
;	***************************************************
	.ALIGN	4				;
_ORGIN_OBJ_POS_CTRL_ST1:			;
	SUB_START
	MOV.L	#_ORIGN_OBJ_CTL_FLG,R1		;
	MOV.W	#BIT0,R0			;
	MOV.W	R0,@R1				;

	MOV.L	#_CB_SEQ_CB_COM346,R1		;2004-07-01
	MOV.W	@R1,R0				;
	MOV.W	#BIT14,R1			;
	TST	R1,R0				;
	TST_BIT_OF ORGIN_OBJ_POS_CTLST1_100	;BIT14=0 自動判別

	MOV.W	#BIT13,R1			;
	AND	R1,R0
	FAR_JSR	#_LINK_DIR_OBJMAK3,R1		;Input R0 R0==0/R0!=0(BIT13)
	M_BRA	ORGIN_OBJ_POS_CTLST1_200	;


ORGIN_OBJ_POS_CTLST1_100:
;	--------- 2014-09-18-------------
	MOV.L	#_SETX_POS_CTL_MATH,R1		;
	MOV.W	@R1,R0				;
	TST	#(_DMATH_DNDRIV),R0		;
	TST_BIT_OF ORGIN_OBJ_POS_CTLST1_150	;ふりこ以外

;	-------- ふりこ範囲確認--------------
;	待機点+0~181までは右半球
	FAR_JSR	#_LINK_UPPLS_DNDRIV,R0		;
	M_BRA	ORGIN_OBJ_POS_CTLST1_200	;




ORGIN_OBJ_POS_CTLST1_150:
	FAR_JSR	#_LINK_UPPLS_A_OBJMAK3,R0	;自動で方向判別(2004-05-24)
ORGIN_OBJ_POS_CTLST1_200:			;


	FAR_JSR	#_DNDUPS_SPD_SET,R4		;
	FAR_JSR	#_ORG_END_SIG_CLR,R0		;206.4 OFF

	SUB_END
	M_RTS

	.ALIGN	4				;
_ORGIN_OBJ_POS_CTRL_ST2:				;
	SUB_START
	MOV.L	#_ORIGN_OBJ_CTL_FLG,R1		;
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;
	TST_BIT_OF ORGIN_OBJ_POSCTLST2_EXT	;(待機点位置決め中 NO! JUMP)

	MOV.L	#_INT_DND_CTL_STEP,R1		;
	MOV.W	@R1,R0				;
	OR	#BIT1,R0			;
	MOV.W	R0,@R1				;

ORGIN_OBJ_POSCTLST2_EXT				;

	SUB_END
	M_RTS



;	***************************************************
;	***						***
;	***						***
;	***						***
;	***						***
;	***		位置決め200usec割込		***
;	***		1msecでも可能			***
;	***						***
;	***						***
;	***						***
;	***						***
;	***************************************************
;	停止ﾀｲﾏの処理・多段全てを行う
;	即停止状態
;	ここではﾊﾟﾙｽの払出しﾊﾟﾙｽの積算は行う
;	_INT_POS_CTL_FLAG
;		0000,0000:IDEL()
;			BIT0:(INITAL完了)
;			      BIT0=1で払いﾃﾞｰﾀ作成,起動中
;			BIT2:減速停止ﾗｯﾁ(払出停止待ち)
;			BIT3:急停止ﾗｯﾁ(払出停止待ち)
;			BIT4:
;			BIT6:位置決め完了(ﾆｱｾﾞﾛ)--->IDELへ
;
;	S2b	INT_POS_STEP_FLG(ｽﾃｯﾌﾟ,段取共通);
;				BIT0:1ｽﾃｯﾌﾟﾃﾞｰﾀ作成完了	:
;				BIT1:払い出し開始	:
;				BIT2:
;				BIT3:ﾀｲﾏ測定中
;				BIT4:完了
	.ALIGN	4				;
_INT_POS_CTRL:
	SUB_START

	FAR_JSR	#_ERR_INFO_DT_IN0,R0	;

;-------------------[2015-04-08]---------------
	FAR_JSR	#_ENDHAND_WAIT_TIMCNT,R0	;

	MOV.L	#_emg_err_flg,R1	;//異常ﾗｯﾁ
	MOV.W	@R1,R0			;
	TST	R0,R0			;
	TST_BIT_OF INT_POSCTL_CHK00	;
	M_BRA	INT_POSCTL_0910		;


INT_POSCTL_CHK00:

;	------- 2010-08-20[制動モード]
	MOV.L	#_BRKTST_MOD_FLG,R1	;
	MOV.W	@R1,R0			;
	TST	#BIT0,R0		;
	TST_BIT_OF INT_POSCTL_CHK10	;

	FAR_JSR	#_BRKTST_POS_CTL,R0	;

	M_BRA	INT_POSCTL_0910		;

INT_POSCTL_CHK10:





	FAR_JSR	#_GAMEN_OVER_RIDE,R0		;MAIN LOOP DATA 1 CHECK
	FAR_JSR	#_OVER_LIDE_SEQREF,R0		;SEQ       DATA 1 CHKEAK
	FAR_JSR	#_SET_OVER_RIDE,R0		;

;;	--------- 2006-10-16---
;;	MOV.L	#_OVER_RIDE_USEFUL,R1
;;	MOV.W	@R1,R0
;;	TST	#BIT0,R0
;;	TST_BIT_OF OVERRIDE_CHG050
;;	FAR_JSR	#_OVERRIDE_CALC_SPED_SEL,R0	;速度ﾘｱﾙﾀｲﾑ
;;OVERRIDE_CHG050




;	------------------------------------------
;	------ 2010-10-07 ------------------------
;	------------------------------------------
;	-----ふりこの場合待機点でのみ速度反映 ----
	FAR_JSR	#_CHK_DNM_SPEC_MOD1,R0		;
	TST	R0,R0				;
	TST_BIT_ON OVERRIDE_CHG050		;ふりこだ!
;	---------------------------------------


	MOV.L	#_OVER_RIDE_USEFUL,R1
	MOV.W	@R1,R0
	TST	#(BIT1+BIT0),R0			;SEQ
	TST_BIT_OF OVERRIDE_CHG050

	FAR_JSR	#_OVERRIDE_CALC_SPED_SEL,R0	;

OVERRIDE_CHG050

;;;;;;;;;;;;;	2015-11-15 ちゃんとした場所で対応
;;;;;;;;;;;;;;-------------------超お試し[2015-04-08]---------------
;;;;;;;;;;;;;	MOV.L	#_MODE_SEL,R1				;
;;;;;;;;;;;;;	MOV.W	@R1,R0					;
;;;;;;;;;;;;;	TST	#_W1INC+_W1SGL,R0			;
;;;;;;;;;;;;;	TST_BIT_OF FORCE_STEPEND_HAND100EXT		;（段取でもある)
;;;;;;;;;;;;;
;;;;;;;;;;;;;	FAR_JSR	#_API_ENDHAND_SIGCHK,R0			;
;;;;;;;;;;;;;	TST	R0,R0			
;;;;;;;;;;;;;	TST_BIT_OF FORCE_STEPEND_HAND100EXT		;
;;;;;;;;;;;;;	M_BRA	FORCE_STEPEND_HAND100			;
;;;;;;;;;;;;;FORCE_STEPEND_HAND100EXT



	MOV.L	#_INT_CYC_DRV_STS,R5		;//BIT0:CYCLE　END()
	MOV.W	@R5,R0				;
	TST	#BIT6,R0			;位置決め完了?
	TST_BIT_OF INT_POSCTL_0020		;
	M_BRA	INT_POSCTL_0700

INT_POSCTL_0020:
	MOV.L	#_INT_POS_CTL_FLAG,R5		;
	MOV.W	@R5,R0				;
	TST	#(BIT6+BIT4+BIT3+BIT2),R0	;
	TST_BIT_OF INT_POSCTL_0040		;
	M_BRA	INT_POSCTL_0300			;

INT_POSCTL_0040:
	TST	#BIT0,R0		;
	TST_BIT_OF INT_POSCTL_0045	;
	M_BRA	INT_POSCTL_0200	;起動処理 BIT0
INT_POSCTL_0045:

;	===================
	MOV.L	#_MNWR_POS_CMD,R6	;ﾊﾟﾙｽ払出即停止
	MOV.W	@R6,R0			;
	AND	#(BIT2+BIT1+BIT0),R0	;
	CMP/EQ	#BIT0,R0		;
	BT	INT_POSCTL_0048		;001[起動]
	M_BRA	INT_POSCTL_0190		;EXIT
;	==== 通常の位置決め起動コマンド状態
INT_POSCTL_0048:

	XOR	R2,R2
	MOV.L	#_INT_POS_STEP_FLG,R1	;
	MOV.W	R2,@R1			;
	MOV.L	#_INT_DND_CTL_STEP,R1;
	MOV.W	R2,@R1
	MOV.L	#_INT_DND_STEP_FLG,R1	;//(上死点復帰の工程管理)
	MOV.W	R2,@R1			;

;	===========================
	MOV.L	#_CAM_CNT_CHG_FLG,R1		;//ｶﾑ:連続Vで1行程目になった際の微妙なﾀｲﾐﾝｸﾞ測定
	MOV.W	R2,@R1				;
;	===========================


;	-------- 2014-09-26 寸動--------------
	MOV.L	#_INC_RESET_USE_F,R1	;//STEPを参照して!
	MOV.W	@R1,R0			;
	TST	R0,R0			;
	TST_BIT_OF INT_POSCTL_0080	;

	MOV.L	#_INC_RESET_STEP,R1	;
	MOV.W	@R1,R4
	MOV.L	#_SV_POS_CTL_STEP,R1	;//1msec 制御上の見かけ
	MOV.W	R4,@R1			;

	FAR_JSR	#_INC_RST_WORK_CLR,R0

INT_POSCTL_0080
;	------ ﾓｰｼｮﾝ運転 --------
	MOV.L	#_SV_POS_CTL_STEP,R1	;//1msec 制御上の見かけ
	MOV.W	@R1,R4			;
	MOV.L	#_INT_POS_CTL_STEP,R2	;//内部制御工程1~11
	MOV.W	R4,@R2			;







INT_POSCTL_0100:
;	===========================================
;	===		起動処理		===
;	===========================================
;;2002-09-05	FAR_JSR	#_POS_LSI_START_INITAL,R0	;

;	----------- 2012-05-17 反転のタイマ継続処理CHK---------
	FAR_JSR	#_DURING_TIM_CNTINUE_CHK,R0					;
	TST	R0,R0								;
	TST_BIT_OF INT_POSCTL_0102						;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_INT_POS_CTL_FLAG,LG=W,BIT=BIT0,WKREG=R1	;必要があればここでつじつまあわせ
	M_BRA	INT_POSCTL_0190							;
INT_POSCTL_0102:




	MOV.L	#_MODE_SEL,R1			;
	MOV.W	@R1,R0				;
	TST	#(_W1DUP+_W1DIC),R0		;
	TST_BIT_ON INT_POSCTL_0120		;


	.AIF	_PRG_CHG200300403 EQ _COMPILE_YES
	MOV.L	#_START_FLG_AFTER_EMG,R1	;???
	MOV.W	#1,R0				;
	MOV.W	R0,@R1				;
	.AENDI


;	-------------繰り返し 2014-09-22 ---------------
	MOV.L	#_MOT_REP_F,R1				;
	MOV.W	@R1,R0					;
	TST	#BIT0,R0				;
	TST_BIT_OF INT_POSCTL_0102A			;

;	-------- 繰り返しの待機点戻り工程--------------
	FAR_JSR	#_MOT_REPSTART_CALC,R0			;
	M_BRA	INT_POSCTL_0115	


INT_POSCTL_0102A:

	MOV.L	#_CPOS_CTL_MATH,R0			;
	MOV.W	@R0,R0					;
	TST	#(_DMATH_CNTROT+_DMATH_DNDRIV),R0	;回転or往復[2011-03-23]
	TST_BIT_OF INT_POSCTL_0110
;	===== 回転時の起動===
	FAR_JSR	#_HIST_INFO_DT_IN1,R0		;起動前の目標停止位置

	FAR_JSR	#_POS_LSI_START_INITAL,R0	;[本当にふりこはここを通していいのかな2011-03-23]

	FAR_JSR	#_ERR_INFO_DT_CHK1,R0		;POS_LSI_START_INITALでｸﾘｱされるﾃﾞｰﾀが0か？
	FAR_JSR	#_ERR_INFO_DT_IN1,R0		;2004-01-28(今一)

	MOV.L	#_CPOS_BANK_USELFUL,R1		;
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;
	TST_BIT_ON INT_POSCTL_0103		;上死停止有り

	FAR_JSR	#_POS_1STEP_DATA_MAK1,R0	;_LNGTH,SHIN,SPEED<停止からの起動か実ﾊﾟﾙｽから>

	M_BRA	INT_POSCTL_0105
INT_POSCTL_0103:				;上死停止なし
	FAR_JSR	#_POS_CNT_BANK_DTMAK1,R0	;これは必ずSVから演算(2004-12-20)もう１回転先になる

INT_POSCTL_0105:

	FAR_JSR	#_ERR_INFO_DT_IN2,R0		;2004-01-28(data-smp-only)
	M_BRA	INT_POSCTL_0115			;

INT_POSCTL_0110:
;	===== 反転時の起動===
	FAR_JSR	#_POS_LSI_START_INITL2,R0	;
	FAR_JSR	#_POS_1STEP_DATA_MAK1CL,R0	;目標位置に対して少しパルスを減らす 2011-02-19


INT_POSCTL_0115:
	FAR_JSR	#_POS_HOLD_FLG_STR2CLR,R0	;2014-09-12
	M_BRA	INT_POSCTL_0140			;


;	------------段取、原点復帰、手動パルサ
INT_POSCTL_0120:				;
;	---------- 2006-07-28------
	MOV.L	#_TEP_MODE_DRV,R1		;//起動時に判定
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_OF INT_POSCTL_0130		;
;;;;;	FAR_JSR	#_POS_LSI_START_INITAL,R0	;手動パルサ
	FAR_JSR	#_POS_LSI_START_INITAL_TEP,R0	;2013-06-13
	MOV.L	#_LINK_SV_OBJ_SPDPLS,R1		;//目標速度
	MOV.L	@R1,R2				;
	FAR_JSR	#_POS_LSI_TOP_SPEED_SET,R1	;
	FAR_JSR	#_TEP_1STEP_DATA_MAK1,R0	;_LNGTH,SHIN,SPEED
	M_BRA	INT_POSCTL_0140			;

INT_POSCTL_0130:				;
	FAR_JSR	#_POS_LSI_START_INITAL,R0	;((((((((((((段取・原点起動スキャン)))))))))))
	FAR_JSR	#_DND_1STEP_DATA_MAK1,R0	;_LNGTH,SHIN,SPEED


INT_POSCTL_0140:				;
	FAR_JSR	#_POS_LENGTH_ADD_DATA,R0
	FAR_JSR	#_ERR_INFO_DT_IN3,R0		;2004-01-28ADD,TOTAL(起動開始)

;;;;;	FAR_JSR	#_POS_PLS_OUTPUT_DATA,R0	;停止時からの起動
	FAR_JSR	#_POS_PLSOUT_SET_RETRY,R0	;(停止時からの起動の場合のみ有効・安一のみ)

;	== 2004-03 ===
	FAR_JSR	#_ERR_INFO_DT_CHK2,R0		; SGL ONLY
	MOV.W	#D'2,R0			;
	MOV.L	#_ERR_INFO_DLY_TIM,R1		;
	MOV.W	R0,@R1				;

	FAR_JSR	#_ERR_INFO_DT_IN4,R0		;
	FAR_JSR	#_FWD_REV_START,R1		;起動

;	-------- 2010-09-27 ふりこ情報--------
	FAR_JSR	#_DNM_START_ACC_CALC,R0
	
	MEM1_BIT0_TO_BIT7_ORSET MEM=_INT_POS_CTL_FLAG,LG=W,BIT=BIT0,WKREG=R1	;

	FAR_JSR	#_BRK_ERR_WORK_CLR1,R0		;_BRK_ERR_CHK_START2	;2003-07-01

	FAR_JSR	#_POS_CMP_1STEP_START_INI,R0

;	---------------- 起動 2011-09-01 -------------------
	FAR_JSR	#_UP_ACCERR_START_INI,R0
	
INT_POSCTL_0190:
	M_BRA	INT_POSCTL_0800			;

INT_POSCTL_0200:
;	===========================================
;	===					===
;	===		起動中			===
;	===					===
;	===========================================
	MOV.L	#_MNWR_POS_CMD,R6						;
	MOV.W	@R6,R0								;
	TST	R0,R0								;ﾊﾟﾙｽ払出即停止
	TST_BIT_ON INT_POSCTL_0220						;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_INT_POS_CTL_FLAG,LG=W,BIT=BIT3,WKREG=R1	;
	FAR_JSR	#_FWD_REV_STSIG_OFF,R0				;
	FAR_JSR	#_POS_LSI_EMG_STOP,R0						;急停止
	FAR_JSR	#_LSI_REST_PLS_CHK_STOP_CLR,R0					;2004-03-03
	M_BRA	INT_POSCTL_0800							;

INT_POSCTL_0220:								;
	TST	#BIT1,R0							;減速停止ｺﾏﾝﾄﾞ
	TST_BIT_OF INT_POSCTL_0240						;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_INT_POS_CTL_FLAG,LG=W,BIT=BIT2,WKREG=R1	;
	FAR_JSR	#_FWD_REV_STSIG_OFF,R0				;
	FAR_JSR	#_POS_LSI_SLOW_STOP,R0						;
	FAR_JSR	#_LSI_REST_PLS_CHK_STOP_CLR,R0					;2004-03-03
	M_BRA	INT_POSCTL_0800							;

INT_POSCTL_0240:
;	==========(位置決め完了・継続) ==========
	MOV.L	#_INT_POS_STEP_FLG,R1						;//ｽﾃｯﾌﾟ,段取り共通
	MOV.W	@R1,R0								;
	TST	#BIT6,R0							;工程終了
	TST_BIT_OF INT_POSCTL_0250						;
	FAR_JSR	#_CYC_END_POS_FLG_SET,R0					;
	FAR_JSR	#_CYC_END_POS_FLG_CLR,R0					;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_INT_POS_CTL_FLAG,LG=W,BIT=BIT6,WKREG=R1	;位置決め完了
	M_BRA	INT_POSCTL_0800							;


INT_POSCTL_0250:
	MOV.L	#_MODE_SEL,R1			;
	MOV.W	@R1,R0				;
	TST	#_W1DIC,R0			;
	TST_BIT_ON INT_POSCTL_0260		;段取

	TST	#_W1DUP,R0			;
	TST_BIT_ON INT_POSCTL_0260		;待機点復帰


	FAR_JSR	#_POS_ALL_STEP_CTRL,R0		;ﾓｰｼｮﾝ
	
	M_BRA	INT_POSCTL_0280			;

INT_POSCTL_0260:				;
	FAR_JSR	#_DND_ALL_STEP_CTRL,R0		;(((((((((((段取毎スキャン)))))))))))))))
INT_POSCTL_0280:
	FAR_JSR	#_POS_PLS_OUTPUT_DATA,R0	;位置決めLSIｱｸｾｽ(毎ｽｷｬﾝ)

;	=== FLAG SET(REST-PLS REFLASH-END)====
	eSHi_SET_IM_MOV DST=_eSHi_REST_RL_HF,L1=W,WKREG1=R1,WKREG2=R0,IMD=1	;


;	=== 2004-01-28===
	FAR_JSR	#_ERR_INFO_DT_CHK2,R0		;0CHEAK(起動中常時) SGL-ONLY
	FAR_JSR	#_ERR_INFO_DT_CHK3,R0		;PLS SGL-OMLY

	.AIF _CMP_ERR_SPEC_ENB	EQ _CMPILE_YES	;2006-09-19
	FAR_JSR	#_ERR_INFO_DT_CHK_CMP2,R0	;SGL-ONLY
	.AENDI

	M_BRA	INT_POSCTL_0800


;	***************************************************
;	***		終わりへ向かう状態		***
;	***************************************************
INT_POSCTL_0300:
	TST	#BIT6,R0			;
	TST_BIT_ON INT_POSCTL_0700		;(位置決め完了状態)起動指令OFF待ち
	TST	#BIT3,R0			;
	TST_BIT_ON INT_POSCTL_0500		;急停止の払出待ち
	TST	#BIT2,R0			;
	TST_BIT_ON INT_POSCTL_0320		;減速停止の払出待ち
	M_BRA	INT_POSCTL_0900			;ｱｲﾄﾞﾙ

INT_POSCTL_0320:
;	===========================================
;	===		減速停止中		===
;	===========================================
	MOV.L	#_MNWR_POS_CMD,R6		;
	MOV.W	@R6,R0				;
	TST	R0,R0				;ﾊﾟﾙｽ払出即停止
	TST_BIT_ON INT_POSCTL_0500	;
	FAR_JSR	#_FWD_REV_STSIG_OFF,R0		;起動信号一定時間ONしたらOFF:但し払い出し中が立つ
	FAR_JSR	#_POS_LSI_EMG_STOP,R0		;急停止
	MEM1_BIT0_TO_BIT7_ORSET MEM=_INT_POS_CTL_FLAG,LG=W,BIT=BIT3,WKREG=R1	;急停止へ
	M_BRA	INT_POSCTL_0800			;


;	===========================================
;	===		急停止中		===
;	===========================================
INT_POSCTL_0500:
	FAR_JSR	#_LOD_POS_STS_REG_SLOW,R1	;
	TST	#BIT2,R0			;停止?
	TST_BIT_OF INT_POSCTL_0800		;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_INT_POS_CTL_FLAG,LG=W,BIT=BIT6,WKREG=R1	;位置決め完了
	M_BRA	INT_POSCTL_0800		;







;	===========================================
;	===		位置決め完了待ち	===
;	===========================================
INT_POSCTL_0700:					;
	MOV.L	#_INT_CYC_DRV_STS,R5	;//BIT0:CYCLE　END()
	MOV.W	@R5,R0			;
	TST	#BIT6,R0		;
	TST_BIT_ON INT_POSCTL_0900	;
	OR	#BIT6,R0		;
	MOV.W	R0,@R5			;位置決め完了SET
;	===========================	;
;	===	運転終了	===	;
;	===========================	;
	FAR_JSR	#_INT_POS_CTL_END,R0	;
INT_POSCTL_0800:
	NOP
INT_POSCTL_0900:
	MEM_MOV_TO_MEM	_POS_CALC_ERR_FLG1,W	,_POS_CALC_ERR_INF1,W,R1,R2,R3			;
	MEM_MOV_TO_MEM	_POS_CALC_ERR_FLG2,W	,_POS_CALC_ERR_INF2,W,R1,R2,R3			;
	MEM_MOV_TO_MEM	_POS_LSI_ACS_ERR_FLG1,W	,_POS_LSI_ACS_ERR_INF1,W,R1,R2,R3		;



	FAR_JSR	#_POS_OVER_RUN_CHK1,R0		;[S01m 2003-04-03]

INT_POSCTL_0910:


;;;2011-09-14移動[ﾌﾞﾚｰｷﾃｽﾄ中はｵｰﾊﾞﾗﾝを見ない]	FAR_JSR	#_POS_OVER_RUN_CHK1,R0		;[S01m 2003-04-03]




	FAR_JSR	#_ERR_STOP_MOV_CHK,R0		;FLG=R0
	TST	R0,R0				;
	TST_BIT_ON INT_POSCTL_0920		;
	MEM1_BIT0_F_ADCLR MEM=(_SQ_CBWK_TOP+_WKSQCB206),LG=W,BIT=(~BIT1),WKRG1=R1,WKRG2=R4
	M_BRA	INT_POSCTL_0950			;
INT_POSCTL_0920:
	MEM1_BIT0_F_ORSET MEM=(_SQ_CBWK_TOP+_WKSQCB206),LG=W,BIT=(BIT1),WKRG1=R1,WKRG2=R4
INT_POSCTL_0950:

;	------ 2006-09-19 -------
	FAR_JSR	#_MONI_SEINOU_CMP_OUTPUT,R0			;制御(_SH_POSCTL_RL_ABSPLS)を使用している注意
	FAR_JSR	#_RL_POS_DATA_CHK,R0				;
	
	FAR_JSR	#_CNT_HOSEI_CHK_CALC,R0				;

;	----------------------------------------------
	FAR_JSR	#_PLS_LSI_CTRL,R0			;


;	------2012-05-15---------------
	MOV.L	#_DURING_TIM_FX,R1		;ﾓﾆﾀ
	MOV.W	@R1,R2				;
	EXTU.B	R2,R2				;

	MOV.L	#_FUL_CLS_MAXOVER_F,R1		;2012-05-30
	MOV.W	@R1,R0				;
	SHLL8	R0				;
	OR	R0,R2				;

	MOV.L	#_SQ_CBWK_TOP+_WKSQCB231,R1	;
	MOV.W	R2,@R1				;

;	------2012-10-01---------------
	MOV.L	#_INT_CLS_CTL_FLG,R1		;
	MOV.W	@R1,R2				;
	EXTU.B	R2,R2				;

	MOV.L	#_POSLSI_DRIV_SHIN,R1		;//BIT0
	MOV.W	@R1,R0				;
	SHLL8	R0				;
	OR	R0,R2				;

	MOV.L	#_SQ_CBWK_TOP+_WKSQCB232,R1	;
	MOV.W	R2,@R1				;


;----------2013-08-20
	MOV.L	#_POSCTL_STEP_FLG,R1		;
	MOV.W	@R1,R2				;
	MOV.L	#_SQ_CBWK_TOP+_WKSQCB233,R1	;
	MOV.W	R2,@R1				;

;;;;;;;;;;;;;;;;;;;2015-07-07	MOV.L	#_LSI_BUF_PLS_BitComdL+0,R1
;;;;;;;;;;;;;;;;;;;2015-07-07	MOV.W	@R1,R2				;
;;;;;;;;;;;;;;;;;;;2015-07-07	MOV.L	#_SQ_CBWK_TOP+_WKSQCB234,R1	;
;;;;;;;;;;;;;;;;;;;2015-07-07	MOV.W	R2,@R1				;
;;;;;;;;;;;;;;;;;;;2015-07-07
;;;;;;;;;;;;;;;;;;;2015-07-07	MOV.L	#_LSI_BUF_PLS_BitComdL+2,R1
;;;;;;;;;;;;;;;;;;;2015-07-07	MOV.W	@R1,R2				;
;;;;;;;;;;;;;;;;;;;2015-07-07	MOV.L	#_SQ_CBWK_TOP+_WKSQCB235,R1	;
;;;;;;;;;;;;;;;;;;;2015-07-07	MOV.W	R2,@R1				;



	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	INT			***
;	***				***
;	***********************************
	.ALIGN	4				;
_INT_POS_CTL_END:
	SUB_START
	XOR	R0,R0
	MOV.L	#_INT_POS_CTL_FLAG,R1;
	MOV.W	R0,@R1
	MOV.L	#_INT_POS_STEP_FLG,R1;
	MOV.W	R0,@R1
	MOV.L	#_INT_POS_CTL_STEP,R1;
	MOV.W	R0,@R1
;	===========================
	MOV.L	#_CAM_CNT_CHG_FLG,R1		;//ｶﾑ:連続Vで1行程目になった際の微妙なﾀｲﾐﾝｸﾞ測定
	MOV.W	R0,@R1				;
;	===========================

	MOV.L	#_INT_DND_CTL_STEP,R1;
	MOV.W	R0,@R1
	MOV.L	#_INT_DND_STEP_FLG,R1;
	MOV.W	R0,@R1

	MOV.L	#_LNGTH_ADD_DATA,R1;[2];//符号付き
	MOV.L	R0,@R1
	MOV.L	R0,@(4,R1)

	MOV.L	#_LNGTH_TOTAL_OUTPLS,R1;[2];//符号つき TOTAL=TOTAL+ADD ADD_DATA<=0
	MOV.L	R0,@R1
	MOV.L	R0,@(4,R1)

	MOV.L	#_POSLSI_CMP_DATA,R1;//CMP_DATA=CMP_DATA+|ADD_DATA| (符号なし)
	MOV.L	R0,@R1

	MOV.L	#_POSLSI_DELT_POS,R1;//変化分
	MOV.L	R0,@R1

	MOV.L	#_OUTPLS_MOD,R1		;
	MOV.L	R0,@R1			;


;	------- 2015-11-17 -----------------------
	FAR_JSR	#_API_ACCLW_DRV_STOP,R0

	SUB_END
	M_RTS




;	***********************************
;	***				***
;	***	移動距離と速度		***
;	***				***
;	***********************************
	.ALIGN	4
_POS_1STEP_DATA_MAK1:
	SUB_START
	FAR_JSR	#_X_SET_PV_ABS_TO_OBJ,R0		;DUMMY CALL

	MOV.L	#_INT_POS_CTL_STEP,R2		;//内部制御工程1~11
	MOV.W	@R2,R0				;
	ADD	#-1,R0				;
	SHLL2	R0				;
	MOV.L	#_CPOS_SDAT1_SPD,R4		;	//SETX-->起動時COPY
	MOV.L	@(R0,R4),R2			;
	MOV.L	#_LINK_SV_OBJ_SPDPLS,R1		;//目標速度
	MOV.L	R2,@R1				;


	PUSH_REG1	R0
	FAR_JSR	#_POS_LSI_TOP_SPEED_SET,R1	;
	POP_REG1	R0			;R0=*4
	SHLL	R0				;*2
	MOV.L	#_CPOS_SDAT1_STPAPOS,R4	;//起動時,その他で演算 8byte data
	ADD	R0,R4			;
	MOV.L	@R4+,R1			;
	MOV.L	@R4,R2			;(目標位置)
	FAR_JSR	#_LENGH_ADD_CALC,R0	;

	XOR	R3,R3			;
	CMP/PZ	R1			;+正転?
	BT	POS_1STEP_DATMK1_050	;
	MOV	#BIT0,R3		;
POS_1STEP_DATMK1_050:
	MOV.L	#_POSLSI_DRIV_SHIN,R1	;//BIT0
	MOV.W	@R1,R0			;
	AND	#LOW ~BIT0,R0		;
	OR	R3,R0			;
	MOV.W	R0,@R1			;
	SUB_END
	M_RTS


;	***********************************
;	***				***
;	***	移動距離と速度		***
;	***	反転用			***
;	***	2011-02-19		***
;	***				***
;	***********************************
;
;	・上昇のときはBEFOREしない
;	・

	.ALIGN	4
_POS_1STEP_DATA_MAK1CL:
	SUB_START
;----------------------------------------
	FAR_JSR	#_X_SET_PV_ABS_TO_OBJ,R0	;

	MOV.L	#_INT_POS_CTL_STEP,R2		;//内部制御工程1~11
	MOV.W	@R2,R0				;
	ADD	#-1,R0				;
	SHLL2	R0				;
	MOV.L	#_CPOS_SDAT1_SPD,R4		;	//SETX-->起動時COPY
	MOV.L	@(R0,R4),R2			;
	MOV.L	#_LINK_SV_OBJ_SPDPLS,R1		;//目標速度
	MOV.L	R2,@R1				;


	PUSH_REG1	R0
	FAR_JSR	#_POS_LSI_TOP_SPEED_SET,R1	;
	POP_REG1	R0			;R0=*4
	
	PUSH_REG1 R0				;2012-10-05

	SHLL	R0				;*2
	MOV.L	#_CPOS_SDAT1_STPAPOS,R4	;//起動時,その他で演算 8byte data
	ADD	R0,R4				;
	MOV.L	@R4+,R1				;
	MOV.L	@R4,R2				;(目標位置)

	POP_REG1 R0				;2012-10-05


;	--------------------
	MOV.L	#_CPOS_SDAT1_INF1,R4		;
	ADD	R0,R4				;
	MOV.L	@R4,R0				;
	TST	#BIT1,R0			;
	TST_BIT_OF POS_1STEP_DATMK1CL_020	;正

;	------------逆転[手前減速位置演算をしない]-------------
	MOV.L	#_NEG_CTL_OBJ_POS_PUSH,R4	;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	R1,@R4				;
	MOV.L	R2,@(4,R4)			;save
	M_BRA	POS_1STEP_DATMK1CL_040		;

POS_1STEP_DATMK1CL_020:
;	============== input R1,R2 ===============
	FAR_JSR	#_FUL_BEFOR_CALC,R0		;[引いた結果が前段や待機点より小さくなる場合はそれより引かない]
;	============== output R1,R2  =============
POS_1STEP_DATMK1CL_040:



	FAR_JSR	#_LENGH_ADD_CALC,R0		;

	XOR	R3,R3				;
	CMP/PZ	R1				;+正転?
	BT	POS_1STEP_DATMK1CL_050		;
	MOV	#BIT0,R3			;
POS_1STEP_DATMK1CL_050:
	MOV.L	#_POSLSI_DRIV_SHIN,R1		;//BIT0
	MOV.W	@R1,R0				;
	AND	#LOW ~BIT0,R0			;
	OR	R3,R0				;
	MOV.W	R0,@R1				;
;	----------------------------------------
	SUB_END
	M_RTS

;	*******************************************
;	***	input R1,R2 /Output R1,R2	***
;	*******************************************
	.ALIGN	4				;
_FUL_BEFOR_CALC:
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R3
	PUSH_REG1 R4
	PUSH_REG1 R5
	PUSH_REG1 R6

	MOV.L	#_NEG_CTL_OBJ_POS_PUSH,R5		;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	R1,@R5					;
	MOV.L	R2,@(4,R5)				;save

	MOV.L	#_NEG_CTRL_BEFOR_OBJ_PLS,R4	;//目標−手前
	MOV.L	@R4,R6				;
	XOR	R5,R5				;
	TST	R6,R6				;
	TST_BIT_OF FUL_BEFOR_CAL500		;

	MOV.L	#_INT_POS_CTL_STEP,R3		;//内部制御工程1~11
	MOV.W	@R3,R0				;
	MOV.L	#_CPOS_STEP_MAX,R3		;
	MOV.W	@R3,R4				;
	ADD	#1,R4				;
	CMP/EQ	R4,R0				;
	BF	FUL_BEFOR_CAL100		;（この論理では戻り工程は１つだけになる）
	M_BRA	FUL_BEFOR_CAL500		;戻り工程は演算しない

FUL_BEFOR_CAL100:

	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;

FUL_BEFOR_CAL500:
	POP_REG1 R6
	POP_REG1 R5
	POP_REG1 R4
	POP_REG1 R3
	POP_REG1 R0

	SUB_END
	M_RTS


	.ALIGN	4				;
_FUL_START_FUL_OBJ_SET
	SUB_START

	MOV.L	#_NEG_CTL_OBJ_POS_PUSH,R5		;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	@R5,R1					;
	MOV.L	@(4,R5),R2				;save

	MOV.L	#_LINK_SV_OBJ_ABSPLS,R4			;
	MOV.L	R1,@(0,R4)	
	MOV.L	R2,@(4,R4)				;

	MOV.L	#_POSCTL_SV_PLS,R4			;SV
	MOV.L	R1,@(0,R4)	
	MOV.L	R2,@(4,R4)				;

;	---------------リアルタイム目標位置-----------
	MOV.L	#_LINK_RL_OBJ_ABSPLS,R4			;
	MOV.L	R1,@(0,R4)	
	MOV.L	R2,@(4,R4)				;

	MOV.L	#_POSCTL_RL_PLS,R4			;
	MOV.L	R1,@(0,R4)	
	MOV.L	R2,@(4,R4)				;
	SUB_END
	M_RTS
	

;	***********************************
;	***				***
;	***	移動距離と速度		***
;	***	ふりこ・回転の通常	***
;	***				***
;	***********************************
;	FAR_JSR	#_LENGH_ADD_CALC,R0	;
;	が
;	FAR_JSR	#_LENGH_ADD_CALC_SV_TYPE,R0	;
;	になっているだけ
;

	.ALIGN	4				;
_POS_1STEP_DATA_MAK2:
	SUB_START

	FAR_JSR	#_X_SET_PV_ABS_TO_OBJ,R0	;2010-10-05 実測を取り込まない

	MOV.L	#_INT_POS_CTL_STEP,R2		;//内部制御工程1~11
	MOV.W	@R2,R0				;
	ADD	#-1,R0				;
	SHLL2	R0				;
	MOV.L	#_CPOS_SDAT1_SPD,R4		;	//SETX-->起動時COPY
	MOV.L	@(R0,R4),R2			;
	MOV.L	#_LINK_SV_OBJ_SPDPLS,R1		;//目標速度
	MOV.L	R2,@R1				;

	PUSH_REG1	R0
	FAR_JSR	#_POS_LSI_TOP_SPEED_SET,R1	;
	POP_REG1	R0			;R0=*4
	SHLL	R0				;*2
	MOV.L	#_CPOS_SDAT1_STPAPOS,R4	;//起動時,その他で演算 8byte data
	ADD	R0,R4			;
	MOV.L	@R4+,R1			;
	MOV.L	@R4,R2			;(目標位置)
	FAR_JSR	#_LENGH_ADD_CALC_SV_TYPE,R0	;

	XOR	R3,R3			;
	CMP/PZ	R1			;+正転?
	BT	POS_1STEP_DATMK2_050	;
	MOV	#BIT0,R3		;
POS_1STEP_DATMK2_050:
	MOV.L	#_POSLSI_DRIV_SHIN,R1	;//BIT0
	MOV.W	@R1,R0			;
	AND	#LOW ~BIT0,R0		;
	OR	R3,R0			;
	MOV.W	R0,@R1			;
	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	移動距離と速度		***
;	***				***
;	***********************************
;;;;;未使用みたい	.ALIGN	4				;
;;;;;未使用みたい_POS_1STEP_DATA_MAK3:
;;;;;未使用みたい	SUB_START
;;;;;未使用みたい	FAR_JSR	#_X_SET_PV_ABS_TO_OBJ,R0			;20060919
;;;;;未使用みたい
;;;;;未使用みたい	MOV.L	#_INT_POS_CTL_STEP,R2		;//内部制御工程1~11
;;;;;未使用みたい	MOV.W	@R2,R0				;
;;;;;未使用みたい	ADD	#-1,R0				;
;;;;;未使用みたい	SHLL2	R0				;
;;;;;未使用みたい	MOV.L	#_CPOS_SDAT1_SPD,R4		;	//SETX-->起動時COPY
;;;;;未使用みたい	MOV.L	@(R0,R4),R2			;
;;;;;未使用みたい	MOV.L	#_LINK_SV_OBJ_SPDPLS,R1		;//目標速度
;;;;;未使用みたい	MOV.L	R2,@R1				;
;;;;;未使用みたい
;;;;;未使用みたい	PUSH_REG1	R0
;;;;;未使用みたい	FAR_JSR	#_POS_LSI_TOP_SPEED_SET,R1	;
;;;;;未使用みたい	POP_REG1	R0			;R0=*4
;;;;;未使用みたい	SHLL	R0				;*2
;;;;;未使用みたい	MOV.L	#_CPOS_SDAT1_STPAPOS,R4	;//起動時,その他で演算 8byte data
;;;;;未使用みたい	ADD	R0,R4			;
;;;;;未使用みたい	MOV.L	@R4+,R1			;
;;;;;未使用みたい	MOV.L	@R4,R2			;(目標位置)
;;;;;未使用みたい
;;;;;未使用みたい	FAR_JSR	#_FUL_CLS_LENGH_ADD_CALC,R0
;;;;;未使用みたい
;;;;;未使用みたい	XOR	R3,R3			;
;;;;;未使用みたい	CMP/PZ	R1			;+正転?
;;;;;未使用みたい	BT	POS_1STEP_DATMK3_050	;
;;;;;未使用みたい	MOV	#BIT0,R3		;
;;;;;未使用みたいPOS_1STEP_DATMK3_050:
;;;;;未使用みたい	MOV.L	#_POSLSI_DRIV_SHIN,R1	;//BIT0
;;;;;未使用みたい	MOV.W	@R1,R0			;
;;;;;未使用みたい	AND	#LOW ~BIT0,R0		;
;;;;;未使用みたい	OR	R3,R0			;
;;;;;未使用みたい	MOV.W	R0,@R1			;
;;;;;未使用みたい	SUB_END
;;;;;未使用みたい	M_RTS

;	***********************************
;	***				***
;	***	初回起動		***
;	***				***
;	***********************************
;
	.ALIGN	4				;
_DND_1STEP_DATA_MAK1:
	SUB_START
	MOV.L	#_LINK_SV_OBJ_SPDPLS,R1		;//目標速度
	MOV.L	@R1,R2				;

	FAR_JSR	#_POS_LSI_TOP_SPEED_SET,R1	;

	MOV.L	#_LINK_SV_OBJ_ABSPLS,R5		;(はじめの起動分はﾒｲﾝで作られている)
	MOV.L	@R5,R1				;
	MOV.L	@(4,R5),R2			;
	FAR_JSR	#_LENGH_ADD_CALC,R0		;ANS R1,R2
	XOR	R3,R3				;
	CMP/PZ	R1				;+正転?
	BT	DND_1STEP_DATMK1_050		;
	MOV	#BIT0,R3			;
DND_1STEP_DATMK1_050:
	MOV.L	#_POSLSI_DRIV_SHIN,R1	;//BIT0
	MOV.W	@R1,R0			;
	AND	#LOW ~BIT0,R0		;
	OR	R3,R0			;
	MOV.W	R0,@R1			;
	SUB_END
	M_RTS



;	***********************************
;	***				***
;	***	ﾓｰｼｮﾝ全工程		***
;	***				***
;	***********************************
;	======== 停止待ち(速度変更)	0000,0000	====
;	======== ﾀｲﾏ計測 		BIT0		====
;	======== 再起動/終了		BIT1		====
;	======== BIT6;終了
	.ALIGN	4				;
_POS_ALL_STEP_CTRL:
	SUB_START

;;;;;;;;;;;;[2015-11-15]ちゃんとした場所へ移動
;;;;;;;;;;;;;-------------------超お試し[2015-04-08]---------------
;;;;;;;;;;;;	MOV.L	#_MODE_SEL,R1				;
;;;;;;;;;;;;	MOV.W	@R1,R0					;
;;;;;;;;;;;;	TST	#_W1INC+_W1SGL,R0			;
;;;;;;;;;;;;	TST_BIT_OF FORCE_STEPEND_HAND200EXT		;（段取でもある)
;;;;;;;;;;;;
;;;;;;;;;;;;	FAR_JSR	#_API_ENDHAND_SIGCHK,R0		;
;;;;;;;;;;;;	TST	R0,R0				;
;;;;;;;;;;;;	TST_BIT_OF FORCE_STEPEND_HAND200EXT	;
;;;;;;;;;;;;	M_BRA	FORCE_STEPEND_HAND200		;
;;;;;;;;;;;;FORCE_STEPEND_HAND200EXT


;	==== 停止した場合、次の工程の起動、工程がなくなれば終わり====
;	停止はﾊﾟﾙｽ払出
	MOV.L	#_INT_POS_STEP_FLG,R1		;//ｽﾃｯﾌﾟ
	MOV.W	@R1,R0				;BIT
	TST	#BIT6,R0			;
	TST_BIT_OF POS_ALLSTEPCTL_020		;
	M_BRA	POS_ALLSTEPCTL_900		;位置決め完了

POS_ALLSTEPCTL_020:
	TST	#(BIT1+BIT0),R0		;
	TST_BIT_OF POS_ALLSTEPCTL_100	;BIT0:ﾀｲﾏ制御開始
	M_BRA	POS_ALLSTEPCTL_300	;BIT1:次の回転起動

POS_ALLSTEPCTL_100:


;	----------- 2012-05-17 全モード,(反転)タイマ継続処理CHK---------
	FAR_JSR	#_DURING_TIM_CNTINUE_CHK,R0		;
	TST	R0,R0					;
	TST_BIT_OF POS_ALLSTEPCTL_101			;
	M_BRA	POS_ALLSTEPCTL_230			;

POS_ALLSTEPCTL_101:

	MOV.L	#_CPOS_CTL_MATH,R1			;
	MOV.W	@R1,R0					;
	TST	#(_DMATH_CNTROT+_DMATH_DNDRIV),R0	;回転or往復
	TST_BIT_ON POS_ALLSTEPCTL_120			;YES 


	FAR_JSR	#_POS_CLS_TYP1_POS_CTL1,R0		;ﾌﾙｸﾛｰｽﾞ,ﾌﾙｸﾛｰｽﾞのｵｰﾌﾟﾝ時は中でﾁｪｯｸする
	TST	R0,R0					;
	TST_BIT_OF POS_ALLSTEPCTL_105			;
	M_BRA	POS_ALLSTEPCTL_230			;(BIT2=1)

POS_ALLSTEPCTL_105:
	M_BRA	POS_ALLSTEPCTL_900			;

POS_ALLSTEPCTL_120:
;	======== 2003-07-01 ======
	FAR_JSR	#_BRK_ERR_CHK_START4,R0		;




;	===========================================
;	=== 回転はニアゼロをチェックする	===
;	===========================================
	FAR_JSR	#_OPEN_ROT_NEAR1_ZERO_CHK,R0	;


	FAR_JSR	#_LOD_POS_STS_REG_POR,R1		;
	TST	#BIT2,R0			;停止?
	TST_BIT_ON POS_ALLSTEPCTL_200		;YES 停止中 1:停止 0:払出中

;	===========================================
;	===	払出中				===
;	===========================================

;	===================================================
;	===  "CPUA=CPUB=ﾃｰﾌﾞﾙ時に生かす" 2013-03-07	===
;	===================================================
	FAR_JSR	#_DNMODE_ENDWAIT_TIM_SET,R0	;[[[2013-03-24復活]]]


	MEM1_BIT0_TO_BIT7_ANDCLR MEM=_DNM_DEBUG_STS1,LG=W,BIT=~(BIT4),WKREG=R1	;2012-12-10 DEBUG

;	===== 払出中のBUSYﾁｪｯｸ ======
	FAR_JSR	#_FWD_REV_STSIG_OFF_SPEC,R0	;
;	===== 払出中 ======
;	===== 位置による速度切り替え＋速度連続のｽﾃｯﾌﾟ切替====
	FAR_JSR	#_SPD_STEP_CHG_FWD,R0	;(STEP番号切替/速度切り替え)


;	======== 回転の連続・ﾀｲﾏ=0処理====
	MOV.L	#_STOP_LATCH,R1			;//BIT0:ｽﾄｯﾌﾟ釦
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;
	TST_BIT_ON POS_ALLSTEPCTL_190		;

;	========== 2004-01-26 連続寸動一工程/連続一工程 ======
	MOV.L	#_WFSYS_OPT_CNT_SEL,R1		;SEL=1 連寸一、連続一行程有効
	MOV.W	@R1,R0				;
	CMP/EQ	#1,R0				;
	BF	POS_ALLSTEPCTL_189		;

	MOV.L	#_MODE_SEL,R1			;
	MOV.W	@R1,R0				;
	TST	#_W1CNT,R0			;
	TST_BIT_OF POS_ALLSTEPCTL_189		;
	MOV.W	#(BIT12+BIT11),R1		;
	TST	R1,R0				;
	TST_BIT_OF POS_ALLSTEPCTL_189		;(通常連続)


;	==============20071106======================
	MOV.L	#_CPOS_BANK_USELFUL,R1		;大バグ
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;
	TST_BIT_OF POS_ALLSTEPCTL_189A		;

;;	FAR_JSR	#_CCS_STEP_NEXT_CHK,R0		;
	FAR_JSR	#_BANK_CNT_STEP_NEXT_CHK,R0	;
	M_BRA	POS_ALLSTEPCTL_190		;
;	===========================================


POS_ALLSTEPCTL_189:				;

	MOV.L	#_CPOS_BANK_USELFUL,R1		;
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;
	TST_BIT_OF POS_ALLSTEPCTL_189A		;
	FAR_JSR	#_BANK_CNT_STEP_NEXT_CHK,R0	;(連続の上死点停止なし)
	M_BRA	POS_ALLSTEPCTL_190		;

POS_ALLSTEPCTL_189A:					;
;;;;未使用	FAR_JSR	#_CNT_STEP_NEXT_CHK,R0		;<ここはくせもの>
	NOP						;安一、寸動、上死点停止付連続、一工程
POS_ALLSTEPCTL_190:					;

;	==== 2003-06-13===
	MEM1_BIT0_TO_BIT7_ANDCLR MEM=_POS_CTRL_SQ_STS,LG=W,BIT=~BIT0,WKREG=R1 ;//位置決めｽﾃｰﾀｽ
	FAR_JSR	#_SET_NZ_TIM_DAT,R0	;2003-06-13 ﾆｱｾﾞﾛﾀｲﾏ再設定

	M_BRA	POS_ALLSTEPCTL_900		;

;	===========================
;	===	払出停止	===
;	===	回転時		===
;	===========================
POS_ALLSTEPCTL_200:
	MEM1_BIT0_TO_BIT7_ORSET MEM=_DNM_DEBUG_STS1,LG=W,BIT=BIT1,WKREG=R1 ;2012-12-10 DEBUG

;	------- 2015-11-17 -----------------------
	FAR_JSR	#_API_ACCLW_DRV_STOP,R0


	MOV.L	#_CNT_PLSOUT_STOP_CNT,R1
	MOV.W	@R1,R0
	ADD	#1,R0				;
	MOV.W	R0,@R1				;
	FAR_JSR	#_LSI_REST_PLS_CHK_STOP_CLR,R0	;2004-03-03


	MOV.L	#_NEAR_IN_FLG,R1		;
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_ON POS_ALLSTEPCTL_220		;ﾆｱｾﾞﾛOK


	FAR_JSR	#_CPU_BA_NZR_ON_JG,R0		;ﾆｱｾﾞﾛ代わり
	TST	R0,R0
	TST_BIT_OF POS_ALLSTEPCTL_210		;
	MOV.L	#_NEAR_IN_FLG,R1		;ﾆｱｾﾞﾛ扱い
	MOV.W	@R1,R0				;
	OR	#BIT0,R0			;
	MOV.W	R0,@R1				;
POS_ALLSTEPCTL_210:				;

	FAR_JSR	#_NZ_TIM_CHK1,R0		;2003-06-13 ﾆｱｾﾞﾛﾀｲﾏｶｳﾝﾄﾀﾞｳﾝ


;	-----------2012-03-06ｲﾝﾎﾟｼﾞ異常ﾁｪｯｸ------------------------------
	MOV.L	#_NZ_TIM_OUT_PV2,R1					;
	MOV.W	@R1,R0							;
	TST	R0,R0							;
	TST_BIT_ON POS_ALLSTEPCTL_211					;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_INP_ERR_FLG,LG=W,BIT=BIT0,WKREG=R1 ;
POS_ALLSTEPCTL_211:							;

	M_BRA	POS_ALLSTEPCTL_900		;

POS_ALLSTEPCTL_220:

;	===================================================
;	===  "CPUA=CPUB=ﾃｰﾌﾞﾙ時に生かす" 2013-03-07	===
;	===================================================

;;;;	===========================================
;;;;	===	ふりこの終了遅延ﾀｲﾏ2013-02-08	===
;;;;	===	CPUB_CURVSEL[5]			===
;;;;	===========================================
	FAR_JSR	#_DNMODE_ENDWAIT_TIM_CHK,R0	;[[[2013-03-24復活]]]
	TST	R0,R0				;[[[2013-03-24復活]]]
	TST_BIT_OF POS_ALLSTEPCTL_225		;[[[2013-03-24復活]]]
	M_BRA	POS_ALLSTEPCTL_900		;[[[2013-03-24復活]]]

POS_ALLSTEPCTL_225:

;	=====================================================


	MEM1_BIT0_TO_BIT7_ORSET MEM=_DNM_DEBUG_STS1,LG=W,BIT=BIT2,WKREG=R1 ;2012-12-10 DEBUG

	FAR_JSR	#_CMPAB_NEAR_END_PROC,R0	;ｵｰﾌﾟﾝ時ﾆｱｾﾞﾛの終わり
	TST	R0,R0				;
	TST_BIT_ON POS_ALLSTEPCTL_230		;
	M_BRA	POS_ALLSTEPCTL_900		;

POS_ALLSTEPCTL_230:

;	===============================================
	MEM1_BIT0_TO_BIT7_ORSET MEM=_DNM_DEBUG_STS1,LG=W,BIT=BIT3,WKREG=R1 ;2012-12-10 DEBUG
	MEM1_BIT0_TO_BIT7_ANDCLR MEM=_POS_CTRL_SQ_STS,LG=W,BIT=~BIT0,WKREG=R1 ;//位置決めｽﾃｰﾀｽ

;	=====================
;	===== 状態遷移時=====
;	=====================
;	==========================
;	===== ﾌﾙｸﾛｰｽﾞ信号ｸﾘｱ======
;	==========================
	FAR_JSR	#_FUL_DATA_INIT,R0	;R0,R1 USED
;	===============================================
	MEM1_BIT0_TO_BIT7_ANDCLR MEM=_NEAR_IN_FLG,LG=W,BIT=~BIT0,WKREG=R1 ;//
;	===============================================
	FAR_JSR	#_CMPSTP_NEAR_ZERO_CLR,R0;//ﾌﾗｸﾞｸﾘｱしたい
;	===============================================
	FAR_JSR	#_SET_NZ_TIM_DAT,R0	;2003-06-13 ﾆｱｾﾞﾛﾀｲﾏ再設定
;	=== ﾆｱｾﾞﾛ待ち信号ｸﾘｱ ====
	MEM1_BIT0_TO_BIT7_ANDCLR MEM=_POS_CTRL_SQ_STS,LG=W,BIT=~BIT0,WKREG=R1 ;//位置決めｽﾃｰﾀｽ


	MOV.L	#_INT_POS_CTL_STEP,R2	;//内部制御工程1~11
	MOV.W	@R2,R0			;ﾀｲﾏLOAD
	ADD	#-1,R0			;
	MOV.L	#_CPOS_SDAT1_TIM,R4	;
	SHLL2	R0			;
	MOV.L	@(R0,R4),R1		;

;	----------------------------
	MOV.L	#_MOT_REP_F,R4			;//BIT0(ﾘﾋﾟｰﾄ動作
	MOV.W	@R4,R0				;
	TST	#BIT0,R0			;ﾘﾋﾟｰﾄ動作直後の停止
	TST_BIT_OF POS_ALLSTEPCTL_REP231	;
	XOR	R1,R1				;
POS_ALLSTEPCTL_REP231:				;









	MOV.L	#_MODE_SEL,R4		;
	MOV.W	@R4,R0			;
	TST	#_W1CNT,R0		;
	TST_BIT_ON POS_ALLSTEPCTL_280	;

;	== 連続以外は最終工程は0固定 ==

	MOV.L	#_INT_POS_CTL_STEP,R2	;1~5,6
	MOV.W	@R2,R0			;
	MOV.L	#_CPOS_STEP_MAX,R2	;
	MOV.W	@R2,R4			;
	ADD	#1,R4			;
	CMP/EQ	R0,R4			;R0 =< R4(MAX)
	BF	POS_ALLSTEPCTL_280	;最終工程ではない
	XOR	R1,R1			;最終工程
POS_ALLSTEPCTL_280:			;

	.AIF	_KJYU_CLS EQ	_CMPILE_YES	;YES:反転ﾓｰﾄﾞで荷重でのｸﾛｰｽﾞを行う
;2015-03-15
	MOV.L	#_FULCLS_TIM_SETFLG,R0		;
	MOV.W	@R0,R0				;
	TST	#BIT1,R0			;
	TST_BIT_OF POS_ALLSTEPCTL_285		;
	XOR	R1,R1				;ﾀｲﾏ=0にする
POS_ALLSTEPCTL_285:				;
	.AENDI

;	input R1
	FAR_JSR	#_DURING_TIM_PRESET_CALC,R0	;2014-05-30 ﾀｲﾏ継続
;;;2014-05-30	MOV.L	#_SDAT_WAIT_PVTIM,R4						;
;;;2014-05-30	MOV.L	R1,@R4								;

	MEM1_BIT0_TO_BIT7_ORSET MEM=_INT_POS_STEP_FLG,LG=W,BIT=BIT0,WKREG=R1	;

;	----------- 荷重行程変更ｸﾘｱ-----------------
	.AIF	_KJYU_CLS EQ	_CMPILE_YES	;YES:反転ﾓｰﾄﾞで荷重でのｸﾛｰｽﾞを行う
	FAR_JSR	#_FCLS_KJYU_STEPCHG_CLR,R0	;2015-03-15[R01:2014-03-20]
	.AENDI

;	===================
;	===	CAM1	===
;	===================
	FAR_JSR	#_CAM_1STEP_END_SIG1,R0	;
	M_BRA	POS_ALLSTEPCTL_900	;


;	====<<<<2段目以降の起動処理>>>====
POS_ALLSTEPCTL_300:
	TST	#BIT1,R0		;
	TST_BIT_ON POS_ALLSTEPCTL_400	;

;	==== 各段一旦停止機能====
	MOV.L	#_CB_SEQ_CB_COM340,R1		;340
	MOV.W	@R1,R0				;
	MOV.W	#BIT13,R4			;
	TST	R4,R0				;
	TST_BIT_OF POS_ALLSTEPCTL_310		;
	MEM1_BIT0_F_ORSET MEM=_SQ_CBWK_TOP+_WKSQCB206,LG=W,BIT=(BIT9),WKRG1=R1,WKRG2=R4
	M_BRA	POS_ALLSTEPCTL_900		;

POS_ALLSTEPCTL_310:
	MEM1_BIT0_F_ADCLR MEM=(_SQ_CBWK_TOP+_WKSQCB206),LG=W,BIT=(~BIT9),WKRG1=R1,WKRG2=R4


;	--------反転及び全動作 タイマ計測から再開
	MEM1_BIT0_TO_BIT7_ORSET MEM=_DURING_TIM_FX,LG=W,BIT=BIT0,WKREG=R1	;する

	DN_TIME LG=L,MEM_ADR=_SDAT_WAIT_PVTIM	,WKREG1=R1,WKREG2=R4	;2014-05-30

	MOV.L	#_SDAT_WAIT_PVTIM,R4	;
	MOV.L	@R4,R1			;
	TST	R1,R1			;
	TST_BIT_OF POS_ALLSTEPCTL_320	;
	M_BRA	POS_ALLSTEPCTL_900	;

POS_ALLSTEPCTL_320:
;;;	===================
;;;	===	CAM2	===
;;;	===================
;;;	FAR_JSR	#_CAM_1STEP_END_SIG2,R0	;

	MEM1_BIT0_TO_BIT7_ORSET MEM=_INT_POS_STEP_FLG,LG=W,BIT=BIT1,WKREG=R1 ;TIME UP

;	--------反転及び全モードタイマ時はタイマ処理から再開をクリア[2/]------
	MEM_0CLR_R0_R1	MEM=_DURING_TIM_FX,LG=W		;ﾀｲﾏ処理終了した
	M_BRA	POS_ALLSTEPCTL_900			;


;	======= 次の起動の演算または終了の判断=====
POS_ALLSTEPCTL_400:

;	=== ﾌﾙｸﾛｰｽﾞ・回転共にこれで止める　連続・回転・停止なしのみここ以外
	MOV.L	#_MODE_SEL,R1			;
	MOV.W	@R1,R0				;寸動なら１工程へ、連続なら停止なしなら１工程へ
	TST	#_W1CNT,R0			;
	TST_BIT_OF POS_ALLSTEPCTL_415		;

;	===== 2004-12-20 ===
	MOV.L	#_CPOS_MOD_FLG1,R1		;
	MOV.W	@R1,R0				;
	TST	#BIT2,R0			;
	TST_BIT_ON POS_ALLSTEPCTL_415		;

	MOV.L	#_STOP_LATCH_B,R1		;
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_OF POS_ALLSTEPCTL_415		;
	FAR_JSR	#_STOP_LTH_OUT,R0		;自分を止めるのが目的

POS_ALLSTEPCTL_415:				;

;	===================================
;	===	二重回路対策		===
;	===	工程完了		===
;	===================================
;;;;;;;;;;;;FORCE_STEPEND_HAND200:				;[2015-04-08]

	FAR_JSR	#_CMPAB_STEP_END_PROC,R0	;
	TST	R0,R0				;
	TST_BIT_ON POS_ALLSTEPCTL_420		;
	M_BRA	POS_ALLSTEPCTL_900		;
POS_ALLSTEPCTL_420:				;
	FAR_JSR	#_CMPSTP_STEP_END_CLR,R0	;//位置決め完了としたい

;	===================
;	===	CAM2	===
;	===================
	FAR_JSR	#_CAM_1STEP_END_SIG2,R0		;


;	====== 次の工程演算[繰り返しCHK] ======
	FAR_JSR	#_MOT_REP_STEPCHK,R0		;ﾘﾋﾟｰﾄ開始(通常工程->ﾘﾋﾟｰﾄ戻工程,ﾘﾋﾟｰﾄ戻->ﾘﾋﾟｰﾄ開始工程)

	MOV.L	#_MOT_REP_F,R5			;//BIT1(ﾚﾋﾟｰﾄ演算しろ),BIT2(ﾘﾋﾟｰﾄ戻実行中)
	MOV.W	@R5,R0				;
	TST	#BIT2,R0			;
	TST_BIT_OF POS_ALLSTEPCTL_410		;ﾘﾋﾟｰﾄから通常の開始工程に切り替えろ?
	AND	#(BIT0),R0			;BIT3,BIT2:CLR
	MOV.W	R0,@R5				;
	MOV.L	#_SET1_MOTREP_STGS,R4		;//繰り返し終了行程[この工程は停止工程とする]
	MOV.W	@R4,R1				;
	MOV.L	#_INT_POS_CTL_STEP,R5		;//内部制御工程1~11
	MOV.W	R1,@R5				;
	MOV.L	#_SV_POS_CTL_STEP,R0		;//1msec 制御上の見かけ
	MOV.W	R1,@R0				;
	M_BRA	POS_ALLSTEPCTL_580		;工程番号から位置演算


POS_ALLSTEPCTL_410
	TST	#BIT1,R0			;
	TST_BIT_OF POS_ALLSTEPCTL_430		;
	AND	#(BIT0),R0			;BIT1:CLR BIT3:ふりこ時に使用される
	MOV.W	R0,@R5				;

	FAR_JSR	#_DEBUG_BRK_POINT2,R0		;

	FAR_JSR	#_MOT_REPSTART_CALC,R0		;
	M_BRA	POS_ALLSTEPCTL_590		;位置演算後の処理


POS_ALLSTEPCTL_430:				;
;	====== 次の工程演算 ======
	MOV.L	#_INT_POS_CTL_STEP,R5	;//内部制御工程1~11
	MOV.W	@R5,R0			;
	ADD	#-1,R0			;
	SHLL2	R0			;
	MOV.L	#_CPOS_SDAT1_CNTSTEP,R7	;
	MOV.L	@(R0,R7),R1		;この工程の最後のｽﾃｯﾌﾟ
	MOV.L	#_CPOS_STEP_MAX,R6	;//設定
	MOV.W	@R6,R4			;
	ADD	#1,R4			;
	CMP/HS	R4,R1			;R4=(<)R1:NOW 最終工程?
	BT	POS_ALLSTEPCTL_450	;YES 最終工程だった JUMP
	ADD	#1,R1			;
	MOV.W	R1,@R5			;NEXT ｾｯﾄ

;	=======================================
	MOV.L	#_CAM_CNT_CHG_FLG,R4		;//ｶﾑ:連続Vで1行程目になった際の微妙なﾀｲﾐﾝｸﾞ測定
	XOR	R0,R0				;
	MOV.W	R0,@R4				;
;	=========================================

;	=================================================
	MOV.L	#_SV_POS_CTL_STEP,R0	;//1msec 制御上の見かけ
	MOV.W	R1,@R0			;
;	================================================
;	=== 次の工程への処理===		;
	M_BRA	POS_ALLSTEPCTL_580	;

;====通常の安一等の最終工程,連続停止の最終行程もここ 2004-03-03
POS_ALLSTEPCTL_450:
	FAR_JSR	#_MOTION_CYCLE_END,R0		;

	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
	FAR_JSR	#_API_IVW_CYC_START,R0			;2010-09-21電力測定ﾀｲﾐﾝｸﾞ

	.AENDI

	FAR_JSR	#_MOTION_CYCLE_ED2,R0		;連続のVﾓｰﾄﾞがここを通過している
	FAR_JSR	#_LOT_SIG_FLG_CLR,R0		;通常の連続
	FAR_JSR	#_DBG_END_CNT1,R0


;	== 非常停止解除(ｻｲｸﾙ運転),1CYCLEND ==
	MOV.L	#_MODE_SEL,R1			;
	MOV.W	@R1,R0				;寸動なら１工程へ、連続なら停止なしなら１工程へ
	TST	#(_W1CNT+_W1INC),R0		;
	TST_BIT_OF POS_ALLSTEPCTL_600X		;終了
	
	TST	#(_W1INC),R0			;
	TST_BIT_ON POS_ALLSTEPCTL_530		;開始

;	=== 連続 ===
	MOV.L	#_STOP_LATCH,R1			;//BIT0:ｽﾄｯﾌﾟ釦
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;
	TST_BIT_ON POS_ALLSTEPCTL_600X		;終了
	M_BRA	POS_ALLSTEPCTL_550		;(連続のＶﾓｰﾄﾞでの最終工程から最初の行程) 停止付の処理

POS_ALLSTEPCTL_600X		;終了
	M_BRA	POS_ALLSTEPCTL_600		;終了


POS_ALLSTEPCTL_530:				;
	MOV.L	#_CB_SEQ_SW_SEL028,R1		;//SEQ 28
	MOV.W	@R1,R1				;.3
	MOV.W	#BIT3,R2			;
	TST	R2,R1
	TST_BIT_OF POS_ALLSTEPCTL_550		;
	M_BRA	POS_ALLSTEPCTL_600		;終了 寸動一工程

;	=== 継続運転<> ==
POS_ALLSTEPCTL_550:				;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_DNM_DEBUG_STS1,LG=W,BIT=BIT4,WKREG=R1 ;2012-12-10 DEBUG
	MEM1_BIT0_TO_BIT7_ANDCLR MEM=_DNM_DEBUG_STS1,LG=W,BIT=~(BIT3+BIT2+BIT1+BIT0),WKREG=R1	;2012-12-10 DEBUG

;	----- [2009-10-07下振子]-----
	FAR_JSR	#_DNM_CYCLE_START,R0		;連続の次のｻｲｸﾙ開始はここ

	XOR	R0,R0				;
;	=======================================
	MOV.L	#_CAM_CNT_CHG_FLG,R1		;//ｶﾑ:連続Vで1行程目になった際の微妙なﾀｲﾐﾝｸﾞ測定
	MOV.W	R0,@R1				;
;	=========================================
	MOV.L	#_INT_POS_STEP_FLG,R1		;//ｽﾃｯﾌﾟ,段取り共通
	MOV.W	R0,@R1				;
	MOV.L	#_LINK_OBJROT_NUM_ZR,R1		;//NOW ROTATION 番号
	MOV.L	@R1,R2				;+0
;;;;	FAR_JSR	#_NEXT_CYCL_START1,R0		;回転なら+1
	FAR_JSR	#_BANK_CHK_NEXT_CYCL_STR1,R0	;2004-12-20::::連続/寸動の上死点停止付処理

	MOV.L	#_SV_POS_CTL_STEP,R1		;//1msec 制御上の見かけ
	MOV.W	@R1,R4				;
	MOV.L	#_INT_POS_CTL_STEP,R2		;//内部制御工程1~11
	MOV.W	R4,@R2				;


	FAR_JSR	#_MOTION_CYCLE_START,R0		;1回転



;	==== 通常の行程切替,連続の停止付１回転====
;	(((((連続Vﾓｰﾄﾞではここは通らない))))))))
POS_ALLSTEPCTL_580:				;<====
;	====== 2007-09-15未出荷　(SIT3:2007-09-15)(COP2:2007-07-07) =============
	FAR_JSR	#_POS_LSI_START_INITAL,R0

	FAR_JSR	#_X_SET_PV_ABS_TO_OBJ,R0	;2010-10-05 実測から設定に取り込まない

	FAR_JSR	#_OVER_RID_UPDN_LAT_DTMK,R0	;20060919:

	MOV.L	#_CPOS_CTL_MATH,R1		;
	MOV.W	@R1,R0				;
	TST	#_DMATH_CNTROT,R0		;2002-09-01 回転?
	TST_BIT_OF POS_ALLSTEPCTL_585		;
;	====== 回転時はこれ==========
	MOV.L	#_CPOS_BANK_USELFUL,R1		;2004-12-20
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;
	TST_BIT_ON POS_ALLSTEPCTL_583		;<====
	FAR_JSR	#_POS_1STEP_DATA_MAK2,R0	;_LNGTH,SHIN,SPEED<設定から求める>
	M_BRA	POS_ALLSTEPCTL_590		;[]

POS_ALLSTEPCTL_583				;
;	=== 連続の上死点ﾀｲﾏなし===
	FAR_JSR	#_POS_CNT_BANK_DTMAK3,R0	;ﾀｲﾏ停止後の起動
	FAR_JSR	#_BANK_CNT_STOP_CHK_TYP1,R0	;
	M_BRA	POS_ALLSTEPCTL_590		;

POS_ALLSTEPCTL_585:				;<<<<<<<<<<<<<<<<<<

	FAR_JSR	#_POS_1STEP_DATA_MAK_SEL,R0	;2011-11-18 _POS_1STEP_DATA_MAK1CL/POS_1STEP_DATA_MAK2の切り替え

						;基本的には一致した状態(本当は最終工程だけ)
;;;;2010-10-05	FAR_JSR	#_POS_1STEP_DATA_MAK1,R0	;_LNGTH,SHIN,SPEED<ｲﾝｸﾘﾒﾝﾀﾙﾊﾟﾙｽから求める>
;;;;2011-02-18	FAR_JSR	#_POS_1STEP_DATA_MAK2,R0	;目標位置タイプ　2010-10-05

POS_ALLSTEPCTL_590:				;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	==== 2003-07-14 回転の停止時間変更 ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 2014-08-30
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	MOV.L	#_SV_CHG_FLG2,R1		;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	MOV.L	@R1,R0				;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	TST	R0,R0				;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	TST_BIT_ON POS_ALLSTEPCTL_900		;次の起動をかけない

;	===(次ｽﾃｯﾌﾟ起動)===
	FAR_JSR	#_ERR_INFO_DT_IN2,R0		;2004-01-27(data-smp only)

	FAR_JSR	#_POS_LENGTH_ADD_DATA,R0	;
	FAR_JSR	#_ERR_INFO_DT_IN3,R0		;2004-01-28ADD,TOTAL(data-smp only)


;;;;;;	FAR_JSR	#_POS_PLS_OUTPUT_DATA,R0	;停止時からの起動
;;;;;(連続のＶﾓｰﾄﾞもここを通過してきているので安全一行程だけ)	
	FAR_JSR	#_POS_PLSOUT_SET_RETRY,R0	;(停止時からの起動の場合のみ有効・安一のみ)

;	== 2004-03 ===
	FAR_JSR	#_ERR_INFO_DT_CHK2,R0		;"SGL"
	MOV.W	#D'2,R0			;
	MOV.L	#_ERR_INFO_DLY_TIM,R1		;
	MOV.W	R0,@R1				;

	FAR_JSR	#_ERR_INFO_DT_IN4,R0		;"SGL"
	FAR_JSR	#_FWD_REV_START,R1		;起動

;	-------- 2010-09-27 ふりこ情報--------
	FAR_JSR	#_DNM_START_ACC_CALC,R0

	FAR_JSR	#_BRK_ERR_WORK_CLR1,R0		;_BRK_ERR_CHK_START2	;2003-07-01

	XOR	R0,R0				;
	MOV.L	#_INT_POS_STEP_FLG,R1		;//ｽﾃｯﾌﾟ,段取り共通
	MOV.W	R0,@R1				;Q

;	==== ﾆｱｾﾞﾛ,ﾊﾝﾄﾞｼｪｲｸ終了,ｸﾛｰｽﾞﾌﾗｸﾞCLR ===
	FAR_JSR	#_POS_CMP_1STEP_START_INI,R0

;	---------------- 起動 2011-09-01 -------------------
	FAR_JSR	#_UP_ACCERR_START_INI,R0


;	------- 2015-11-17 -----------------------
	FAR_JSR	#_API_ACCLW_DRV_START1,R0	;
	M_BRA	POS_ALLSTEPCTL_900		;

POS_ALLSTEPCTL_600:
	FAR_JSR	#_MOTION_CYCLE_END,R0			;2回目通る
	FAR_JSR	#_MOTION_CYCLE_ED2,R0			;2003-07-09
	FAR_JSR	#_LOT_SIG_FLG_CLR,R0			;通常の連続
	FAR_JSR	#_DBG_END_CNT2,R0

	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
	FAR_JSR	#_API_IVW_CYC_END,R0			;2010-09-21電力測定ﾀｲﾐﾝｸﾞ
	.AENDI

	MEM1_BIT0_TO_BIT7_ORSET MEM=_INT_POS_STEP_FLG,LG=W,BIT=BIT6,WKREG=R1 ;

;	------- 2015-11-17 -----------------------
	FAR_JSR	#_API_ACCLW_DRV_STOP,R0

;	======ｻｲｸﾙ停止状態ON==========================
	MOV.L	#_SQ_CBWK_TOP+_WKSQCB206,R1		;
	MOV.W	@R1,R0					;
	MOV.W	#BIT7,R4				;
	OR	R4,R0					;以下 BIT0,BIT1,BIT8,BIT9を作成する
	MOV.W	R0,@R1					;
;	===============================================
POS_ALLSTEPCTL_900:





;	------- 2012-12-10 DEBUG-----------
;;;2014-09-14	MOV.L	#_DNM_DEBUG_STS1,R1
;;;2014-09-14	MOV.W	@R1,R2
;;;2014-09-14	MOV.L	#_SQ_CBWK_TOP+_WKSQCB246,R1	;
;;;2014-09-14	MOV.W	R2,@R1				;ﾃﾞﾊﾞｯｸ専用


	SUB_END
	M_RTS






_DEBUG_BRK_POINT1
	SUB_START
;	-------debug break-point set----------
	PUSH_REG1 R0
	PUSH_REG1 R1
	MOV.L	#_di2_cb_ctl2,R1	;
	MOV.W	@R1,R0			;
	TST	#BIT7,R0		;連続ｾｯﾄｱｯﾌﾟ釦
	TST_BIT_OF DEBUG_BRK_PNT1_100

	NOP
	NOP
	NOP
	NOP
	NOP


DEBUG_BRK_PNT1_100

	
	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS

_DEBUG_BRK_POINT2
	SUB_START
;	-------debug break-point set----------
	PUSH_REG1 R0
	PUSH_REG1 R1
	MOV.L	#_di2_cb_ctl2,R1	;
	MOV.W	@R1,R0			;
	TST	#BIT7,R0		;連続ｾｯﾄｱｯﾌﾟ釦
	TST_BIT_OF DEBUG_BRK_PNT2_100

	NOP
	NOP
	NOP
	NOP
	NOP


DEBUG_BRK_PNT2_100

	
	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS
	
_DEBUG_BRK_POINT3
	SUB_START
;	-------debug break-point set----------
	PUSH_REG1 R0
	PUSH_REG1 R1
	MOV.L	#_di2_cb_ctl2,R1	;
	MOV.W	@R1,R0			;
	TST	#BIT7,R0		;連続ｾｯﾄｱｯﾌﾟ釦
	TST_BIT_OF DEBUG_BRK_PNT3_100

	NOP
	NOP
	NOP
	NOP
	NOP


DEBUG_BRK_PNT3_100

	
	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS
	

;	*******************************************************************
;	***								***
;	***	反転時のフルクローズ後の工程（戻り）は目標位置ではだめ	***
;	***								***
;	*******************************************************************
;	2011-02-18 (2010-10-05 はMCのよるソフト)
;
	.ALIGN	4				;
_POS_1STEP_DATA_MAK_SEL:
	SUB_START

	MOV.L	#_CPOS_CTL_MATH,R1			;
	MOV.W	@R1,R0					;
	TST	#(_DMATH_CNTROT+_DMATH_DNDRIV),R0	;回転or往復
	TST_BIT_ON POS_1STEP_DATA_MKSL100		;YES

;;;	FAR_JSR	#_POS_1STEP_DATA_MAK1,R0		;目標位置に対して少しパルスを減らす 2011-02-19
	FAR_JSR	#_POS_1STEP_DATA_MAK1CL,R0		;目標位置に対して少しパルスを減らす 2011-02-19
	M_BRA	POS_1STEP_DATA_MKSL200			;


POS_1STEP_DATA_MKSL100:
	FAR_JSR	#_POS_1STEP_DATA_MAK2,R0		;目標位置タイプ　2010-10-05
POS_1STEP_DATA_MKSL200:
							;基本的には一致した状態(本当は最終工程だけ)
;;;;2010-10-05	FAR_JSR	#_POS_1STEP_DATA_MAK1,R0	;_LNGTH,SHIN,SPEED<ｲﾝｸﾘﾒﾝﾀﾙﾊﾟﾙｽから求める>
;;;;2011-02-18	FAR_JSR	#_POS_1STEP_DATA_MAK2,R0	;目標位置タイプ　2010-10-05


	SUB_END
	M_RTS
	




;	*******************************************
;	***					***
;	***					***
;	***					***
;	***	JUMP処理短縮のｻﾌﾞﾙｰﾁﾝ化		***
;	***	2009-10-07			***
;	***					***
;	***					***
;	*******************************************
_CNT_NEAR_TIM_CHK:
	SUB_START
	SUB_END
	M_RTS

_POS_ALLSTEP_STOP_SPD_CHK:
	SUB_START
	SUB_END
	M_RTS

_NEAR_ZERO_IN_CHK:
	SUB_START
	SUB_END
	M_RTS

_PLSOUT_STEP_END_TIMSET
	SUB_START
	SUB_END
	M_RTS

_WAIT_TIM_CNT:
	SUB_START
	SUB_END
	M_RTS


;	***********************************
;	***				***
;	***	次のｻｲｸﾙ演算		***
;	***				***
;	***********************************

;	***************************
;	***	Input R2 回転	***
;	***************************
;	==かならず正転方向から運転を始める
;	==(今の目標位置＝現在位置）は待機点と正転方向の第一目標位置の間にあるか？(正転動作から始める)０を
;	(1)待機点が第一目標位置より小さい場合（普通の設定 目標位置は１回転足されていない）０をはさまない
;	   @待機点と目標位置の範囲内なら足さない
;	   A　@以外で１８０度(上昇ホールドだけど)〜０度（３６００）の範囲なら＋１する
;	   Bそれ以外は戻すからそのまま
;	(2)待機点が第一目標位置より大きい場合（普通の設定 目標位置は１回転足されている）：０をはさむ
;	   @待機点〜０の間はそのまま
;	   A０を含む ０〜第一目標位置の間は−１する
;          Bそのままにしておく

;	パルスで考える
;
;	0ﾊﾟﾙｽから待機点ﾊﾟﾙｽ間はそのまま
;	待機ﾊﾟﾙｽ~SV間
;
;	第一目標位置が360度を越えない場合(またがない場合)
;	第一目標位置が360度を越える場合(またぐ場合)
;
;
;	0_______ORG_____SV________359.9
;	  PV1       PV2     PV3       
;	  *PV1:そのままの回転 PV2:そのまま　PV3 回転+1
;
;	0_______ORG_______________360.0_______SV______719.9
; 	   PV2          PV1              PV3-2   PV3-1
;	   PV+360.0
;         PV1:そのまま (PV2はない)
;	  PV3-1:そのまま
;	  PV3-2: "-1"
;	"Input R2"
	.ALIGN	4				;
_NEXT_CYCL_START2:				;[正方向から開始する運転の１回目の起動]
	SUB_START				;

	FAR_JSR	#_NOW_INC_DIG_MAK,R0			;
	MOV.L	#_LINK_NOWROT_NUM_ZR,R4			;//回転数
	MOV.L	@R4,R2					;

	MOV.L	#_LINK_NOWROT_OFSPLS_P,R4		;"(目標)"
	MOV.L	@R4,R9					;
	MOV.L	#_CPOS_UPAREA_PLS,R1			;//4;待機点
	MOV.L	@R1,R8					;
	MOV.L	#_LINK_1ROT_PLS,R1			;待機点より小さかったら+１回転
	MOV.L	@R1,R7					;反転時もこの論理でＯＫ

;;;;2014-09-19 振子の逆待機点からの開始
;;;;2014-09-19 	MOV.L	#_SETX_POS_SDAT1_OFSPOS,R10		;
	MOV.L	#_CPOS_SDAT1_OFSPOS,R10		;
	MOV.L	@R10,R3					;1ｽﾃｯﾌﾟ目

;	------INC_RESET_USE_F;//STEPを参照して　2014-09-26----------
	MOV.L	#_INC_RESET_USE_F,R1		;
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_ON POS_START_ROT_CAL_900	;
;	----------------------------------------------------------


;	----- 2014-09-19　ふりこ反対側待機点からの初起動-----------
	MOV.L	#_CPOS_CTL_MATH,R1			;
	MOV.W	@R1,R0					;
	TST	#(_DMATH_DNDRIV),R0			;往復
	TST_BIT_OF POS_START_ROT_CAL_100		;

	MOV.L	#_DNM_DIR_NOW_FLG,R1			;//このフラグでいいのかな？
	MOV.W	@R1,R0					;
	TST	R0,R0					;
	TST_BIT_OF POS_START_ROT_CAL_100		;ふりこの通常側からの起動

;-------いいのかな?
	CMP/GE	R3,R8					;目標=<待機点
	BT	POS_START_ROT_CAL_900			;逆転から始まる
	M_BRA	POS_START_ROT_CAL_999			;-1回転



;---------------- 今までの回転、反転、ふりこ右側待機・・正転から始まる-----------
POS_START_ROT_CAL_100:
	CMP/GE	R7,R3					;1REV =< SV
	BT	POS_START_ROT_CAL_200			;
;	======= 0度をはさまない ====
	CMP/GT	R3,R9					;
	BT	POS_START_ROT_CAL_950			;待機(R8)<SV(R3)<NOW
	M_BRA	POS_START_ROT_CAL_900			;

;	====== ０度を挟む===
POS_START_ROT_CAL_200:
	CMP/GT	R9,R8					;待機点以下?
	BF	POS_START_ROT_CAL_900			;NO! 待機点~360度
	MOV	R9,R5
	ADD	R7,R5					;1REV+NOW
	CMP/GT	R3,R5					;SV < NOW
	BT	POS_START_ROT_CAL_900			;YES
	M_BRA	POS_START_ROT_CAL_999			;



;	===== そのまま =====
POS_START_ROT_CAL_900
	MOV.L	#_LINK_NOWROT_NUM_ZR,R4			;//回転数
	MOV.L	@R4,R2					;
	M_BRA	NEXT_CYCL_STR1_050			;

;	===== +1 =====
POS_START_ROT_CAL_950
	MOV.L	#_LINK_NOWROT_NUM_ZR,R4			;//回転数
	MOV.L	@R4,R2					;
	ADD	#1,R2					;
	M_BRA	NEXT_CYCL_STR1_050			;

;	===== -1 =====
POS_START_ROT_CAL_999
	MOV.L	#_LINK_NOWROT_NUM_ZR,R4			;//回転数
	MOV.L	@R4,R2					;
	ADD	#-1,R2					;
	M_BRA	NEXT_CYCL_STR1_050			;

	.ALIGN	4				;
_NEXT_CYCL_START1:
	SUB_START
	MOV.L	#_CPOS_CTL_MATH,R1		;
	MOV.W	@R1,R0				;
	TST	#_DMATH_CNTROT,R0		;回転?
	TST_BIT_OF NEXT_CYCL_STR1_050
	ADD	#1,R2				;回転数+1<反転>
NEXT_CYCL_STR1_050:

;	=== 2004-12-20====
	MOV.L	#_BANK1_CALC_ROT_NUM_ZR,R4
	MOV.L	R2,@R4

	MOV.W	#1,R4
	MOV.L	#_SV_POS_CTL_STEP,R1		;
	MOV.W	R4,@R1				;(+1だけでいいのか/つくり直す必要があるのか)
	PUSH_REG1 R2
	FAR_JSR	#_CPOS_ROT_NUM_SET,R1		;Input R2 回転
	POP_REG1 R2
	FAR_JSR	#_CPOS_ABS_POS_SET,R1		;Input R2 回転

;	=====2003-07-09 速度============
	FAR_JSR	#_CPOS_SPD_DTMOV,R0		;
;	===== 2003-07-14 TIME ======
	FAR_JSR	#_CPOS_TIM_DTMOV,R0		;


;	--------2012-05-15 反転、全モードのタイマ時はタイマ処理から再開をクリア[3/]　次ｻｲｸﾙ開始----
;	基本的にはなくてすむはずかな?
	MEM_0CLR_R0_R1	MEM=_DURING_TIM_FX,LG=W		;ﾀｲﾏ処理終了した


;	--------- 2014-08-30 ﾎｰﾙﾄﾞ位置-----------
	FAR_JSR	#_HLDCAM_ABS_POS_SET,R1		;



	SUB_END
	M_RTS



















;	***********************************************************
;	***							***
;	***	連続速度中の速度と連続内のｽﾃｯﾌﾟ切り替え		***
;	***							***
;	***********************************************************
;	連続だ。自分の切り替え位置を超えたら＋１する。もし、ＭＡＸステップを超えたら１にする
;
;
	.ALIGN	4				;
_SPD_STEP_CHG_FWD:
	SUB_START
	MOV.L	#_INT_POS_CTL_STEP,R11					;//内部制御工程1~11
	MOV.W	@R11,R9							;ﾀｲﾏLOAD
	MOV	R9,R7							;
	ADD	#-1,R7							;
	SHLL2	R7							;
	MOV	R7,R2
	SHLL	R2
	MOV.L	#_CPOS_SDAT1_CHGAPOS,R0					;
	ADD	R2,R0
	MOV.L	@R0+,R1							;位置
	MOV.L	@R0,R2							;

	MOV.L	#_LINK_RL_OBJ_ABSPLS,R4					;
	MOV.L	@R4+,R5							;
	MOV.L	@R4,R6							;R5,R6 実測位置-->目標位置

	MOV.L	#_CPOS_SDAT1_INF1,R0		;[12];		//SETX-->起動時COPY
	MOV.L	@(R0,R7),R0			;BIT0=1連続
	TST	#BIT0,R0			;
	TST_BIT_OF SPD_STEP_CHGFWD_EXT		;連続? NO EXIT
	TST	#BIT1,R0			;
	TST_BIT_ON SPD_STEP_CHGFWD_100		;逆転方向 THEN JUMP
;	===== 正転方向 =======
	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;(ｲｺｰﾙでは切り替えない)
	CMP/PZ	R1				;
	BF	SPD_STEP_CHGFWD_200		;"-":超えた

;	====== 2013-04-14 反転手前処理[反転手前で止めるため、その区間に停止がある場合の処理]======
	MOV.L	#_CPOS_CTL_MATH,R1			;
	MOV.W	@R1,R0					;
	TST	#(_DMATH_CNTROT+_DMATH_DNDRIV),R0	;回転or往復
	TST_BIT_ON SPD_STEP_CHGFWD_090			;

	FAR_JSR	#_REV_BEFORE_CHGKOUTEICHK,R0		;反転
	TST	R0,R0					;
	TST_BIT_OF SPD_STEP_CHGFWD_090			;
	MOV	R2,R9					;行程
	M_BRA	SPD_STEP_CHGFWD_202			;2013-04-14追加

SPD_STEP_CHGFWD_090:
	M_BRA	SPD_STEP_CHGFWD_EXT		;SV-PV >=0 EXIT (SV >= PV)


SPD_STEP_CHGFWD_100:
;	===== 逆転方向 =======
	SUB8B DT_REGH=R1,DT_REGL=R2,DT_ANS_REGH=R5,DT_ANS_REGL=R6	;(ｲｺｰﾙでは切り替えない)
	CMP/PZ	R5				;
	BT	SPD_STEP_CHGFWD_EXT		;PV-SV >=0 EXIT (PV >= SV)
SPD_STEP_CHGFWD_200:
	ADD	#1,R9				;NEXT STEP SET

SPD_STEP_CHGFWD_202:				;2013-04-14追加
	MOV.L	#_CPOS_STEP_MAX,R1		;//設定
	MOV.W	@R1,R2				;
	ADD	#1,R2				;
	CMP/HS	R9,R2				;STEP+1=<MAX
	BT	SPD_STEP_CHGFWD_250		;

;	=== 何の意味のチェックだろう？最大工程＋１＜管理ステップの意味？
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POSLSI_CHK_STS,LG=W,BIT=BIT3,WKREG=R3	;
	M_BRA	SPD_STEP_CHGFWD_EXT						;

SPD_STEP_CHGFWD_250:				;
	MOV.W	R9,@R11				;ﾀｲﾏLOAD
;	==========================================
;	=================================================
	MOV.L	#_SV_POS_CTL_STEP,R0	;//1msec 制御上の見かけ
	MOV.W	R9,@R0			;
;	================================================
	ADD	#-1,R9				;
	SHLL2	R9				;
	MOV.L	#_CPOS_SDAT1_SPD,R0		;
	MOV.L	@(R0,R9),R2			;
	MOV.L	#_LINK_SV_OBJ_SPDPLS,R1		;//目標速度
	MOV.L	R2,@R1				;
	FAR_JSR	#_POS_LSI_TOP_SPEED_SETX,R1	;


;	=======================================
	MOV.L	#_CAM_CNT_CHG_FLG,R1		;//ｶﾑ:連続Vで1行程目になった際の微妙なﾀｲﾐﾝｸﾞ測定
	XOR	R0,R0				;
	MOV.W	R0,@R1				;
;	=========================================
	FAR_JSR	#_CHG_STEP_INFO_MAKE_STEP_END,R0
	FAR_JSR	#_CHG_STEP_INFO_MAKE_STEP_DAT,R0

	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
	.AELSE
	FAR_JSR	#_CPUB_HENSA_FLG_CLR,R0		;
	.AENDI


SPD_STEP_CHGFWD_EXT:
	SUB_END
	M_RTS




;	=== 2004-01-26 連続寸動一工程　===
;	== _CCS_STEP_NEXT_CHK ===
;;;;;;;;;;;;;;不要ですね20060930	.INCLUDE	"ssa_ccss.inc"		; //


;	*******************************************
;	***					***
;	***		段取/待機点復帰		***
;	***					***
;	*******************************************
_EQ_STOP_START_WAIT_ORG		.EQU	D'500	;100mec(3000sec)
_EQ_STOP_START_WAIT_DND		.EQU	D'100	;
;
;	============== 
	.ALIGN	4				;
_DND_ALL_STEP_CTRL:
	SUB_START
	MOV.L	#_MODE_SEL,R1			;
	MOV.W	@R1,R0				;
	TST	#_W1DUP,R0		;
	TST_BIT_ON DND_ALLSTEPCTL_020	;原点復帰

;	------ 2006-07-28 -----
	MOV.L	#_TEP_MODE_DRV,R1		;//起動時に判定
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_OF DND_ALLSTEPCTL_005		;
	FAR_JSR	#_DND_TEP_STEP_CTRL,R0		;
	M_BRA	DND_ALLSTEPCTL_900		;

DND_ALLSTEPCTL_005:

	MOV.L	#_SETX_POS_CTL_MATH,R1		;
	MOV.W	@R1,R0				;
	TST	#_DMATH_REVRSE,R0		;DRIVE MATH 反転
	TST_BIT_OF DND_ALLSTEPCTL_010		;

;	==== 反転段取寸動========
	FAR_JSR	#_DND_NEG_STEP_CTRL,R0		;
	M_BRA	DND_ALLSTEPCTL_900

DND_ALLSTEPCTL_010:
	FAR_JSR	#_DND_ROT_STEP_CTRL,R0		;[]
	M_BRA	DND_ALLSTEPCTL_900

;	================================
;	======== 待機点復帰 ============
;	================================
DND_ALLSTEPCTL_020:
	MOV.L	#_INT_DND_STEP_FLG,R1		;//ｽﾃｯﾌﾟ
	MOV.W	@R1,R0				;BIT
	TST	#BIT6,R0			;
	TST_BIT_OF DND_ALLSTEPCTL_050		;
	M_BRA	DND_ALLSTEPCTL_900		;位置決め完了

DND_ALLSTEPCTL_050:
;	===== 2004-05-23 =======
	FAR_JSR	#_ORGIN_OBJ_POS_CTRL_ST2,R0	;.BIT1
;	========================


	MOV.L	#_INT_DND_CTL_STEP,R1		;
	MOV.W	@R1,R0				;
	TST	#BIT1,R0
	TST_BIT_ON DND_ALLSTEPCTL_060		;第３工程中　EXIT
	TST	#BIT0,R0			;
	TST_BIT_OF DND_ALLSTEPCTL_060		;第２工程前
	FAR_JSR	#_ORGIN_MODE_SMP,R0		;SMPLING
DND_ALLSTEPCTL_060:				;

	MOV.L	#_INT_DND_STEP_FLG,R1		;//ｽﾃｯﾌﾟ
	MOV.W	@R1,R0				;BIT
	TST	#(BIT1+BIT0),R0			;
	TST_BIT_OF DND_ALLSTEPCTL_100		;BIT0:ﾀｲﾏ制御開始
	M_BRA	DND_ALLSTEPCTL_300		;BIT1:次の回転起動

DND_ALLSTEPCTL_100:
	FAR_JSR	#_LOD_POS_STS_REG_POR,R1		;
	TST	#BIT2,R0			;停止?
	TST_BIT_ON DND_ALLSTEPCTL_200		;YES 停止中 1:停止 0:払出中
	FAR_JSR	#_FWD_REV_STSIG_OFF_SPEC,R0	;
	M_BRA	DND_ALLSTEPCTL_900		;


;	====== 停止 =====
	.IMPORT	_PAR_START_WAIT_DND			;段取時切替WAIT時間
DND_ALLSTEPCTL_200:
	MOV.W	#_EQ_STOP_START_WAIT_ORG,R1		;段取時切替WAIT時間
	MOV.L	#_SDAT_WAIT_PVTIM,R4	;
	MOV.L	R1,@R4			;

	MEM1_BIT0_TO_BIT7_ORSET MEM=_INT_DND_STEP_FLG,LG=W,BIT=BIT0,WKREG=R1
	M_BRA	DND_ALLSTEPCTL_900	;

DND_ALLSTEPCTL_300:
	TST	#BIT1,R0		;
	TST_BIT_ON DND_ALLSTEPCTL_400	;

	DN_TIME LG=L,MEM_ADR=_SDAT_WAIT_PVTIM	,WKREG1=R1,WKREG2=R4	;2014-05-30
	MOV.L	#_SDAT_WAIT_PVTIM,R4	;
	MOV.L	@R4,R1			;
	TST	R1,R1			;
	TST_BIT_ON DND_ALLSTEPCTL_320	;DND_ALLSTEPCTL_900	;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_INT_DND_STEP_FLG,LG=W,BIT=BIT1,WKREG=R1 ;TIME UP
DND_ALLSTEPCTL_320:
	M_BRA	DND_ALLSTEPCTL_900	;


;	======= 次の起動の演算または終了の判断=====
DND_ALLSTEPCTL_400:
	MOV.L	#_INT_DND_CTL_STEP,R5	;
	MOV.W	@R5,R0			;
	TST	#BIT1,R0		;BIT0=1 FIRST END BIT1=1 SECOND END 
	TST_BIT_OF DND_ALLSTEPCTL_420	;
	M_BRA	DND_ALLSTEPCTL_600	;YES 最終工程だった JUMP
DND_ALLSTEPCTL_420:


	TST	#BIT0,R0			;
	TST_BIT_OF DND_ALLSTEPCTL_425		;
	M_BRA	DND_ALLSTEPCTL_500		;
DND_ALLSTEPCTL_425:

;	===========================
;	===	2003-07-09 	===
;	===========================
;	BIT0=0のままでn往復動作を行う
	MOV.L	#_ORG_DRV_CNT_PV,R1		;//0:1回 0なら最後のｽﾃｯﾌﾟにいく
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_OF DND_ALLSTEPCTL_450		;(今までのｿﾌﾄを流す)
;
;	== _ORG_RDY_CTL_FLG BIT0 を使用する ===
	MOV.L	#_ORG_RDY_CTL_FLG,R5		;[2工程/3工程の切り替えﾌﾗｸﾞ]
	MOV.W	@R5,R0				;
	TST	#BIT0,R0			;
	TST_BIT_ON DND_ORGIN_STEP_050		;
	OR	#BIT0,R0			;
	MOV.W	R0,@R5				;

;	===== 第２工程開始(補正なし "+") ======
;	======== 20060919 ======================
;	CPUBは自分の払いだした量だけ動作しない。そのため位置がづれるので、停止後はからなず必要
	FAR_JSR	#_X_SET_PV_ABS_TO_OBJ,R0
;	=======================================
	FAR_JSR	#_LINK_UPPLS_A_OBJMAK2,R0	;
	FAR_JSR	#_DNDUPS_CLEEP_SPD_SET,R0	;ANS R2
	FAR_JSR	#_POS_LSI_TOP_SPEED_SET,R1	;INPUT R2
;;;;	FAR_JSR	#_DNDUPS_SPD_SET,R0		;
	MOV.L	#_LINK_SV_OBJ_ABSPLS,R5		;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	@R5,R1				;
	MOV.L	@(4,R5),R2			;
	FAR_JSR	#_LENGH_ADD_CALC,R0		;
	FAR_JSR	#_POS_LENGTH_ADD_DATA,R0	;
	FAR_JSR	#_POS_PLS_OUTPUT_DATA,R0	;位置決めLSIｱｸｾｽ(毎ｽｷｬﾝ)
	FAR_JSR	#_FWD_REV_START,R1		;起動
	M_BRA	DND_ORGIN_STEP_100		;

DND_ORGIN_STEP_050:
	AND	#LOW ~BIT0,R0			;
	MOV.W	R0,@R5				;BIT0 CLR
;	===== 第3工程開始(補正なし "-") ======
;	======== 20060919 ======================
;	CPUBは自分の払いだした量だけ動作しない。そのため位置がづれるので、停止後はからなず必要
	FAR_JSR	#_X_SET_PV_ABS_TO_OBJ,R0
;	=======================================
	FAR_JSR	#_LINK_UPPLS_A_OBJMAK1,R0	;
	FAR_JSR	#_DNDUPS_CLEEP_SPD_SET,R0	;(最後だけゆっくり動けばいいかも)
	FAR_JSR	#_POS_LSI_TOP_SPEED_SET,R1	;INPUT R2

;;;;	FAR_JSR	#_DNDUPS_SPD_SET,R0		;
	MOV.L	#_LINK_SV_OBJ_ABSPLS,R5		;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	@R5,R1				;
	MOV.L	@(4,R5),R2			;
	FAR_JSR	#_LENGH_ADD_CALC,R0		;
	FAR_JSR	#_POS_LENGTH_ADD_DATA,R0	;
	FAR_JSR	#_POS_PLS_OUTPUT_DATA,R0	;位置決めLSIｱｸｾｽ(毎ｽｷｬﾝ)
	FAR_JSR	#_FWD_REV_START,R1		;起動

	MOV.L	#_ORG_DRV_CNT_PV,R1		;//0:1回 0なら最後のｽﾃｯﾌﾟにいく
	MOV.W	@R1,R0				;
	ADD	#-1,R0				;
	MOV.W	R0,@R1				;
DND_ORGIN_STEP_100:
	XOR	R0,R0				;
	MOV.L	#_INT_DND_STEP_FLG,R1		;//ｽﾃｯﾌﾟ,段取り共通
	MOV.W	R0,@R1				;Q

	M_BRA	DND_ALLSTEPCTL_900		;


;	===== 通常の最後の原点復帰（最終回数目）====
DND_ALLSTEPCTL_450:
;	===== 第２工程開始(補正開始) ======
	FAR_JSR	#_X_SET_PV_ABS_TO_OBJ,R0			;20060919
	FAR_JSR	#_LINK_UPPLS_A_OBJMAK2,R0	;
	FAR_JSR	#_DNDUPS_CLEEP_SPD_SET,R0	;
	FAR_JSR	#_POS_LSI_TOP_SPEED_SET,R1	;INPUT R2

	FAR_JSR	#_ORGIN_MODE_INI,R0	;
	MOV.L	#_INT_DND_CTL_STEP,R5	;
	MOV.W	@R5,R0			;
	OR	#BIT0,R0		;
	MOV.W	R0,@R5			;

;	======= 原点出し時のｲﾝﾀｰﾛｯｸ =======
	XOR	R0,R0				;
	MOV.L	#_RST_ERR_CHK_FLG,R1		;[ｲﾆｼｬﾙを異常側で再演算する]
	MOV.W	R0,@R1				;
	M_BRA	DND_ALLSTEPCTL_580		;

DND_ALLSTEPCTL_500:
;	===== 第2工程終了（サーチ作業完了） ======
	FAR_JSR	#_ORGIN_MODE_END,R0		;
	FAR_JSR	#_X_SET_PV_ABS_TO_OBJ,R0		;20060919
	FAR_JSR	#_LINK_UPPLS_A_OBJMAK3,R0	;(待機点への移動)

	FAR_JSR	#_DNDUPS_CLEEP_SPD_SET,R0	;(最後だけゆっくり動けばいいかも)
	FAR_JSR	#_POS_LSI_TOP_SPEED_SET,R1	;INPUT R2

;;;2003-07-14	FAR_JSR	#_DNDUPS_SPD_SET,R0	;
;	===== 第３工程開始 ======
	MOV.L	#_INT_DND_CTL_STEP,R5		;
	MOV.W	@R5,R0				;
	OR	#BIT1,R0			;
	MOV.W	R0,@R5				;


	FAR_JSR	#_DNDUPS_SPD_SET,R0		;2011-03-22[最後の目標位置へは上昇復帰速度]


DND_ALLSTEPCTL_580:
	MOV.L	#_LINK_SV_OBJ_SPDPLS,R1		;//目標速度
	MOV.L	@R1,R2				;
	FAR_JSR	#_POS_LSI_TOP_SPEED_SET,R1	;

	MOV.L	#_LINK_SV_OBJ_ABSPLS,R5		;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	@R5,R1				;
	MOV.L	@(4,R5),R2			;
	FAR_JSR	#_LENGH_ADD_CALC,R0		;Input R1,R2
	FAR_JSR	#_POS_LENGTH_ADD_DATA,R0	;
	FAR_JSR	#_POS_PLS_OUTPUT_DATA,R0	;位置決めLSIｱｸｾｽ(毎ｽｷｬﾝ)
	FAR_JSR	#_FWD_REV_START,R1		;起動

	FAR_JSR	#_BRK_ERR_WORK_CLR1,R0		;_BRK_ERR_CHK_START2	;2003-07-01

	XOR	R0,R0				;
	MOV.L	#_INT_DND_STEP_FLG,R1		;//ｽﾃｯﾌﾟ,段取り共通
	MOV.W	R0,@R1				;Q
	M_BRA	DND_ALLSTEPCTL_900		;

DND_ALLSTEPCTL_600:
	MEM1_BIT0_TO_BIT7_ORSET MEM=_INT_DND_STEP_FLG,LG=W,BIT=BIT6,WKREG=R1 ;

;	== 2003-07-09 ==(_INT_DND_STEP_FLG.BIT6でも代替OK) ===
	MEM1_BIT0_TO_BIT7_ORSET MEM=_ORG_RDY_CTL_FLG,LG=W,BIT=BIT3,WKREG=R1 ;



;	====2004-09-27(中型ではこれは206.4=1)====
	FAR_JSR	#_DND_ORGIN_SIG_FORCE_ON,R0

;	------------2011-03-22-------
;;;;;;	FAR_JSR	#_ORGIN2_MODE_END,R0
	FAR_JSR	#_ORIGIN_POS_CHK_INI2,R0	;待機点移動完了

;	--------- 2014-08-05----------
	FAR_JSR	#_API_BREAK_VALV_FLG_OF,R0





DND_ALLSTEPCTL_900:
	SUB_END
	M_RTS

;	***************************************************
;	***						***
;	***	中型の目標位置決め原点でも206.4=1にする	***
;	***						***
;	***************************************************
;	====2004-09-27(中型ではこれは206.4=1)====
	.ALIGN	4				;
_DND_ORGIN_SIG_FORCE_ON:
	SUB_START
	MOV.L	#_PAR_WTSEL_USE,R0			;
	MOV.W	@R0,R0					;
	CMP/EQ	#1,R0					;待機点選択を中型で認識
	BF	DND_ORGIN_SIG_FORON_EXT			;中型? NO

	MOV.L	#_MODE_SEL,R1				;
	MOV.W	@R1,R0					;
	TST	#_W1DUP,R0				;
	TST_BIT_OF DND_ORGIN_SIG_FORON_EXT		;原点? NO

	MOV.L	#_ORIGN_OBJ_CTL_FLG,R1			;
	MOV.W	@R1,R0					;
	TST	#BIT0,R0				;
	TST_BIT_OF DND_ORGIN_SIG_FORON_EXT		;目標位置決め? NO

	MEM1_BIT0_F_ORSET MEM=_SQ_CBWK_TOP+_WKSQCB206,LG=W,BIT=(BIT4),WKRG1=R1,WKRG2=R4
DND_ORGIN_SIG_FORON_EXT:
	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	段取寸動反転仕様	***
;	***				***
;	***********************************
;
	.INCLUDE	"ssa_dnd1.inc"		; //

;	*******************************************
;	***					***
;	***	段取寸動正転・逆転停止仕様	***
;	***					***
;	*******************************************
;
	.INCLUDE	"ssa_dnd2.inc"		; //


;	*******************************************
;	***					***
;	***	手動パルサ仕様			***
;	***					***
;	*******************************************
;	0.5秒以内に2ﾊﾟﾙｽ以上増えたら起動
;	
;
	.INCLUDE	"ssa_tep1.inc"		; //





;	***********************************
;	***				***
;	***	目標位置→LENGTH	***
;	***				***
;	***********************************
;	Input R1,R2(目標位置)
;	Output R1,R2
	.ALIGN	4				;
_LENGH_ADD_CALC:
	SUB_START
	MOV.L	#_LINK_SV_OBJ_ABSPLS,R5	;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	R1,@R5				;
	MOV.L	R2,@(4,R5)			;

;	===2004-12-20 ===================
	PUSH_REG1 R5
	MOV.L	#_LINKX_SV_OBJ_ABSPLS,R5	;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	R1,@R5				;
	MOV.L	R2,@(4,R5)			;
	POP_REG1 R5
;	=================================

;;;;2014-09-12ﾃﾞﾝｼﾞｬﾗｽか?	MOV.L	#_LINK_PV_ABSPLS,R4		;(ﾌﾙｸﾛｰｽﾞ時は対象を変える)
	MOV.L	#_X_LINK_PV_ABSPLS,R4		;2014-09-14
	MOV.L	@R4+,R5				;
	MOV.L	@R4,R6				;
	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2
	MOV.L	#_LNGTH_ADD_DATA,R4		;//符号付き
	MOV.L	R1,@R4				;
	MOV.L	R2,@(4,R4)			;

;	==== MONITOR 2004-01-28 ====
	MOV.L	#_LT_LNGTH_ADD_DATA,R4	;//符号付き
	MOV.L	R1,@R4				;
	MOV.L	R2,@(4,R4)			;



	SUB_END
	M_RTS

	.ALIGN	4				;
_LENGH_ADD_CALC_SV_TYPE:
	SUB_START
	MOV.L	#_LINK_SV_OBJ_ABSPLS,R4	;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	@R4,R5				;OLD_LOAD
	MOV.L	@(4,R4),R6			;
	MOV.L	R1,@R4				;
	MOV.L	R2,@(4,R4)			;NEW SAVE
;	===2004-12-20 ===================
	PUSH_REG1 R4
	MOV.L	#_LINKX_SV_OBJ_ABSPLS,R4	;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	R1,@R4				;
	MOV.L	R2,@(4,R4)			;
	POP_REG1 R4
;	=================================

	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2
	MOV.L	#_LNGTH_ADD_DATA,R4		;//符号付き
	MOV.L	R1,@R4				;
	MOV.L	R2,@(4,R4)			;
;	==== MONITOR 2004-01-28 ====
	MOV.L	#_LT_LNGTH_ADD_DATA,R4	;//符号付き
	MOV.L	R1,@R4				;
	MOV.L	R2,@(4,R4)			;

	SUB_END
	M_RTS

;	===== BANK LENGTH ADD ====
	.ALIGN	4				;
_BANK_LENGH_ADD_CALC_SV_TYPE:
	SUB_START
	MOV.L	#_LINKX_SV_OBJ_ABSPLS,R4	;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	@R4,R5				;OLD_LOAD
	MOV.L	@(4,R4),R6			;
	MOV.L	R1,@R4				;
	MOV.L	R2,@(4,R4)			;NEW SAVE
	PUSH_REG1 R4
	MOV.L	#_LINK_SV_OBJ_ABSPLS,R4		;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	R1,@R4				;
	MOV.L	R2,@(4,R4)			;
	POP_REG1 R4



	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2
	MOV.L	#_LNGTH_ADD_DATA,R4		;//符号付き
	MOV.L	R1,@R4				;
	MOV.L	R2,@(4,R4)			;
;	==== MONITOR 2004-01-28 ====
	MOV.L	#_LT_LNGTH_ADD_DATA,R4	;//符号付き
	MOV.L	R1,@R4				;
	MOV.L	R2,@(4,R4)			;

	SUB_END
	M_RTS


;	***********************************
;	***	STOP MEM CLR		***
;	***********************************
	.ALIGN	4				;
_POS_LSI_WORK_STOP_CLR:
	SUB_START

	XOR	R0,R0
	MOV.L	#_LNGTH_TOTAL_OUTPLS,R1				;//符号つき TOTAL=TOTAL+ADD ADD_DATA<=0
	MOV.L	R0,@R1						;
	MOV.L	R0,@(4,R1)					;
	MOV.L	#_LNGTH_ADD_DATA,R1				;//符号付き
	MOV.L	R0,@R1						;
	MOV.L	R0,@(4,R1)					;
	MOV.L	#_OUTPLS_MOD,R1					;
	MOV.L	R0,@R1						;

	SUB_END
	M_RTS

;	*******************************************
;	***					***
;	*******************************************
	.ALIGN	4				;
_POS_LSI_WORK_STOP2;
	SUB_START
	FAR_JSR	#_OutputPLS_REG_CLR,R0		;
	XOR	R0,R0				;
	MOV.L	#_POSLSI_CMP_DATA,R1		;//CMP_DATA=CMP_DATA+|ADD_DATA| (符号なし)
	MOV.L	R0,@R1				;
	SUB_END
	M_RTS
;	***********************************
;	***				***
;	***				***
;	***				***
;	***********************************
	.ALIGN	4
_EMG_POS_FLG_PROC:
	SUB_START
	FAR_JSR	#_CYC_END_POS_FLG_CLR,R0	;

	MOV.W	#BIT6,R0			;位置決め完了
	MOV.L	#_INT_CYC_DRV_STS,R1		;//BIT0=1(終了:ﾃﾞｰﾀ保証あり)
	MOV.W	R0,@R1				;

	MOV.L	#_MNWR_POS_CMD,R1		;ﾊﾟﾙｽ払出即停止
	XOR	R0,R0				;
	MOV.W	R0,@R1				;

;;	.AIF	_NEG_SPEC1 EQ _COMPILE_YES	;
;;	.AENDI
	XOR	R0,R0	
	MOV.L	#_INT_DND_NEG_STEP,R1		;//2003-01-27 _NEG_SPEC1 EQ _COMPILE_YES	;
	MOV.W	R0,@R1				;
	MOV.L	#_DNDINC_CTRL_STEP,R1		;2006-07-28
	MOV.W	R0,@R1				;

	FAR_JSR	#_FWD_REV_STSIG_OFF,R0		;
	FAR_JSR	#_POS_LSI_EMG_STOP,R0		;急停止

;	---	[2009-10-07下振子]	---
	FAR_JSR	#_DNM_DATA_CLR,R0			;

;	------------寸動からの上限指令 2013-02-15--
	XOR	R0,R0			;
	MOV.L	#_UPLIMIT_START_F,R1	;//BIT0:寸動からの指令
	MOV.W	R0,@R1			;

;	------------ 2013-07-13
	FAR_JSR	#_EXQ_POS_FLG_PROC,R0

;	--------- 2013-07-18
	XOR	R0,R0
	MOV.L	#_POSCTL_CALC_ERR,R1			;BIT0:起動時
	MOV.W	R0,@R1					;

;	--------- 2014-09-22 繰返---------------
	FAR_JSR	#_MOT_REP_CLR,R0

	SUB_END
	M_RTS


	.ALIGN	4
_EXQ_POS_FLG_PROC:
	SUB_START

	MOV.L	#_MNWR_POS_CMD,R1	;ﾊﾟﾙｽ払出即停止
	XOR	R0,R0			;
	MOV.W	R0,@R1			;
	FAR_JSR	#_FWD_REV_STSIG_OFF,R0				;
	FAR_JSR	#_POS_LSI_EMG_STOP,R0			;急停止

;	==========================
	XOR	R0,R0				;
	MOV.L	#_INT_POS_STEP_FLG,R1		;//ｽﾃｯﾌﾟ,段取り共通
	MOV.W	R0,@R1				;

	XOR	R0,R0				;
	REG_MOV_TO_MEM	DST_ADR=_POS_LSI_ACS_ERR_FLG1	,L1=W,DT_REG=R0,WKREG1=R1	;LSI異常
	REG_MOV_TO_MEM	DST_ADR=_POS_CALC_ERR_FLG1	,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_POS_CALC_ERR_FLG2	,L1=W,DT_REG=R0,WKREG1=R1	;

	FAR_JSR	#_LSI_REST_PLS_CHK_STOP_CLR,R0

	.AIF	_CB_CPU_SEL EQ	_CB_CPUA

	FAR_JSR	#_VIB_PLS_OUT_OF,R0	;2010-08-23加振動制御
	.AENDI


	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
	FAR_JSR	#_API_IVW_CYC_END,R0			;2010-09-21電力測定ﾀｲﾐﾝｸﾞ
	.AENDI

;	-2012-05-30 反転
	FAR_JSR	#_FULCLS_MAXOVER_CLR,R0

;	----------- 荷重行程変更ｸﾘｱ-----------------
	.AIF	_KJYU_CLS EQ	_CMPILE_YES	;YES:反転ﾓｰﾄﾞで荷重でのｸﾛｰｽﾞを行う
	FAR_JSR	#_FCLS_KJYU_STEPCHG_CLR,R0	;2015-03-15[R01:2014-03-20]
	FAR_JSR	#_KAJYU_ELSE_STS_CLR,R0		;
	.AENDI

;	--------- 2013-07-18
	XOR	R0,R0
	MOV.L	#_POSCTL_CALC_ERR,R1			;BIT0:起動時
	MOV.W	R0,@R1					;

	FAR_JSR	#_PRESET_PV_FLGCLR,R0		;2014-09-14 異常が発生した

;	-------- 2015-09-06(2015-07-14)-----------
;;;	_BRK_SADOU_CHG EQ _CMPILE_YES
	FAR_JSR	#_POS_END_MYUTIG_TIMER_CLR,R0

;	------- 2015-11-17 -----------------------
	FAR_JSR	#_API_ACCLW_DRV_STOP,R0

	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	ﾜｰｸﾌﾗｸﾞ関係ｸﾘｱ		***
;	***				***
;	***********************************
;	1ｻｲｸﾙ終了時
	.ALIGN	4
_CYC_END_POS_FLG_CLR:
	SUB_START
	XOR	R0,R0				;
	MOV.L	#_SV_POS_CTL_STEP,R1		;
	MOV.W	R0,@R1				;


	SUB_END
	M_RTS
;	***********************************
;	***				***
;	***	ﾜｰｸﾌﾗｸﾞ関係SET		***
;	***				***
;	***********************************
;	1ｻｲｸﾙ終了時	CYCL=BIT0,SV_STEP=0
;	非常停止復帰時	CYCL=0	,SV_STEP=0
	.ALIGN	4				;
_CYC_END_POS_FLG_SET:
	SUB_START
	MEM1_DATA_SET MEM=_INT_CYC_DRV_STS,LG=W,DATA=(BIT6+BIT0),WKREG1=R1,WKREG2=R2	;ｻｲｸﾙｴﾝﾄﾞ(次回運転まで有効)
	SUB_END
	M_RTS

;	***************************************************
;	***						***
;	***						***
;	***						***
;	***		位置決めＬＳＩアクセス		***
;	***						***
;	***						***
;	***						***
;	***************************************************
;	?加減速時間の演算と指令周波数の演算
;	P27の指令ﾊﾟﾙｽREGのADDとP39の正確な位置決めができませんはなに？
;	"_poslsi1_top"
;	*ﾊﾟﾙｽ列の払い出しは指令ﾊﾟﾙｽｶｳﾝﾀの減算量
;	*速度周波数の演算
;	*ベース周波数=1?
;	*加速時間
;	*急停止の時間
;	***********************************
;	***				***
;	***	ﾊｰﾄﾞｳｴｱｲﾆｼｬﾙ		***
;	***				***
;	***********************************
;	25MHZ*1/N*1/LATE=65535

	.EXPORT	_POS_LSI_HARD_INITAL
	.EXPORT	_POS_LSI_DATA_INITAL

	.MACRO	POS_LSI_CMD_WR ADR_REG,DAT_REG
	SWAP.W	\DAT_REG,\DAT_REG				;

	MOV.W	\DAT_REG,@\ADR_REG
	ADD	#2,R6						;MEM HIGH WORD==>LOW WORD SAVE
	SWAP.W	\DAT_REG,\DAT_REG				;
	POS_LSI_WORD_DUM_LOD					;
	MOV.W	\DAT_REG,@\ADR_REG				;HIGH WORD SAVE
	POS_LSI_WORD_DUM_LOD					;
	.ENDM

	.MACRO	POS_LSI_BIT_SET_LG ADR,MEM
	MOV.L	#\MEM,R6					;
	MOV.L	@R6,R5						;
	OR	R4,R5						;
	MOV.L	R5,@R6						;SAVE

	MOV.L	#_poslsi1_top+_PLSI_CH1+\ADR,R6			;
	POS_LSI_CMD_WR ADR_REG=R6,DAT_REG=R5			;
	.ENDM


	.MACRO	POS_LSI_BIT_CLR_LG ADR,MEM
	MOV.L	#\MEM,R6					;
	MOV.L	@R6,R5						;
	AND	R4,R5						;
	MOV.L	R5,@R6						;SAVE

	MOV.L	#_poslsi1_top+_PLSI_CH1+\ADR,R6			;
	POS_LSI_CMD_WR ADR_REG=R6,DAT_REG=R5			;
	.ENDM

;AND R3 対象BIT
;OR  R4 転送BIT
	.MACRO	POS_LSI_BIT_MOV_LG ADR,MEM
	MOV.L	#\MEM,R6					;
	MOV.L	@R6,R5						;
	NOT	R3,R3						;
	AND	R3,R5						;
	OR	R4,R5						;
	MOV.L	R5,@R6						;SAVE

	MOV.L	#_poslsi1_top+_PLSI_CH1+\ADR,R6			;
	POS_LSI_CMD_WR ADR_REG=R6,DAT_REG=R5			;
	.ENDM



;	***************************************************
;	***	位置決めＬＳＩ 32BIT DATA WRITE		***
;	***	払出ﾊﾟﾙｽ設定
;	********************************************

	.MACRO	POS_LSI_32BIT_DAT_SET ADR,ADR_REG,DAT_REG
	PUSH_REG1 \ADR_REG
	PUSH_REG1 \DAT_REG
	POS_LSI_WORD_DUM_LOD					;
	MOV.L	#_poslsi1_top+_PLSI_CH1+\ADR,\ADR_REG		;
	MOV.W	\DAT_REG,@\ADR_REG				;(LOW)
	ADD	#2,\ADR_REG					;
	SWAP.W	\DAT_REG,\DAT_REG				;
	POS_LSI_WORD_DUM_LOD					;
	MOV.W	\DAT_REG,@\ADR_REG				;(HIGH)
	POS_LSI_WORD_DUM_LOD					;
	POP_REG1 \DAT_REG
	POP_REG1 \ADR_REG
	.ENDM


;	*******************************************
;	***					***
;	***					***
;	***					***
;	*******************************************
	.ALIGN	4				;
_POS_LSI_HARD_INITAL:
	SUB_START
;	==========================================
	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_CtrlReg,R6		;
	.AIF	_LSI_SOFT_CAL_ENB EQ _CMPILE_YES		;2006-09-19
	MOV.W	#H'100*(B'01000011)+(B'11000100),R5
								;B相進み
								;BIT7,BIT6=1,1 +OT,-OT無効
								;BIT9,BIT8=1,1 自動加減速無効
								;BIT14         外部ｹﾞｰﾄ無効
	.AELSE
	MOV.W	#H'100*(B'01000000)+(B'11000100),R5
								;B相進み
								;BIT7,BIT6=1   +OT,-OT無効
								;BIT9,BIT8=0,0 自動加減速有効
								;BIT14         外部ｹﾞｰﾄ無効
	.AENDI
	MOV.W	R5,@R6						;
;BIT0=0(正転PLS/逆転PLS 2PLS MODE)
;BIT1=0 帰還有効
;BIT2=1 A相進み
;BIT4,3=0 90位相;
;BIT13=0速度16ﾋﾞｯﾄ　=1:20ﾋﾞｯﾄ
;
;	======= ｲﾝｸﾘﾒﾝﾀﾙﾊﾟﾙｽｶｳﾝﾄ開始	============
	MOV.L	#BIT2,R5					;
	MOV.L	#_LSI_BUF_PLS_BitComdL,R6			;
	MOV.L	R5,@R6						;MOTROLA 32BIT DATA

	MOV.L	#BIT2,R4						;
	POS_LSI_BIT_SET_LG ADR=_PLS_BitComdL,MEM=_LSI_BUF_PLS_BitComdL	;BIT2(BIT18)

	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	ﾒｲﾝﾃﾞｰﾀ受信後		***
;	***				***
;	***********************************
	.ALIGN	4				;
_POS_LSI_DATA_INITAL:
	SUB_START
	FAR_JSR	#_POS_LSI_SPDLATE_SET,R0	;(本当は1回だけ)
	FAR_JSR	#_POS_LSI_BAS_SPEED_SET,R0	;(本当は1回だけ)
	MEM_MOV_TO_MEM	_POSCTL_SV_OFS_SPD,L,_POSCTL_RL_SPD,L,R1,R2,R3	;2006-11-30



;;;;2006-11-30	FAR_JSR	#_POS_LSI_ACC1_SET,R0		;加減速(意味無し)
;;;;2006-11-30	FAR_JSR	#_POS_LSI_ACC2_SET,R0		;加減速

	SUB_END
	M_RTS


;	***********************************
;	***				***
;	***	起動前ｲﾆｼｬﾙ		***
;	***				***
;	***********************************
	.ALIGN	4				;
_POS_LSI_START_INITAL:
	SUB_START

;	===== 本当は不要だけど、ﾃﾞﾊﾞｯｸ完了までは======

;	====== フルクローズ時は自起動を使用したインチングを行う ===
	FAR_JSR	#_POS_LSI_BAS_SPEED_SET,R0	;
	MEM_MOV_TO_MEM	_POSCTL_SV_OFS_SPD,L,_POSCTL_RL_SPD,L,R1,R2,R3	;2006-11-30




;;;;2006-11-30	FAR_JSR	#_POS_LSI_ACC2_SET,R0		;加減速
;;;;2006-11-30	FAR_JSR	#_POS_LSI_ACC1_SET,R0		;加減速
	FAR_JSR	#_POS_LSI_WORK_STOP_CLR,R0	;

	SUB_END
	M_RTS
;	***********************************
;	***				***
;	***	起動前ｲﾆｼｬﾙ		***
;	***				***
;	***********************************
	.ALIGN	4				;
_POS_LSI_START_INITL2:
	SUB_START


;	====== フルクローズ時は自起動を使用したインチングを行う ===
	FAR_JSR	#_POS_LSI_CLS_BAS_SPD_SET,R0	;
	MEM_MOV_TO_MEM	_POSCTL_SV_OFS_SPD,L,_POSCTL_RL_SPD,L,R1,R2,R3	;2006-11-30

;;;;2006-11-30	FAR_JSR	#_POS_LSI_ACC2_SET,R0		;加減速
;;;;2006-11-30	FAR_JSR	#_POS_LSI_ACC1_SET,R0		;加減速
	FAR_JSR	#_POS_LSI_WORK_STOP_CLR,R0	;

	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	起動前ｲﾆｼｬﾙ		***
;	***	2013-06-13		***
;	***********************************
	.ALIGN	4				;
_POS_LSI_START_INITAL_TEP:
	SUB_START

	FAR_JSR	#_POS_LSI_TEP_BAS_SPEED_SET,R0
	MEM_MOV_TO_MEM	_POSCTL_SV_OFS_SPD,L,_POSCTL_RL_SPD,L,R1,R2,R3	;2006-11-30
	FAR_JSR	#_POS_LSI_WORK_STOP_CLR,R0	;

	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	指令ﾊﾟﾙｽﾚｼﾞｽﾀｸﾘｱ	***
;	***				***
;	***********************************
;	2004-02-19
	.ALIGN	4				;
_OutputPLS_REG_CLR:
	SUB_START
	PUSH_ALL
	XOR	R0,R0					;
	MOV.L	#_LSI_PLSCLR_RETRY_CNT1,R1		;//CLR処理そのもの
	MOV.W	R0,@R1					;

	TIM_CNT_ADD MEM=_LSI_PLSCLR_AC_CNT1,LG=L,ADR_REG=R1,DAT_REG=R0,LATE=1


OutputPLS_REGCLR_LOP:
	FAR_JSR	#_LOAD_REST_PLS,R0
	MOV.L	#(BIT12*H'10000),R4						;
	POS_LSI_BIT_SET_LG ADR=_PLS_BitComdL,MEM=_LSI_BUF_PLS_BitComdL		;

;(DE LATCHしない)	FAR_JSR	#_LOAD_REST_PLS,R0				;
	POS_LSI_WORD_DUM_LOD							;
	POSLSI_RD_WR_WAIT_NOP							;

	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_OutPposL,R1			;R/W 指令ﾊﾟﾙｽ数
	MOV.W	@R1+,R0								;
	POS_LSI_WORD_DUM_LOD							;
	MOV.W	@R1,R0								;
	POS_LSI_WORD_DUM_LOD							;

	MOV.L	#~(BIT12*H'10000),R4						;
	POS_LSI_BIT_CLR_LG ADR=_PLS_BitComdL,MEM=_LSI_BUF_PLS_BitComdL		;
	FAR_JSR	#_LOAD_REST_PLS,R0

	TST	R0,R0					;払出ﾊﾟﾙｽｸﾘｱ完了
	TST_BIT_ON OutputPLS_REGCLR_100			;
	M_BRA	OutputPLS_REGCLR_END			;
OutputPLS_REGCLR_100:

;	==== ﾘｾｯﾄｺﾏﾝﾄﾞによるﾘｾｯﾄ失敗=====
	TIM_CNT_ADD MEM=_LSI_PLSCLR_NG_CNT1,LG=L,ADR_REG=R1,DAT_REG=R0,LATE=1

	FAR_JSR	#_LOAD_REST_PLS,R0					;
	NEG	R0,R0							;
	POS_LSI_32BIT_DAT_SET ADR=_PLS_OutPposL,ADR_REG=R1,DAT_REG=R0	;

	FAR_JSR	#_LOAD_REST_PLS,R0					;
	TST	R0,R0							;
	TST_BIT_ON OutputPLS_REGCLR_150					;
	M_BRA	OutputPLS_REGCLR_END					;

OutputPLS_REGCLR_150:
	TIM_CNT_ADD MEM=_LSI_PLSCLR_RETRY_CNT1,LG=W,ADR_REG=R1,DAT_REG=R0,LATE=1		;
	MOV.L	#_LSI_PLSCLR_RETRY_CNT1,R1							;
	MOV.W	@R1,R0										;
	MOV.W	#_LSI_RETRY_ERR_MAX,R1								;
	CMP/HI	R1,R0										;10=< R0
	BT	OutputPLS_REGCLR_ERR								;
	TIM_CNT_ADD MEM=_LSI_PLSCLR_NG_CNT2,LG=L,ADR_REG=R1,DAT_REG=R0,LATE=1			;
	M_BRA	OutputPLS_REGCLR_LOP								;

OutputPLS_REGCLR_ERR:
;	== 異常ﾌﾗｸﾞ==
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POS_LSI_ACS_ERR_FLG1,LG=W,BIT=(BIT1+BIT0),WKREG=R1		;

OutputPLS_REGCLR_END:
	POP_ALL
	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	急停止			***
;	***				***
;	***********************************
	.ALIGN	4				;
_POS_LSI_EMG_STOP			;急停止
	SUB_START

	FAR_JSR	#_FWD_REV_STSIG_OFF,R0				;

	FAR_JSR	#_LOD_POS_STS_REG,R0
	TST	#BIT2,R0		;
	TST_BIT_ON POS_LSI_EMGSTOP_END

	.AIF	_LSI_SOFT_CAL_ENB EQ _CMPILE_YES		;2006-09-19
	FAR_JSR	#_SPD_CTL_EMG_STOP,R0				;
	FAR_JSR	#_POS_LSI_EMG_STOP_CMD,R0			;
	
	.AELSE
	FAR_JSR	#_POS_LSI_EMG_STOP_CMD,R0			;
	.AENDI

POS_LSI_EMGSTOP_END:

	SUB_END
	M_RTS
;	***********************************
;	***				***
;	***	減速停止		***
;	***				***
;	***********************************
	.ALIGN	4				;
_POS_LSI_SLOW_STOP			;急停止
	SUB_START

	FAR_JSR	#_FWD_REV_STSIG_OFF,R0		;

	FAR_JSR	#_LOD_POS_STS_REG,R0
	TST	#BIT2,R0			;
	TST_BIT_ON POS_LSI_SLWSTOP_END

	.AIF	_LSI_SOFT_CAL_ENB EQ _CMPILE_YES		;2006-09-19
	FAR_JSR	#_SPD_CTL_SLOW_STOP,R0		;
	.AELSE
	FAR_JSR	#_POS_LSI_SLOW_STOP_CMD,R0	;
	.AENDI


POS_LSI_SLWSTOP_END:

	SUB_END
	M_RTS

;	---------------------------------------------------
;	---	位置決めLSIへのｺﾏﾝﾄﾞ発行とﾜｰｸ処理	---
;	---	EMG					---
;	---------------------------------------------------
	.ALIGN	4				;
_POS_LSI_EMG_STOP_CMD:
	SUB_START
	MOV.L	#(BIT11*H'10000),R4					;
	POS_LSI_BIT_SET_LG ADR=_PLS_BitComdL,MEM=_LSI_BUF_PLS_BitComdL	;
	NOP
	FAR_JSR	#_POS_LSI_WORK_STOP_CLR,R0
	NOP
	MOV.L	#~(BIT11*H'10000),R4		;
	POS_LSI_BIT_CLR_LG ADR=_PLS_BitComdL,MEM=_LSI_BUF_PLS_BitComdL	;
	SUB_END
	M_RTS

;	---------------------------------------------------
;	---	位置決めLSIへのｺﾏﾝﾄﾞ発行とﾜｰｸ処理	---
;	---	SLOW					---
;	---------------------------------------------------
	.ALIGN	4				;
_POS_LSI_SLOW_STOP_CMD
	SUB_START
	MOV.L	#(BIT10*H'10000),R4		;
	POS_LSI_BIT_SET_LG ADR=_PLS_BitComdL,MEM=_LSI_BUF_PLS_BitComdL	;
	NOP
	FAR_JSR	#_POS_LSI_WORK_STOP_CLR,R0
	NOP
	MOV.L	#~(BIT10*H'10000),R4		;
	POS_LSI_BIT_CLR_LG ADR=_PLS_BitComdL,MEM=_LSI_BUF_PLS_BitComdL	;

	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	速度変更有効		***
;	***				***
;	***********************************


;	***********************************
;	***				***
;	***	起動			***
;	***				***
;	***********************************

	.ALIGN	4				;
_FWD_REV_START:
	SUB_START
	FAR_JSR	#_FWD_REV_STSIG_OFF,R0				;

	MOV.L	#_POSLSI_DRIV_SHIN,R1
	MOV.W	@R1,R0						;
	MOV.L	#(BIT3*H'10000),R3				;
	XOR	R4,R4						;
	TST	#BIT0,R0					;
	TST_BIT_OF FWD_REV_STR_050				;
	MOV	R3,R4						;
FWD_REV_STR_050:						;
;	=============================
	MOV.L	#_SVP_MACINE_SEL1,R1				;
	MOV.W	@R1,R0						;
	MOV.W	#D'8765,R1					;
	CMP/EQ	R1,R0						;
	BF	FWD_REV_STR_055					;
	MOV.L	#_DBG_XOR_SIG,R0				;
	XOR	R0,R4						;
FWD_REV_STR_055:						;

;	==方向選択==
	POS_LSI_BIT_MOV_LG ADR=_PLS_BitComdL,MEM=_LSI_BUF_PLS_BitComdL		;
	POS_LSI_WORD_DUM_LOD							;

;	== 起動 ===								;
	MOV.L	#(BIT2*H'10000),R4						;
	POS_LSI_BIT_SET_LG ADR=_PLS_BitComdL,MEM=_LSI_BUF_PLS_BitComdL		;;起動 ONｴｯｼﾞ
	POS_LSI_WORD_DUM_LOD							;

	FAR_JSR	#_SPD_CTL_START,R0


	.AIF	_CB_CPU_SEL EQ	_CB_CPUA

	FAR_JSR	#_VIB_PLS_OUT_ON,R0	;2010-08-23加振動制御
	.AENDI




	SUB_END
	M_RTS

;	==== 起動信号OFF ====
	.ALIGN	4				;
_FWD_REV_STSIG_OFF:
	SUB_START
	MOV.L	#~(BIT2*H'10000),R4		;
	POS_LSI_BIT_CLR_LG ADR=_PLS_BitComdL,MEM=_LSI_BUF_PLS_BitComdL	;
	SUB_END
	M_RTS

;	=====================
;	==== 起動信号OFF ====
;	=====================
;	残ﾊﾟﾙｽがなくなってから指令OFF
	.ALIGN	4				;
_FWD_REV_STSIG_OFF_SPEC:
	SUB_START
	PUSH_REG1 R0
	FAR_JSR	#_LOAD_REST_PLS,R0
	MOV	R0,R1						;
	POP_REG1 R0

	TST	R1,R1				;
	TST_BIT_ON FWD_REV_STSIG_OFSPEC_050	;
	MOV.L	#~(BIT2*H'10000),R4		;
	POS_LSI_BIT_CLR_LG ADR=_PLS_BitComdL,MEM=_LSI_BUF_PLS_BitComdL	;
FWD_REV_STSIG_OFSPEC_050:
	SUB_END
	M_RTS

;	***********************************
;	***	ｽﾃｰﾀｽLOAD		***
;	***********************************
;;	.EXPORT	_LOD_POS_STS_REG	;2003-05-12
	.ALIGN	4				;
_LOD_POS_STS_REG:
	SUB_START
	PUSH_REG1 R2

	FAR_JSR	#_LOD_POS_STS_REG_IN,R0	;ANS R0

	POP_REG1 R2
	SUB_END
	M_RTS


;	***********************************
;	***	ｽﾃｰﾀｽLOAD		***
;	***********************************
;;	.EXPORT	_LOD_POS_STS_REG	;2003-05-12
	.ALIGN	4				;
_LOD_POS_STS_REG_POR:
_LOD_POS_STS_REG_SLOW:
	SUB_START
	PUSH_REG1 R2

	FAR_JSR	#_LOD_POS_STS_REG_IN,R0		;ANS R0
	TST	#BIT2,R0			;
	TST_BIT_ON LOD_POS_STS_REGSLOW_END	;
	MOV.L	#_POSCTL_STEP_FLG,R2		;
	MOV.W	@R2,R4				;
	MOV.W	#BIT6,R2			;
	TST	R2,R4				;
	TST_BIT_OF LOD_POS_STS_REGSLOW_END	;
	OR	#BIT2,R0			;

LOD_POS_STS_REGSLOW_END:
	POP_REG1 R2
	SUB_END
	M_RTS



;	***********************************
;	***	ｽﾃｰﾀｽLOAD		***
;	***********************************
;	R0 BIT2=1 STOP
	.ALIGN	4				;
_LOD_POS_STS_REG_IN:
	SUB_START
	PUSH_REG1 R2

	MOV.L	#(BIT2*H'10000),R4
LOD_POS_STSRG00:
	POS_LSI_WORD_DUM_LOD					;
	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_BitInfoL,R6	;
	MOV.W	@R6+,R0						;BIT1:指令ﾊﾟﾙｽ BIT2:ﾊﾟﾙｽ払出停止中
								;BIT2で判断する
	POS_LSI_WORD_DUM_LOD					;
	MOV.W	@R6,R2						;
	EXTU.W	R0,R0						;LOW
	EXTU.W	R2,R2						;HIGH
	SHLL16	R2
	OR	R2,R0						;
	NOP
	POS_LSI_WORD_DUM_LOD					;
	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_BitInfoL,R6	;
	MOV.W	@R6+,R1						;
	POS_LSI_WORD_DUM_LOD					;
	MOV.W	@R6,R2						;
	EXTU.W	R1,R1						;LOW
	EXTU.W	R2,R2						;HIGH
	SHLL16	R2						;
	OR	R2,R1						;

	XOR	R1,R0						;
	TST	R4,R0						;
	TST_BIT_ON LOD_POS_STSRG00				;R0=R1
	MOV	R1,R0						;BIT2

	POP_REG1 R2
	SUB_END
	M_RTS





;	***********************************
;	***	現在位置ｶｳﾝﾀLOAD	***
;	***********************************
	.EXPORT	_POS_LSI_CNT_LOAD_R1reg
	.ALIGN	4				;
_POS_LSI_CNT_LOAD_R1reg:
	SUB_START
	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_NowPos1L,R6	;
	MOV.L	@R6,R1						;(とりあえずこのままにしておく)
	SWAP.W	R1,R1						;
	SUB_END
	M_RTS



;	***********************************
;	***				***
;	***	払出ﾊﾟﾙｽ		***
;	***				***
;	***********************************
;	I/F LNGTH_ADD_DATA[2];//符号付き
;
;	ﾊﾞｯｸﾗｯｼの処理はここで行う
;
;
	.ALIGN	4				;
_POS_LENGTH_ADD_DATA
	SUB_START
	MOV.L	#_LNGTH_ADD_DATA,R4		;//符号付き
	MOV.L	@R4,R1				;
	MOV.L	@(4,R4),R2			;
	XOR	R3,R3				;
	MOV.L	R3,@R4							;
	MOV.L	R3,@(4,R4)						;(ここでﾊﾞｯｸﾗｯｼ補正を足しこむ)

	MOV.L	#_LNGTH_TOTAL_OUTPLS,R7					;//符号つき TOTAL=TOTAL+ADD ADD_DATA<=0
	MOV.L	@R7,R5							;
	MOV.L	@(4,R7),R6						;
	ADD8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;
	MOV.L	R1,@R7							;
	MOV.L	R2,@(4,R7)						;

;	===2004-01-28 MONITOR ==
	MOV.L	#_LT_LNGTH_TOTAL_OUTPLS,R7;//符号つき
	MOV.L	R1,@R7							;
	MOV.L	R2,@(4,R7)						;

	SUB_END
	M_RTS

;	*******************************************
;	***					***
;	***	ﾊﾟﾙｽ払い出し管理		***
;	***					***
;	*******************************************
;	***********************************************************
;	***	(停止時からの起動の場合のみ有効・安一のみ)	***
;	***********************************************************
	.ALIGN	4				;
_POS_PLSOUT_SET_RETRY:
	SUB_START
	MOV.L	#_MODE_SEL,R1			;
	MOV.W	@R1,R0				;
	MOV.W	#_W1SGL,R4			;
	TST	R4,R0				;
	TST_BIT_ON POS_PLSOUT_SETRY100		;

	FAR_JSR	#_POS_PLS_OUTPUT_DATA,R0	;
	M_BRA	POS_PLSOUT_SETRYEXT

;	===	安全一行程	===
POS_PLSOUT_SETRY100:
	XOR	R0,R0
	MOV.L	#_LSI_PLSSET_RETRY_CNT1,R1		;
	MOV.W	R0,@R1					;

	eSHi_SET_MEM_MOV SRC=_LNGTH_TOTAL_OUTPLS+4,L1=L,DST=_eSHi_LNGH_ADD_SR,L2=L	;
	TIM_CNT_ADD MEM=_eSHi_LOT_CNT_A,LG=W,ADR_REG=R1,DAT_REG=R0,LATE=1		;+1



POS_PLSOUT_SETRYLOP:

	MOV.L	#_LNGTH_TOTAL_OUTPLS,R7					;+/-(0へ向かっていく)
	MOV.L	@R7,R1							;
	MOV.L	@(4,R7),R2						;払いだしたい量
	PUSH_REG1 R1							;
	PUSH_REG1 R2							;
	FAR_JSR	#_POS_PLS_OUTPUT_DATA,R0				;
	POP_REG1 R2							;
	POP_REG1 R1							;
	MOV	R1,R3							;
	MOV	R2,R4							;
	CMP/PZ	R3							;"+"
	BT	POS_PLSOUT_SETRY120					;
	NEG1_64	H_REG=R3,L_REG=R4,WKREG=R0				;|R3,R4|
POS_PLSOUT_SETRY120:
	TST	R3,R3							;
	TST_BIT_OF POS_PLSOUT_SETRY130					;
;	====上位LWORDが存在する. 1回転の中にそれがあることはない
;	==== data err ===									;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POS_CALC_ERR_FLG1,LG=W,BIT=(BIT2+BIT0),WKREG=R1		;
	FAR_JSR	#_OutputPLS_REG_CLR,R0								;
	M_BRA	POS_PLSOUT_SETRY900								;

POS_PLSOUT_SETRY130:

	FAR_JSR	#_LOAD_REST_PLS,R0			;
	eSHi_SET_REG_MOV DST=_eSHi_REST_PLS_SR,L1=L,SETREG=R0,WKREG1=R5

	CMP/EQ	R0,R4					;
	BT	POS_PLSOUT_SETRY900			;"EQU"
	ADD	#1,R0					;
	CMP/EQ	R0,R4					;
	BT	POS_PLSOUT_SETRY900			;
	ADD	#-2,R0					;
	CMP/EQ	R0,R4					;
	BT	POS_PLSOUT_SETRY900			;

;	==== ﾍﾞﾘﾌｧｲ異常====
	DEBUG_LSI_ACS_ON2_BIT BITDT=BIT2		;VERIFAY ERR

	FAR_JSR	#_OutputPLS_REG_CLR,R0			;
	MOV.L	#_LNGTH_TOTAL_OUTPLS,R7			;+/-(0へ向かっていく)
	MOV.L	R1,@R7					;
	MOV.L	R2,@(4,R7)				;払いだしたい量

	MOV.L	#_LSI_PLSSET_RETRY_CNT1,R1		;
	MOV.W	@R1,R0					;
	MOV.W	#_LSI_RETRY_ERR_MAX,R4								;
	ADD	#1,R0										;
	MOV.W	R0,@R1										;
	CMP/HI	R4,R0										;3<
	BT	POS_PLSOUT_SETRYERR								;
	TIM_CNT_ADD MEM=_LSI_PLSSET_NG_CNT1,LG=L,ADR_REG=R1,DAT_REG=R0,LATE=1			;
	M_BRA	POS_PLSOUT_SETRYLOP			;

POS_PLSOUT_SETRYERR:
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POS_LSI_ACS_ERR_FLG1,LG=W,BIT=(BIT2+BIT0),WKREG=R1		;
	DEBUG_LSI_ACS_ON2_BIT BITDT=BIT6		;RETRY ERR
	M_BRA	POS_PLSOUT_SETRYEXT	

POS_PLSOUT_SETRY900:
;	=== FLAG SET====
	eSHi_SET_IM_MOV DST=_eSHi_REST_SR_HF,L1=W,WKREG1=R1,WKREG2=R0,IMD=1	;

POS_PLSOUT_SETRYEXT:
	DEBUG_LSI_ACS_OF2_BIT BITDT=BIT4		;VERYFAI ERR OFF付

	SUB_END
	M_RTS

;	*******************************************
;	***					***
;	***	ﾊﾟﾙｽ払い出し管理		***
;	***					***
;	*******************************************
	.ALIGN	4				;
_POS_PLS_OUTPUT_DATA:
	SUB_START


	FAR_JSR	#_LOAD_REST_PLS,R0						;
	MOV	R0,R11								;R/W 指令ﾊﾟﾙｽｶｳﾝﾀ(残ﾊﾟﾙｽ)
	MOV.L	#_POSLSI_CHK_RESTPLS,R1						;
	MOV.L	R11,@R1								;

	MOV.L	#_PLS_OUTPUT_MAX,R12						;
	SUB	R11,R12								;
	CMP/PZ	R12								;残り設定できる距離出力側で
	BT	POS_PLS_OUTDAT_050						;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POSLSI_CHK_STS,LG=W,BIT=BIT0,WKREG=R1	 ;
	XOR	R12,R12								;
POS_PLS_OUTDAT_050:								;R12は出力ﾊﾟﾙｽﾚﾍﾞﾙ
;	============= 出力ﾊﾟﾙｽ補正============
	MOV	R12,R2							;ﾊﾟﾙｽ列-->ｲﾝｸﾘﾒﾝﾀﾙﾊﾟﾙｽ量
;;;;;	FAR_JSR	#_POS_OUT_TO_INC_CHG,R0					;
	MOV	R2,R12							;

;	==== R12が設定可能量====
	MOV.L	#_LNGTH_TOTAL_OUTPLS,R7					;+/-(0へ向かっていく)
	MOV.L	@R7,R1							;
	MOV.L	@(4,R7),R2						;払いだしたい量
	MOV	R1,R0							;
	OR	R2,R0							;
	TST	R0,R0							;
	TST_BIT_ON POS_PLS_OUTDAT_080					;
	XOR	R12,R12							;位置決めLSIには設定済み
	M_BRA	POS_PLS_OUTDAT_300					;

POS_PLS_OUTDAT_080:							;
	PUSH_REG1	R1
	CMP/PZ	R1							;
	BT	POS_PLS_OUTDAT_100					;
	NEG1_64	H_REG=R1,L_REG=R2,WKREG=R3				;|R1,R2|
POS_PLS_OUTDAT_100:							;
	TST	R1,R1							;
	TST_BIT_ON POS_PLS_OUTDAT_200					;引いてOK
	CMP/GT	R12,R2							;引いてOK
	BT	POS_PLS_OUTDAT_200					;
	MOV	R2,R12							;R12(R2)だけ引いてOK
POS_PLS_OUTDAT_200:							;(引く量の決定)
	XOR	R0,R0							;
	SUB8B DT_REGH=R0,DT_REGL=R12,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;
	POP_REG1 R0
	CMP/PZ	R0
	BT	POS_PLS_OUTDAT_250					;
	NEG1_64	H_REG=R1,L_REG=R2,WKREG=R3				;
POS_PLS_OUTDAT_250:							;
	MOV.L	R1,@R7							;
	MOV.L	R2,@(4,R7)						;

;"R12ADD"
POS_PLS_OUTDAT_300:								;
	FAR_JSR	#_LOAD_REST_PLS,R0						;OLD残りﾊﾟﾙｽ
	MOV	R0,R4								;
	MOV	R12,R2								;

	DEBUG_LSI_ACS_ON2_BIT BITDT=(BIT4+BIT0)					;
	.AIF	_PLSI_WR_WT_CHG		EQ	_CMPILE_YES	;YES:WR WAIT 4CLK(NO 3CLK) 2004-02-19
	POS_LSI_32BIT_DAT_SET ADR=_PLS_OutPposL,ADR_REG=R6,DAT_REG=R2		;製品
	.AELSE

;	===== 異常を発生させるよう ======
	PUSH_REG1 R0							;
	PUSH_REG1 R12							;
	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_OutPposL,R0		;R/W
	SWAP.W	R12,R12							;
	MOV.L	R12,@R0							;
	POP_REG1 R12							;
	POP_REG1 R0							;
	.AENDI

	DEBUG_LSI_ACS_OF2_BIT BITDT=BIT0

	FAR_JSR	#_LOAD_REST_PLS,R0						;NEW残りﾊﾟﾙｽ
	MOV.L	#_NEW_POSLSI_RESTPLS,R1						;
	MOV.L	R0,@R1								;

	eSHi_SET_REG_MOV DST=_eSHi_REST_PLS_RL,L1=L,SETREG=R0,WKREG1=R1		;


;	基本的には
;	OLD+SV=NEW

	ADD	R12,R4							;
	MOV	R4,R3							;
	MOV.W	#D'500,R1						;200usec(100pls)　受信割込有り
	ADD	R1,R4							;OLD+SV+500<NEW 
	CMP/HI	R4,R0							;OLD+SV+500<NEW
	BT	POS_PLS_OUTDAT_320_ERR1					;

	MOV	R3,R4							;
	MOV.W	#D'500,R1						;200usec(100pls)
	SUB	R1,R4							;
	CMP/PZ	R4							;
	BT	POS_PLS_OUTDAT_320_ECK10				;
	XOR	R4,R4							;
POS_PLS_OUTDAT_320_ECK10:						;
	CMP/HS	R4,R0
	BT	POS_PLS_OUTDAT_320_END					;R4 =< R0 OK
;	=== 設定したﾊﾟﾙｽ+OLD残ﾊﾟﾙｽ-200 ≧残ﾊﾟﾙｽなら異常(2)	===
	TIM_CNT_ADD MEM=_LSI_PLSSET_NG_CNT2,LG=L,ADR_REG=R1,DAT_REG=R0,LATE=1			;
;;;;;	MEM1_BIT0_TO_BIT7_ORSET MEM=_POS_LSI_ACS_ERR_FLG1,LG=W,BIT=(BIT3+BIT0),WKREG=R1		;
	M_BRA	POS_PLS_OUTDAT_320_EXT								;

POS_PLS_OUTDAT_320_ERR1:									;
;	=== 設定したﾊﾟﾙｽ+OLD残ﾊﾟﾙｽ≦残ﾊﾟﾙｽなら異常(1)	=== 500KHZ 200usec=100pls		;
	TIM_CNT_ADD MEM=_LSI_PLSSET_NG_CNT3,LG=L,ADR_REG=R1,DAT_REG=R0,LATE=1			;ここだとﾘﾄﾗｲできない
;;;;;	MEM1_BIT0_TO_BIT7_ORSET MEM=_POS_LSI_ACS_ERR_FLG1,LG=W,BIT=(BIT4+BIT0),WKREG=R1		;
	M_BRA	POS_PLS_OUTDAT_320_EXT								;

POS_PLS_OUTDAT_320_END:									;
	TIM_CNT_ADD MEM=_LSI_PLSSET_AC_CNT2,LG=L,ADR_REG=R1,DAT_REG=R0,LATE=1		;
POS_PLS_OUTDAT_320_EXT:									;



	eSHi_SET_MEM_MOV SRC=_INT_POS_CTL_STEP,L1=W,DST=_eSHi_LOT_STEP_A,L2=W


;	======== ものは試し====
	XOR	R5,R5
	MOV.L	#_POSLSI_DRIV_SHIN,R1
	MOV.W	@R1,R0							;
	TST	#BIT0,R0
	TST_BIT_OF POS_PLS_OUTDAT_400					;
	NEG1_64	H_REG=R5,L_REG=R13,WKREG=R3				;
POS_PLS_OUTDAT_400:							;


	SUB_END
	M_RTS


;	***********************************
;	***				***
;	***	連続開始		***
;	***				***
;	***********************************
;	安全一工程、連続、オプション
;	寸動と

	.ALIGN	4				;
_MOTION_CYCLE_START:
	SUB_START
;;	MOV.L	#_MODE_SEL,R1			;
;;	MOV.W	@R1,R0				;
;;	TST	#_W1CNT,R0			;
;;	TST_BIT_OF MOTION_CYC_ST100		;
;;	FAR_JSR	#_CYCLE_TIME_REFLASH_START,R0	;
;;MOTION_CYC_ST100:				;


	FAR_JSR	#_DAI_MOSTPOS_SMPINI,R0		;2003-02-03
	FAR_JSR	#_KJPHOS_SMPINI,R0		;2004-07-05

	MOV.L	#_MODE_SEL,R1			;
	MOV.W	@R1,R0				;
	TST	#_W1CNT+_W1SGL+_W1INC+_W1OPT,R0	;
	TST_BIT_OF MOTION_CYC_ST200		;

	MOV.L	#_CPOS_CTL_MATH,R1		;
	MOV.W	@R1,R0				;
;;2009-10-07	TST	#_DMATH_CNTROT,R0		;2002-09-01 回転?
	TST	#(_DMATH_CNTROT+_DMATH_DNDRIV),R0	;2009-10-07_DMATH_CNTROT,R0		;2002-09-01 回転?
	TST_BIT_OF DAI_CHK01_100

;;;2003-02-03	FAR_JSR	#_DAI_MOSTPOS_SMPINI,R0		;
	FAR_JSR	#_DAI_FULL_SCALE_SMP_INI,R0	;2003-02-03

DAI_CHK01_100

	FAR_JSR	#_CYCLE_TIME_REFLASH_START,R0	;

MOTION_CYC_ST200:				;

	FAR_JSR	#_MOST_DISP_DAT_INI,R0

;	----------------------------------------
	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
	FAR_JSR	#_API_IVW_CYC_START,R0			;2010-09-21電力測定ﾀｲﾐﾝｸﾞ
;;;;;2012-10-19 削除	FAR_JSR	#_OVERH_CYC_START,R0			;2012-09-25
	.AENDI

	SUB_END
	M_RTS

;	
;	止まる時に１回通る/止まらないときも

	.ALIGN	4				;
_MOTION_CYCLE_END:
	SUB_START
;	======= 描画用 ====
	MEM1_BIT0_TO_BIT7_ORSET MEM=_DISP_RE_VIEW_FLG,LG=W,BIT=BIT0,WKREG=R1	;
;;;;	FAR_JSR	#_LOT_SIG_SET,R0						;
;;;;	FAR_JSR	#_LOT_SIG_FLG_CLR,R0						;
	FAR_JSR	#_CYCLE_TIME_REFLASH_END,R0					;

;	============================================
	MOV.L	#_CPOS_CTL_MATH,R1		;
	MOV.W	@R1,R0				;
;;[20091007下振子]	TST	#_DMATH_CNTROT,R0		;2002-09-01 回転?
	TST	#(_DMATH_CNTROT+_DMATH_DNDRIV),R0	;2009-10-0_7DMATH_CNTROT,R0		;2002-09-01 回転?
	TST_BIT_OF DAI_CHK03_300

	FAR_JSR	#_DAI_FULL_SCALE_SMP_END,R0	;2003-02-03
	FAR_JSR	#_DAI_MOSTPOS_CMPARE,R0		;

	FAR_JSR	#_KJPHOS_SMPLING_END1,R0	;2004-07-05

DAI_CHK03_300:
	FAR_JSR	#_DBG_END_CNT4,R0

	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
	.IMPORT	_TRD_SIG_SET
	FAR_JSR	#_TRD_SIG_SET,R0			;2006-11-20
	.AENDI

;	------- [2009-10-07下振子]-----
	FAR_JSR	#_DNM_CYCLE_END,R0	;

;	------------- 2007-12-12 ---------------
	FAR_JSR	#_CYCL_DOWN_POS_REF,R0		;


	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
	FAR_JSR	#_OVERH_CYC_END,R0			;2012-09-25
	.AENDI

;	----------- 2014-09-20-----------
	FAR_JSR	#_MOT_REP_CLR,R0

	SUB_END
	M_RTS


;	*******************************************
;	***		2007-12-12		***
;	*******************************************
	.ALIGN	4				;
_CYCL_DOWN_POS_REF:
	SUB_START
;;	MOV.L	#_CLS_RNA_MOST_DOWN_POS,R1	;//ﾌﾙｸﾛｰｽﾞ開始時~終了までの最下死点
;;	MOV.L	@R1,R0				;
	MOV.L	#_SHOT_MOST_DOWN_POSWK,R1	;
	MOV.L	@R1,R0				;
	MOV.L	#_SHOT_MOST_DOWN_POS,R1
	MOV.L	R0,@R1				;
	SUB_END
	M_RTS

;	*******************************************
;	***	どのﾓｰﾄﾞでも1回しかこない	***
;	*******************************************
;	止まるとき（安全一、連続停止時２回通る）
;
	.ALIGN	4				;
_MOTION_CYCLE_ED2:
	SUB_START

;	==========================
	MOV.L	#_CYCL_DSP_CNT_PV,R1	;//非表示ｶｳﾝﾀ 2->1->0(表示)
	MOV.W	@R1,R0			;
	TST	R0,R0			;
	TST_BIT_OF MOTCYC_ED2_050	;
	ADD	#-1,R0			;
	MOV.W	R0,@R1			;
MOTCYC_ED2_050:

	FAR_JSR	#_DBG_END_CNT5,R0

	SUB_END
	M_RTS

	.ALIGN	4				;
_DBG_END_CNT1:
	SUB_START
	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
	MOV.L	#_PVP_A_LOT_CNT1,R1
	.AELSE
	MOV.L	#_PVP_B_LOT_CNT1,R1
	.AENDI
	MOV.W	@R1,R0
	ADD	#1,R0
	MOV.W	R0,@R1	;
	SUB_END
	M_RTS

	.ALIGN	4				;
_DBG_END_CNT2:
	SUB_START
	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
	MOV.L	#_PVP_A_LOT_CNT2,R1
	.AELSE
	MOV.L	#_PVP_B_LOT_CNT2,R1
	.AENDI
	MOV.W	@R1,R0
	ADD	#1,R0
	MOV.W	R0,@R1	;
	SUB_END
	M_RTS

_DBG_END_CNT3:
	SUB_START
	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
	MOV.L	#_PVP_A_LOT_CNT3,R1
	.AELSE
	MOV.L	#_PVP_B_LOT_CNT3,R1
	.AENDI
	MOV.W	@R1,R0
	ADD	#1,R0
	MOV.W	R0,@R1	;
	SUB_END
	M_RTS

_DBG_END_CNT4:
	SUB_START
	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
	MOV.L	#_PVP_A_LOT_CNT4,R1
	.AELSE
	MOV.L	#_PVP_B_LOT_CNT4,R1
	.AENDI
	MOV.W	@R1,R0
	ADD	#1,R0
	MOV.W	R0,@R1	;
	SUB_END
	M_RTS

_DBG_END_CNT5:
	SUB_START
	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
	MOV.L	#_PVP_A_LOT_CNT5,R1
	.AELSE
	MOV.L	#_PVP_B_LOT_CNT5,R1
	MOV.W	@R1,R0
	ADD	#1,R0
	MOV.W	R0,@R1	;
	.AENDI
	SUB_END
	M_RTS





;	***********************************
;	***	200usec --> 2msec 	***
;	***********************************

;	***********************************
;	***	200usec --> 2msec 	***
;	***********************************
	.ALIGN	4				;
_INT_POS_DATA_REF:
	SUB_START
	SUB_END
	M_RTS


;	***********************************
;	***	払い出しカウント	***
;	***********************************
	.EXPORT	_OUT_UP_DN_TOTAL_CNT
	.ALIGN	4				;
_OUT_UP_DN_TOTAL_CNT:
	SUB_START

;;;;;	いらない
;;;;;	-2013-04-14 [１段目停止位置＝２段目停止位置などでﾘｱﾙと払出完了のﾀｲﾐﾝｸﾞ用]---------
;;;;;	FAR_JSR	#_LOD_POS_STS_REG_POR,R0	;
;;;;;	MOV.L	#_PLS_OUT_END_STS,R1		;
;;;;;;	MOV.W	R0,@R1				;BIT2=1 ﾊﾟﾙｽ出力完了
;	----------------------------------------------------









	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_OutcntPS,R6		;R/W 指令ﾊﾟﾙｽｶｳﾝﾀ(残ﾊﾟﾙｽではない)
	MOV.W	@R6,R0							;+/-に関わらず+するｶｳﾝﾀ

;	-----------------2007-11-26 前回と同じならもう一度読み込みを行う----------------
	MOV.L	#_CHK_LSI_LOAD_OUT_CNT,R4				;
	MOV.W	@R4,R1
	MOV.W	R0,@R4
	CMP/EQ	R0,R1
	BF	OUTPLS_CNT_CHK010					;
	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_OutcntPS,R6		;
	MOV.W	@R6,R0							;
OUTPLS_CNT_CHK010:							;



	MOV.W	#H'FF00,R4
	MOV	R0,R2
	AND	R4,R2

	MOV.W	@R6,R1							;
	AND	R4,R1
	CMP/EQ	R1,R2							;桁　FFFF=>0　上位8BITが一致している
	BT	OUTPLS_CNT_CHK020					;
	MOV.W	@R6,R0							;
OUTPLS_CNT_CHK020:							;


	MOV.L	#_POSLSI_CHK_CNT,R1					;
	MOV.W	@R1,R2							;
	MOV.W	R0,@R1							;
	EXTU.W	R2,R2							;
	EXTU.W	R0,R0							;
	SUB	R2,R0							;
	EXTS.W	R0,R0							;
	CMP/PZ	R0							;
	BT	OUTPLS_CNT_CHK050					;
	NEG	R0,R0							;
OUTPLS_CNT_CHK050:							;
	MOV.L	#_POSLSI_CHK_DLT,R1					;変化量 +のみ
	MOV.W	R0,@R1							;
	MOV.L	#_POSLSI_DRIV_SHIN,R4					;
	MOV.W	@R4,R1
	MOV.W	#BIT0,R3						;


	XOR	R5,R5							;
	MOV	R0,R6							;

	TST	R3,R1							;
	TST_BIT_OF OUTPLS_CNT_CHK100					;BIT3=0 "+"
	NEG	R6,R6							;
	CMP/PZ	R6
	BT	OUTPLS_CNT_CHK100					;
	ADD	#-1,R5							;
OUTPLS_CNT_CHK100:							;

;	=== 2003-07-01 1msec差分速度算出用 ==
	MOV.L	#_OUTPLS_DELT,R3			;符号付
	MOV.W	R6,@R3					;

;	=====================================
	PUSH_REG1 R5							;異常測定用
	PUSH_REG1 R6							;
	MOV.L	#_POSLSI_OUTPUT_TOTAL_PLS,R3				;
	MOV.L	@R3,R1							;
	MOV.L	@(4,R3),R2						;
	ADD8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;
	MOV.L	R1,@R3							;
	MOV.L	R2,@(4,R3)						;
	POP_REG1 R6							;
	POP_REG1 R5							;

;	=========	20060919 現在位置管理用	=============
	MOV.L	#_LINK_RL_OBJ_ABSPLS,R3				;
	MOV.L	@R3,R1							;
	MOV.L	@(4,R3),R2						;
	ADD8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;
	MOV.L	R1,@R3							;
	MOV.L	R2,@(4,R3)						;



	SUB_END
	M_RTS

;	*******************************************
;	***					***
;	***					***
;	***		ニアゼロチェック	***
;	***					***
;	*******************************************
;	R0= -1:完了
;
	.ALIGN	4				;
_OPEN_ROT_NEAR1_ZERO_CHK:
	SUB_START
	FAR_JSR	#_INCENC_SV_HENSA_MAKE,R0	;

;	=====2009-10-07　連続のふりこ専用ｲﾝﾎﾟｼﾞｼｮﾝ(h2wはふりこ＋反転)
	MOV.L	#_MODE_SEL,R1			;
	MOV.W	@R1,R0				;
	TST	#_W1CNT,R0			;
	TST_BIT_OF OPEN_ROT_NEAR1_ZR_CK20	;

;	-----2009-10-07 ADD(ふりこの場合の連続ﾓｰﾄﾞのみニアゼロ幅を変える) h2wは反転も------
	MOV.L	#_SET1_OBJARA_INPXPSX,R3		;ふりこ用2007-11-13
	MOV.W	@R3,R4					;
	TST	R4,R4					;
	TST_BIT_OF OPEN_ROT_NEAR1_ZR_CK20		;"0以外"

	MOV.L	#_SETX_POS_CTL_MATH,R1			;
	MOV.W	@R1,R0					;
;;;h2w	TST	#(_DMATH_REVRSE+_DMATH_DNDRIV),R0	;DRIVE MATH 反転,ふりこ	
	TST	#(_DMATH_DNDRIV),R0			;DRIVE MATH ふりこ
	TST_BIT_OF OPEN_ROT_NEAR1_ZR_CK20		;
	M_BRA	OPEN_ROT_NEAR1_ZR_CK40


OPEN_ROT_NEAR1_ZR_CK20:
	MOV.L	#_SET1_OBJARA_INPXPLS,R3	;
	MOV.W	@R3,R4				;
OPEN_ROT_NEAR1_ZR_CK40:				;
	CMP/GE	R2,R4				;R2 =< MAX
	BT	OPEN_ROT_NEAR1_ZR_CK50		;
;	==== ﾆｱｾﾞﾛ待ち======
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POS_CTRL_SQ_STS,LG=W,BIT=BIT0,WKREG=R1 ;//位置決めｽﾃｰﾀｽ
	MEM1_BIT0_TO_BIT7_ANDCLR MEM=_POS_CTRL_SQ_STS,LG=W,BIT=~BIT1,WKREG=R1 ;//位置決めｽﾃｰﾀｽ
;	===============================================
	XOR	R0,R0				;
	M_BRA	OPEN_ROT_NEAR1_ZR_CK100

OPEN_ROT_NEAR1_ZR_CK50:
;	=========[ﾆｱｾﾞﾛ]======================================
	MEM1_BIT0_TO_BIT7_ORSET MEM=_NEAR_IN_FLG,LG=W,BIT=BIT0,WKREG=R1 ;//ﾆｱｾﾞﾛﾗｯﾁ
	MEM1_BIT0_TO_BIT7_ORSET MEM=_DNM_DEBUG_STS1,LG=W,BIT=BIT0,WKREG=R1 ;2012-12-10 DEBUG



	MEM1_BIT0_TO_BIT7_ANDCLR MEM=_POS_CTRL_SQ_STS,LG=W,BIT=~BIT0,WKREG=R1 ;//位置決めｽﾃｰﾀｽ
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POS_CTRL_SQ_STS,LG=W,BIT=BIT1,WKREG=R1 ;//位置決めｽﾃｰﾀｽ
	
;	===============================================
	MOV	#-1,R0				;ANS FFFF SET NEAR-ZERO
OPEN_ROT_NEAR1_ZR_CK100:				;
	SUB_END
	M_RTS

;	*******************************************
;	***					***
;	***	反転の戻り工程だけの		***
;	***		ニアゼロチェック	***
;	***					***
;	*******************************************
;	R0= -1:完了
;	
	.ALIGN	4				;
_OPEN_ROT_NEAR2_ZERO_CHK:
	SUB_START
	FAR_JSR	#_INCENC_SV_HENSA_MAKE,R0	;
	MOV.L	#_SET1_OBJARA_INPXPLS,R3	;
	MOV.W	@R3,R4				;
	MOV.W	#D'1000,R0			;
	ADD	R0,R4				;目標位置+ｲﾝﾎﾟｼﾞｼｮﾝ+1000~-ｲﾝﾎﾟｼﾞｼｮﾝ-1000

	CMP/GE	R2,R4				;R2 =< MAX
	BT	OPEN_ROT_NEAR2_ZR_CK50		;
;	==== ﾆｱｾﾞﾛ待ち======
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POS_CTRL_SQ_STS,LG=W,BIT=BIT0,WKREG=R1 ;//位置決めｽﾃｰﾀｽ
	MEM1_BIT0_TO_BIT7_ANDCLR MEM=_POS_CTRL_SQ_STS,LG=W,BIT=~BIT1,WKREG=R1 ;//位置決めｽﾃｰﾀｽ
;	===============================================
	XOR	R0,R0				;
	M_BRA	OPEN_ROT_NEAR2_ZR_CK100

OPEN_ROT_NEAR2_ZR_CK50:
;	=========[ﾆｱｾﾞﾛ]======================================
	MEM1_BIT0_TO_BIT7_ORSET MEM=_NEAR_IN_FLG,LG=W,BIT=BIT0,WKREG=R1 ;//ﾆｱｾﾞﾛﾗｯﾁ

	MEM1_BIT0_TO_BIT7_ANDCLR MEM=_POS_CTRL_SQ_STS,LG=W,BIT=~BIT0,WKREG=R1 ;//位置決めｽﾃｰﾀｽ
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POS_CTRL_SQ_STS,LG=W,BIT=BIT1,WKREG=R1 ;//位置決めｽﾃｰﾀｽ
	
;	===============================================
	MOV	#-1,R0				;ANS FFFF SET NEAR-ZERO
OPEN_ROT_NEAR2_ZR_CK100:				;
	SUB_END
	M_RTS


;	*******************************************
;	***					***
;	***	カムへステップ完了を教える	***
;	***					***
;	*******************************************
;	ﾀｲﾏ前
	.ALIGN	4				;
_CAM_1STEP_END_SIG1:
	SUB_START
	MOV.L	#_INT_POS_CTL_STEP,R1		;//内部制御工程1~11
	MOV.W	@R1,R0				;ﾀｲﾏLOAD
	SHLL2	R0				;
	MOV.L	#_LONG_BIT_TBL0,R2		;
	ADD	R0,R2				;
	MOV.L	@R2,R0				;
	MOV.L	#_CAM_POS_STEP_END_FLG1,R1	;//各工程の位置決め完了
	MOV.W	R0,@R1				;
	SUB_END
	M_RTS

;	ﾀｲﾏ後
	.ALIGN	4				;
_CAM_1STEP_END_SIG2:
	SUB_START
	MOV.L	#_INT_POS_CTL_STEP,R1		;//内部制御工程1~11
	MOV.W	@R1,R0				;ﾀｲﾏLOAD
	SHLL2	R0				;
	MOV.L	#_LONG_BIT_TBL0,R2		;
	ADD	R0,R2				;
	MOV.L	@R2,R0				;
	MOV.L	#_CAM_POS_STEP_END_FLG2,R1	;//各工程の位置決め完了
	MOV.W	R0,@R1				;
	SUB_END
	M_RTS

;	*******************************************
;	***	ANS R1,R2 |目標-現在|=R2	***
;	***	ANS R0=0 目標>=現在		***
;	*******************************************
;	4BYTE MAX +/ 7FFF,FFFF
	.EXPORT	_INCENC_SV_HENSA_MAKE
	.ALIGN	4				;
_INCENC_SV_HENSA_MAKE:
	SUB_START
	MOV.L	#_LINK_SV_OBJ_ABSPLS,R4					;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	@R4,R1							;
	MOV.L	@(1*4,R4),R2						;目標位置
	MOV.L	#_LINK_PV_ABSPLS,R4					;20060919
	MOV.L	@R4,R5							;
	MOV.L	@(1*4,R4),R6						;現在位置
	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;
	MOV	R1,R0				;
	CMP/PZ	R1				;
	BT	INCENC_SV_HENSA_MK050		;
	NEG1_64	H_REG=R1,L_REG=R2,WKREG=R3	;
INCENC_SV_HENSA_MK050:				;
	TST	R1,R1				;
	TST_BIT_OF INCENC_SV_HENSA_MK100	;8byte
	MOV.L	#H'7FFFFFFF,R2			;
INCENC_SV_HENSA_MK100:				;

	SUB_END
	M_RTS

;	***********************************
;	***	最下死点INITAL		***
;	***********************************
	.ALIGN	4				;
_MOST_DISP_DAT_INI:
	SUB_START
	MOV.L	#_CYCL_START_CNT,R1		;
	MOV.W	@R1,R0				;
	ADD	#1,R0				;
	MOV.W	R0,@R1				;起動回数

;	======== 2007-12-12 ====================
	MOV.L	#_RNA_ABS_POS,R1		;//ﾎﾞﾙｽﾀ面高さ(絶対位置)
	MOV.L	@R1,R2				;
	MOV.L	#_SHOT_MOST_DOWN_POSWK,R1	;
	MOV.L	R2,@R1				;
;	=========================================

;	====== 最下死点処理======
	MOV.L	#_RNA_CTL_POS1,R1		;//制御位置
	MOV.L	@R1,R0				;
	MOV.L	#_CLS_RNA_MOST_DOWN_POS,R1	;//ﾌﾙｸﾛｰｽﾞ開始時~終了までの最下死点
	MOV.L	R0,@R1				;

	MOV.L	#_RNA_LINK_NOWROT_OFSPLS_P,R1	;//余り角度 +ﾃﾞｰﾀ
	MOV.L	@R1,R0				;
	MOV.L	#_CLS_INC_MOST_DOWN_PLS,R1	;//ﾌﾙｸﾛｰｽﾞ開始時~終了までの最下死点
	MOV.L	R0,@R1				;
;	=========================
	SUB_END
	M_RTS

;	***********************************
;	***	最下死点ｻﾝﾌﾟﾘﾝｸﾞ	***
;	***********************************
	.ALIGN	4				;
_MOST_DISP_DAT_SMP:
	SUB_START
;	====== 最下死点処理======
	MOV.L	#_RNA_CTL_POS1,R1		;//制御位置
	MOV.L	@R1,R0				;
	MOV.L	#_CLS_RNA_MOST_DOWN_POS,R1	;//ﾌﾙｸﾛｰｽﾞ開始時~終了までの最下死点
	MOV.L	@R1,R2				;
	CMP/GE	R2,R0				; OLD < NEW(R0) 
	BT	MOST_DISP_DATSMP_050		;
	MOV	R0,R2				;最小値ｻﾝﾌﾟﾘﾝｸﾞ
MOST_DISP_DATSMP_050:				;
	MOV.L	R2,@R1				;

	MOV.L	#_RNA_LINK_NOWROT_OFSPLS_P,R1	;//余り角度 +ﾃﾞｰﾀ
	MOV.L	@R1,R0				;
	MOV.L	#_CLS_INC_MOST_DOWN_PLS,R1	;//ﾌﾙｸﾛｰｽﾞ開始時~終了までの最下死点
	MOV.L	@R1,R2				;
	CMP/GE	R0,R2				;NEW(R0) < OLD
	BT	MOST_DISP_DATSMP_100		;
	MOV	R0,R2				;最大値ｻﾝﾌﾟﾘﾝｸﾞ
MOST_DISP_DATSMP_100:				;
	MOV.L	R2,@R1				;
;	=========================

;	======== 2007-12-12(RNA_ABS_POSの最小値) ======
;	====== 最下死点処理======
	MOV.L	#_RNA_ABS_POS,R1		;//ﾎﾞﾙｽﾀ面高さ(絶対位置)
	MOV.L	@R1,R0				;
	MOV.L	#_SHOT_MOST_DOWN_POSWK,R1	;//
	MOV.L	@R1,R2				;
	CMP/GE	R2,R0				; OLD < NEW(R0) 
	BT	MOST_DISP_DATSMP_150		;
	MOV	R0,R2				;最小値ｻﾝﾌﾟﾘﾝｸﾞ
MOST_DISP_DATSMP_150:				;
	MOV.L	R2,@R1				;
;	=========================================

	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***				***
;	***				***
;	***********************************
	.ALIGN	4				;
_CMP_ERR_STS_REF:
	SUB_START
	SUB_END
	M_RTS


;	***********************************
;	***	R0=0:停止 ELSE 動作	***
;	***********************************
;	== R0=0 停止 R0=FF 動作
;	USED R4,R1,R0
	.IMPORT	_CPUA_PLS_OUTF	;
	.IMPORT	_CPUB_PLS_OUTF	;

	.ALIGN	4				;
_ERR_STOP_MOV_CHK:
	SUB_START
	FAR_JSR	#_LOD_POS_STS_REG,R0		;停止の判断をこれにする
	XOR	R1,R1				;
	TST	#BIT2,R0			;
	TST_BIT_ON ERR_STOP_MOVCK050		;
	ADD	#-1,R1
ERR_STOP_MOVCK050:
	MOV	R1,R0				;
	MOV.L	#_PLS_OUTPUT_FLG,R1		;//0払い出し停止 1払出中
	MOV.W	R0,@R1				;

;	----- 2015-07-14--------
 .AIF	_CB_CPU_SEL EQ	_CB_CPUA	;
	MOV.L	#_CPUA_PLS_OUTF,R1	;
 .AELSE
	MOV.L	#_CPUB_PLS_OUTF,R1	;
 .AENDI
	MOV.W	R0,@R1				;
	SUB_END
	M_RTS

;	***************************************************
;	***						***
;	***						***
;	***						***
;	***						***
;	***		位置決めLSIｱｸｾｽｿﾌﾄ		***
;	***						***
;	***						***
;	***						***
;	***************************************************

;	=== (2003-07-01 履歴用ﾃﾞｰﾀ作成) ======
	.EXPORT	_LOAD_REST_PLS		;残りﾊﾟﾙｽ
	.EXPORT	_LOAD_FREQ_PLS		;設定ﾊﾟﾙｽ
	.EXPORT	_LOAD_NOW_FREQ_PLS	;現在
	.EXPORT	_LOAD_GPOINT_PLS	;

	.EXPORT	_LOAD_SPD_LATE		;
	.EXPORT	_LOAD_ACCS1_LATE	;
	.EXPORT	_LOAD_BASE_FREQ_PLS	;

;	***************************************************
;	***						***
;	***		残りﾊﾟﾙｽREAD			***
;	***		ANS:R0				***
;	***************************************************
;	R0以外破壊しない
;	"残りﾊﾟﾙｽ"
;	減る方向で化けるｹｰｽもある.従って２度読みの古い方側を使用した方が良いか？
;	３度読みでその真ん中は正しい=  >２度読みの古いほうが正しい ==>だめ 
;	１回目が化けて大きくなって２回目が正常なら発生する
;	時間などチェックが必要だ
	.ALIGN	4				;
_LOAD_REST_PLS:
	SUB_START
	PUSH_REG1 R1
	PUSH_REG1 R2
	PUSH_REG1 R3
	PUSH_REG1 R4
	MOV	#D'10,R3					;

LOAD_RESTPLS_LOP:

	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_OutPposL,R1	;R/W 指令ﾊﾟﾙｽ数
	FAR_JSR	#_LSI_LOAD_32BIT_DATA,R0			;
	MOV	R0,R4						;FIRST R0

	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_OutPposL,R1	;R/W 指令ﾊﾟﾙｽ数
	FAR_JSR	#_LSI_LOAD_32BIT_DATA,R0			;
	MOV	R0,R2						;FIRST R0

	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_OutPposL,R1	;R/W 指令ﾊﾟﾙｽ数
	FAR_JSR	#_LSI_LOAD_32BIT_DATA,R0			;

;	R0=<R2=<R4
	CMP/HS	R2,R4						;R2 =< R4
	BF	LOAD_RESTPLS_050				;NO! 失敗(R2>R4)
	CMP/HS	R0,R2						;R0 =< R2
	BF	LOAD_RESTPLS_050				;NO! 失敗(R0>R2)
	M_BRA	LOAD_RESTPLS_END				;R0(NEW)=<R2(MID)=<R4(OLD) R2を信用する

LOAD_RESTPLS_050:						;
	MOV.L	#_LSI_PLSRD_NG_CNT1,R1				;
	MOV.W	@R1,R0						;
	ADD	#1,R0						;
	MOV.W	R0,@R1						;

	ADD	#-1,R3						;
	CMP/PL	R3						;
	BT	LOAD_RESTPLS_LOP				;
;	==== HARD ERR ===
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POS_LSI_ACS_ERR_FLG1,LG=W,BIT=(BIT5+BIT0),WKREG=R1		;R1,R0

;;	MOV	R2,R0						;
;	ANS.R2
LOAD_RESTPLS_END:
	MOV	R2,R0						;(3度読みの真ん中をデータとして使用する)
	POP_REG1 R4
	POP_REG1 R3
	POP_REG1 R2
	POP_REG1 R1

	SUB_END
	M_RTS

;	***************************************************
;	***						***
;	***		設定周波数ﾚｼﾞｽﾀREAD		***
;	***						***
;	***************************************************
;	R0以外破壊しない
	.ALIGN	4				;
_LOAD_FREQ_PLS
	SUB_START

	PUSH_REG1 R1

	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_TopFreqL,R1	;TOP(設定)周波数
	FAR_JSR	#_LSI_LOAD_32BIT_DATA,R0			;

	POP_REG1 R1

	SUB_END
	M_RTS

;	***********************************
;	***	ベース周波数()		***
;	***********************************
	.ALIGN	4				;
_LOAD_BASE_FREQ_PLS:
	SUB_START
	PUSH_REG1 R1

	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_BasFreqL,R1	;BASE(設定)周波数
	FAR_JSR	#_LSI_LOAD_32BIT_DATA,R0			;


	POP_REG1 R1
	SUB_END
	M_RTS
;	***********************************
;	***	加速時間()		***
;	***********************************
	.ALIGN	4				;
_LOAD_ACCS1_LATE:
	SUB_START
	PUSH_REG1 R1


	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_AccLate1,R1	;
	MOV.W	@R1,R0						;

	POP_REG1 R1
	SUB_END
	M_RTS

;	***************************
;	***	LATE()		***
;	***************************
	.ALIGN	4				;
_LOAD_SPD_LATE:
	SUB_START
	PUSH_REG1 R1

	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_SpedLate,R1	;
	MOV.W	@R1,R0						;

	POP_REG1 R1
	SUB_END
	M_RTS



;	***************************************************
;	***						***
;	***		現在周波数ﾚｼﾞｽﾀREAD		***
;	***						***
;	***************************************************
;	R0以外破壊しない
	.ALIGN	4				;
_LOAD_NOW_FREQ_PLS
	SUB_START

	PUSH_REG1 R1

	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_NowFreqL,R1	;R/W 現在周波数
	FAR_JSR	#_LSI_LOAD_32BIT_DATA,R0			;

	POP_REG1 R1
	SUB_END
	M_RTS

;	***************************************************
;	***						***
;	***		減速距離READ			***
;	***						***
;	***************************************************
;	R0以外破壊しない
	.ALIGN	4				;
_LOAD_GPOINT_PLS
	SUB_START
	PUSH_REG1 R1

	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_GNpointL,R1	;R/W 減速点
	FAR_JSR	#_LSI_LOAD_32BIT_DATA,R0			;

	POP_REG1 R1
	SUB_END
	M_RTS

;	***************************************************
;	***						***
;	***		32BITﾚｼﾞｽﾀREAD			***
;	***		Input  R1:ADRESS(DESTROY)	***
;	***		Output R0:data(ﾓﾄﾛｰﾗHEX)	***
;	***************************************************
	.ALIGN	4				;
_LSI_LOAD_32BIT_DATA:
	SUB_START
;;	PLS_READ_LATCH						;2004-02-12
;;	POS_LSI_WORD_DUM_LOD					;CS
;;	MOV.W	@R1+,R0						;LOW WORD
;;	EXTU.W	R0,R0						;
;;
;;	POS_LSI_WORD_DUM_LOD					;CS
;;	MOV.W	@R1,R1						;HIGH WORD
;;	EXTU.W	R1,R1						;
;;	SHLL16	R1
;;	OR	R1,R0						;
;;	MOV.L	#_ACCESS_ERR1+4*4,R1				;4 5/5

	POS_LSI_WORD_DUM_LOD					;CS(A)
	PLS_READ_LATCH						;2004-02-12
	POS_LSI_WORD_DUM_LOD					;CS(B)
	MOV.L	@R1,R0						;LONG
	SWAP.W	R0,R0						;

	SUB_END
	M_RTS


;	*******************************************
;	***	2003-07-01 指令ﾊﾟﾙｽの速度演算	***
;	*******************************************
	.EXPORT	_OUT_PLS_SPD_CALC
	.EXPORT	_ENC_PLS_SPD_CALC
	.ALIGN	4				;
_OUT_PLS_SPD_CALC:
	SUB_START
	MOV.L	#_OUTPLS_DELT,R1			;符号付
	MOV.W	@R1,R2					;
;;	SHLL	R2
;;	SHLL	R2
;;	SHLL	R2
;;	SHLL	R2				;*16

;	=====================================
	MOV.L	#_OUTPLS_SPD_TOTAL,R5		;= R5(ad4)
	MOV.L	#_OUTPLS_SPD_AVL_TOP,R6		;= R6(ad2)
	MOV.L	#_OUTPLS_POINT_SEL,R1		;= R7(dt2)=10
	MOV.W	@R1,R7				;

	MOV.L	#_OUTPLS_SPD_POINT,R8		;= R8(ad2)
	MOV.L	#_OUT_PLS_SPD_DIR,R9		;= R9(ad2) 0pls/s でも -と+がある
	MOV.L	#_OUTPLS_1000MSEC_LAT,R10	;= R10(ad2)
	MOV.L	#_OUT_PLS_SPD,R11		;= R11(ad4)
	MOV.L	#_ABS_OUT_PLS_SPD,R12		;= R12(ad4)
	MOV.L	#_PV_OUT_SPD_PER,R13		;= R13(ad2)
	MOV.L	#_PVC_BRK_OUT_SPD,R14		;= R14(ad2)

	FAR_JSR	#_DELT_POS_SPD_CHG1,R0		;ANS R2 ABS_PLS

	SUB_END
	M_RTS
;	*******************************************
;	***	2003-07-01 PGﾊﾟﾙｽの速度演算	***
;	*******************************************
	.ALIGN	4				;
_ENC_PLS_SPD_CALC:
	SUB_START

;	=== 2003-07-01 1msec差分速度算出用 ==
	MOV.L	#_ENCPLS_DELT,R1;			;符号付
	MOV.W	@R1,R2					;R2(dt2) 
;	=====================================
	MOV.L	#_ENCPLS_SPD_TOTAL,R5			;= R5(ad4)
	MOV.L	#_ENCPLS_SPD_AVL_TOP,R6			;= R6(ad2)
	MOV.L	#_ENCPLS_POINT_SEL,R1			;= R7(dt2)=10
	MOV.W	@R1,R7					;

	MOV.L	#_ENCPLS_SPD_POINT,R8			;= R8(ad2)
	MOV.L	#_ENC_PLS_SPD_DIR,R9			;= R9(ad2) 0pls/s でも -と+がある
	MOV.L	#_ENCPLS_1000MSEC_LAT,R10		;= R10(ad2)
	MOV.L	#_ENC_PLS_SPD,R11			;= R11(ad4)
	MOV.L	#_ABS_ENC_PLS_SPD,R12			;= R12(ad4)
	MOV.L	#_PV_ENC_SPD_PER,R13			;= R13(ad2)
	MOV.L	#_PVC_BRK_ENC_SPD,R14			;= R14(ad2) per
	FAR_JSR	#_DELT_POS_SPD_CHG1,R0			;ANS R2 ABS_PLS

	SUB_END
	M_RTS


;	*******************************************
;	***	2003-07-01 PGﾊﾟﾙｽの速度演算	***
;	*******************************************
	.ALIGN	4				;
_ENC_PLS_SPD_CLR:
	SUB_START

	XOR	R2,R2
	MOV.L	#_ENCPLS_DELT,R1;			;符号付
	MOV.W	R2,@R1					;

	MOV.L	#_ENCPLS_SPD_TOTAL,R5			;= R5(ad4)
	MOV.L	#_ENCPLS_SPD_AVL_TOP,R6			;= R6(ad2)
	MOV.L	#_ENCPLS_POINT_SEL,R1			;= R7(dt2)=10
	MOV.W	@R1,R7					;
	MOV.L	#_ENCPLS_SPD_POINT,R8			;= R8(ad2)
	FAR_JSR	#_DELT_POS_SPD_CLR,R0			;

;;;	MOV.L	#_ENC_PLS_SPD_DIR,R9			;= R9(ad2) 0pls/s でも -と+がある
;;;	MOV.L	#_ENCPLS_1000MSEC_LAT,R10		;= R10(ad2)
	XOR	R0,R0
	MOV.L	#_ENC_PLS_SPD,R11			;= R11(ad4)
	MOV.L	R0,@R11
	MOV.L	#_ABS_ENC_PLS_SPD,R12			;= R12(ad4)
	MOV.L	R0,@R12
	MOV.L	#_PV_ENC_SPD_PER,R13			;= R13(ad2)
	MOV.W	R0,@R13
	MOV.L	#_PVC_BRK_ENC_SPD,R14			;= R14(ad2)
	MOV.W	R0,@R14


	SUB_END
	M_RTS

;	.GLOBAL	_PV_ENC_SPD_PER;//0~100.00%
;	.GLOBAL	_PV_OUT_SPD_PER;//0~100.00%

;_ENCPLS_SPD_TOTAL	= R5(ad4)
;_ENC_PLS_SPD_DIR	= R9(ad2) 0pls/s でも -と+がある
;_ENCPLS_POINT_SEL	= R7(dt2)=10
;_ENCPLS_DELT		= R2(dt2) 
;_ENCPLS_SPD_AVL_TOP	= R6(ad2)
;_ENCPLS_SPD_POINT	= R8(ad2)
;_ENCPLS_1000MSEC_LAT   =R10(ad2)
;_ENC_PLS_SPD		= R11(ad4)
;_ABS_ENC_PLS_SPD	= R12(ad4)
;_PV_ENC_SPD_PER	=R13(ad2)
;_PVC_ENC_SPD_PER	=R14(ad2)MINLIMIT
;R0,R1,R2,R3,R4 WORK

;	***********************************************************
;	***							***
;	***	1msecのﾃﾞｰﾀの移動平均を行う			***
;	***	不感帯がないと停止時はｸﾘｱ処理ばかりはしる	***
;	***	処理の重さだけの話になる			***
;	***	(+/-10pls溜まるまで待つか=>やらない)		***
;	***							***
;	***********************************************************
	.ALIGN	4				;
_DELT_POS_SPD_CHG1:
	SUB_START

	TST	R7,R7			;
	TST_BIT_ON DELT_POS_SPDCG1_020	;
	ADD	#1,R7			;
DELT_POS_SPDCG1_020:			;

	TST	R2,R2			;R2=0
	TST_BIT_OF DELT_POS_SPDCG1_200	;
	MOV.W	@R9,R0			;符号LOAD
	CMP/PZ	R2			;
	BT      DELT_POS_SPDCG1_050     ;"+"
	TST	R0,R0			;
	TST_BIT_ON DELT_POS_SPDCG1_200	;"-" CLR処理不要
	M_BRA	DELT_POS_SPDCG1_100	;前回-で今回+ ｸﾘｱ必要

DELT_POS_SPDCG1_050:
	TST	R0,R0			;
	TST_BIT_OF DELT_POS_SPDCG1_200	;今回も前回も+

;	====== CLR =======
DELT_POS_SPDCG1_100:
	FAR_JSR	#_DELT_POS_SPD_CLR,R0


	NOP				;ﾊﾞﾌｧはｸﾘｱするけど計算は行う

;	====================================
DELT_POS_SPDCG1_200:
	MOV.W	@R8,R0			;POINTER
	SHLL	R0			;2Byte
	ADD	R0,R6			;TOP+POINTER
	MOV.W	@R6,R1			;OLD LOAD
	MOV.W	R2,@R6			;NEW SAVE
	MOV.L	@R5,R3			;TOTAL
	ADD	R2,R3			;
	SUB	R1,R3			;
	MOV.L	R3,@R5			;TOTAL REFLASH
	SHLR	R0			;
	ADD	#1,R0			;
	CMP/HS	R7,R0			;R7(10) =<R0(0~9)
	BF	DELT_POS_SPDCG1_250	;
	XOR	R0,R0			;
DELT_POS_SPDCG1_250:			;
	MOV.W	R0,@R8			;POINTER +1 REFLASH
;	==================================
	MOV.W	@R10,R1			;TOTAL(10msec)*100=PLS/S
	DMULS.L	R1,R3			;total*100=pps
	STS	MACL,R2			;

	MOV.L	R2,@R11			;_ENC_PLS_SPD 符号付 0.1pps??1PPSでしょう。
	TST	R2,R2			;
	TST_BIT_OF DELT_POS_SPDCG1_350	;速度が0なら符号は変えない

	XOR	R0,R0			;
	CMP/PZ	R2			;+?
	BT	DELT_POS_SPDCG1_300	;
	NEG	R2,R2			;
	MOV	#-1,R0			;
DELT_POS_SPDCG1_300:			;
	MOV.W	R0,@R9			;SHIN _ENC_PLS_SPD_DIR
DELT_POS_SPDCG1_350:			;

;	=========================================
	MOV.L	#_WPAR_ZERO_SPD,R1			;
	MOV.W	@R1,R0					;
	CMP/HS	R0,R2					;MIN
	BT	DELT_POS_SPDCG1_380			;
	XOR	R2,R2					;
DELT_POS_SPDCG1_380:					;
	MOV.L	R2,@R12			;_ABS_ENC_PLS_SPD	= R12(ad4)

;	==== 速度換算 ======
;;;2010-10-22	MOV.L	#_LINK_MAX_SPD_PLS,R0			;//ｲﾝｸﾘﾒﾝﾀﾙｴﾝｺｰﾀﾞ換算値　pls/s
	MOV.L	#_SETD_LINK_MAX_SPD_PLS,R0			;//ｲﾝｸﾘﾒﾝﾀﾙｴﾝｺｰﾀﾞ換算値　pls/s[SETD_LINK_MAX_SPD_PLS　ｻｰﾎﾞﾊﾟﾗ]
	MOV.L	@R0,R4						;
	MOV.W	#_SPD_PER_MAX,R1				;100.00per
	FAR_JSR	#_FPU_R2_MUL_R1_DIV_R4,R0			;
	MOV.W	#_SPD_PER_MAX*110/100,R1			;110.00per
	REG_PMAX_MMIN	DATA_REG=R2,MAX_MIN_REG=R1		;R1=10000
	MOV.W	R2,@R13						;_PV_ENC_SPD_PER

;	=========================================
	MOV.L	#_WPAR_BRK_SEL_SPD,R1			;%
	MOV.W	@R1,R0					;
	CMP/HS	R0,R2					;MIN
	BT	DELT_POS_SPDCG1_430			;
	XOR	R2,R2					;
DELT_POS_SPDCG1_430:					;
	MOV.W	R2,@R14					;_PVC_BRK_ENC_SPD

	SUB_END
	M_RTS

;	===== INPUT R5 TOTAL
;	===== INPUT R6 AVL_TOP
;	===== INPUT R7 POINTER MAX
;	===== INPUT R8 POINTER
;	DESTROY R0,R1,R4
;
	.ALIGN	4				;
_DELT_POS_SPD_CLR:
	SUB_START
	XOR	R4,R4			;
	MOV.W	R4,@R8			;POINTER-CLR
	MOV.L	R4,@R5			;TOTAL-CLR

	MOV	R7,R0			;POINTER MAX
	MOV	R7,R1			;
	ADD	#-1,R1			;
	SHLL	R1			;
	ADD	R6,R1			;TOP+MAX

DELT_POS_SPDCG1_150:			;
	MOV.W	R4,@R1			;
	ADD	#-2,R1			;
	ADD	#-1,R0			;
	TST	R0,R0			;
	TST_BIT_ON DELT_POS_SPDCG1_150	;
	SUB_END
	M_RTS

;	***************************
;	***	減速中信号	***
;	***************************
;	TOP周波数ﾚｼﾞｽﾀ >現在周波数ﾚｼﾞｽﾀにて減速中
;	・最終減速かどうかは,最終工程にて判断を行う
;	・停止工程かどうか
;	R0,R1,R2,R3,R4,R6
;	R0=0
	.EXPORT	_GENSOK_SIG_MAK		;
	.ALIGN	4				;
_GENSOK_SIG_MAK:
	SUB_START

	FAR_JSR	#_LOD_POS_STS_REG,R0	;
	TST	#BIT2,R0		;停止中
	TST_BIT_OF GENSOK_SIGMK_050	;
	M_BRA	GENSOK_SIGMK_OF		;YES:STOP NOT 減速中

GENSOK_SIGMK_050:			;
	MOV.L	#_POSCTL_STEP_FLG,R1	;
	MOV.W	@R1,R0			;
	TST	#(BIT2+BIT1),R0		;
	TST_BIT_ON GENSOK_SIGMK_ON	;
	M_BRA	GENSOK_SIGMK_OF		;


GENSOK_SIGMK_ON:			;
	MOV	#BIT0,R0
	M_BRA	GENSOK_SIGMK_END	;
GENSOK_SIGMK_OF:			;
	XOR	R0,R0			;
GENSOK_SIGMK_END:			;
	SUB_END
	M_RTS


	.INCLUDE	"ssa_fulc.inc"		;//ﾌﾙｸﾛｰｽﾞ処理



;	***************************
;	***			***
;	***	異常履歴ﾃﾞｰﾀ	***
;	***			***
;	***************************
	.ALIGN	4				;
_HIST_INFO_DT_IN1:
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R1
	PUSH_REG1 R2

	MOV.L	#_LINK_SV_OBJ_ABSPLS,R1		;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	#_LT_LINK_SV_OBJ_ABSPLS,R2		;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	@R1+,R0					;
	MOV.L	R0,@R2					;
	ADD	#4,R2					;
	MOV.L	@R1+,R0					;
	MOV.L	R0,@R2					;

	MOV.L	#_LINK_PV_ABSPLS,R1		;
	MOV.L	#_LT_INT_LINK_RL_OBJ_ABSPLS,R2		;
	MOV.L	@R1+,R0					;
	MOV.L	R0,@R2					;
	ADD	#4,R2					;
	MOV.L	@R1+,R0					;
	MOV.L	R0,@R2					;

	POP_REG1 R2
	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	異常情報		***
;	***				***
;	***********************************
	.MACRO	DATA_8B_0CHK MEM,ANSBIT
	MOV.L	#\MEM,R1	;
	MOV.L	@R1+,R2			;HIGH
	MOV.L	@R1,R3			;LOW
	XOR	R1,R1			;
	OR	R3,R2			;
	TST	R2,R2			;
	TST_BIT_OF JMP01\@		;ZERO
	MOV.W	#\ANSBIT,R1		;
JMP01\@					;
	.ENDM

	.MACRO	DATA_4B_0CHK MEM,ANSBIT
	MOV.L	#\MEM,R1	;
	MOV.L	@R1+,R2			;HIGH
	XOR	R1,R1			;
	TST	R2,R2			;
	TST_BIT_OF JMP01\@		;ZERO
	MOV.W	#\ANSBIT,R1		;
JMP01\@					;
	.ENDM


;	***************************
;	***	data 記憶	***
;	***************************
	.ALIGN	4				;
_ERR_INFO_DT_IN0:
	SUB_START
	MOV.L	#_PV_POWER_ON_CNT,R1			;
	MOV.W	@R1,R0					;
	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_B01,R1	;POWER
	MOV.W	R0,@R1					;

	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_B02,R1	;TIM
	MOV.W	@R1,R0					;
	ADD	#1,R0					;
	MOV.W	R0,@R1					;
	SUB_END
	M_RTS

	.ALIGN	4				;
_ERR_INFO_DT_IN1:
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R1


	MOV.L	#_ERR_INFO_SAVE_LATCH,R1	;
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_ON ERR_INFO_DTIN1_EXT		;

	MOV.L	#_MODE_SEL,R1	;
	MOV.W	@R1,R0		;
	TST	#_W1SGL,R0	;
	TST_BIT_OF ERR_INFO_DTIN1_EXT

	MOV.L	#_LINK_SV_OBJ_ABSPLS+4,R1		;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	@R1,R0					;
	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_C01,R1	;
	MOV.L	R0,@R1					;

ERR_INFO_DTIN1_EXT:

	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS


;	***************************
;	***	data 記憶	***
;	***************************
;	(data-smp only)
	.ALIGN	4				;
_ERR_INFO_DT_IN2:
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R1
	MOV.L	#_ERR_INFO_SAVE_LATCH,R1	;
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_ON ERR_INFO_DTIN2_EXT		;

	MOV.L	#_LINK_SV_OBJ_ABSPLS+4,R1		;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	@R1,R0					;
	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_C02,R1	;
	MOV.L	R0,@R1					;

	MOV.L	#_LINK_PV_ABSPLS+4,R1		;
	MOV.L	@R1,R0					;
	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_C03,R1	;
	MOV.L	R0,@R1					;

	MOV.L	#_LNGTH_ADD_DATA+4,R1			;
	MOV.L	@R1,R0					;
	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_C04,R1	;
	MOV.L	R0,@R1					;


;	----- 2010-10-25 ---------------
	MOV.L	#_LNGTH_ADD_DATA,R1			;
	MOV.L	@R1,R0					;
	MOV.L	#_CHK_ADD_DATA_LATCH,R1			;
	MOV.L	R0,@R1					;

	MOV.L	#_LNGTH_ADD_DATA+4,R1			;
	MOV.L	@R1,R0					;
	MOV.L	#_CHK_ADD_DATA_LATCH+4,R1		;
	MOV.L	R0,@R1					;






ERR_INFO_DTIN2_EXT

	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS

;	***************************
;	***	data 記憶	***
;	***************************
	.ALIGN	4				;
_ERR_INFO_DT_IN2A:
	SUB_START
	SUB_END
	M_RTS

;	***************************
;	***	data 記憶	***
;	***************************
	.ALIGN	4				;
_ERR_INFO_DT_IN3:
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R1
	MOV.L	#_ERR_INFO_SAVE_LATCH,R1	;
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_ON ERR_INFO_DTIN3_EXT		;

	MOV.L	#_LNGTH_TOTAL_OUTPLS+4,R1		;
	MOV.L	@R1,R0					;
	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_C05,R1	;
	MOV.L	R0,@R1					;

ERR_INFO_DTIN3_EXT

	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS

;	***********************************
;       ***     起動時の残りﾊﾟﾙｽ	***
;	***********************************
	.ALIGN	4				;
_ERR_INFO_DT_IN4:
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R1
	MOV.L	#_ERR_INFO_SAVE_LATCH,R1	;
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_ON ERR_INFO_DTIN4_EXT		;

	MOV.L	#_MODE_SEL,R1	;
	MOV.W	@R1,R0		;
	TST	#_W1SGL,R0	;
	TST_BIT_OF ERR_INFO_DTIN4_EXT

;	==========
	FAR_JSR	#_LOAD_REST_PLS,R0		;残りﾊﾟﾙｽ
	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_C06,R1	;
	MOV.L	R0,@R1					;
	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_C07,R1	;
	MOV.L	R0,@R1					;

ERR_INFO_DTIN4_EXT:
	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS

;	***********************************************************
;	***	TOTAL,ADDが0であること				***
;	***********************************************************
	.ALIGN	4				;
_ERR_INFO_DT_CHK1:
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R1
	PUSH_REG1 R2
	PUSH_REG1 R3

	MOV.L	#_ERR_INFO_SAVE_LATCH,R1	;
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_ON ERR_INFO_DTCHK1_EXT		;

	MOV.L	#_MODE_SEL,R1	;
	MOV.W	@R1,R0		;
	TST	#_W1SGL,R0	;
	TST_BIT_OF ERR_INFO_DTCHK1_EXT

	MOV.L	#_CPOS_CTL_MATH,R0		;
	MOV.W	@R0,R0				;
	TST	#_DMATH_CNTROT,R0		;2002-09-01 回転?
	TST_BIT_OF ERR_INFO_DTCHK1_EXT

;	-------------2011-09-14---------------
	MOV.L	#_BRKTST_INPUT_CMD,R1		;2011-09-14
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;
	TST_BIT_ON ERR_INFO_DTCHK1_EXT		;


	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_A01,R1		;
	MOV.W	@R1,R0						;

	DATA_8B_0CHK MEM=_LNGTH_ADD_DATA,ANSBIT=BIT0		;
	OR	R1,R0						;

	DATA_8B_0CHK MEM=_LNGTH_TOTAL_OUTPLS,ANSBIT=BIT1	;
	OR	R1,R0						;

	DATA_4B_0CHK MEM=_OUTPLS_MOD,ANSBIT=BIT2		;

	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_A01,R1		;
	MOV.W	R0,@R1						;
ERR_INFO_DTCHK1_EXT:

	POP_REG1 R3
	POP_REG1 R2
	POP_REG1 R1
	POP_REG1 R0


	SUB_END
	M_RTS

;	***********************************************************
;	***	TOTAL,ADDが0であること				***
;	***********************************************************
;	SGL
	.ALIGN	4				;
_ERR_INFO_DT_CHK2:
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R1
	PUSH_REG1 R2
	PUSH_REG1 R3



	MOV.L	#_ERR_INFO_SAVE_LATCH,R1	;
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_ON ERR_INFO_DTCHK2_EXT		;

	MOV.L	#_MODE_SEL,R1			;
	MOV.W	@R1,R0				;
	TST	#_W1SGL,R0			;
	TST_BIT_OF ERR_INFO_DTCHK2_EXT		;

	MOV.L	#_CPOS_CTL_MATH,R0		;
	MOV.W	@R0,R0				;
;;;;2010-10-25	TST	#_DMATH_CNTROT,R0		;2002-09-01 回転?
	TST	#(_DMATH_CNTROT+_DMATH_DNDRIV),R0	;2010-10-25 回転+ふりこ
	TST_BIT_OF ERR_INFO_DTCHK2_EXT		;

;	-------------2011-09-14---------------
	MOV.L	#_BRKTST_INPUT_CMD,R1		;2011-09-14
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;
	TST_BIT_ON ERR_INFO_DTCHK2_EXT		;


	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_A02,R1		;
	MOV.W	@R1,R0						;

	DATA_8B_0CHK MEM=_LNGTH_ADD_DATA,ANSBIT=BIT0		;
	OR	R1,R0						;

	DATA_8B_0CHK MEM=_LNGTH_TOTAL_OUTPLS,ANSBIT=BIT1	;
	OR	R1,R0						;

	DATA_4B_0CHK MEM=_OUTPLS_MOD,ANSBIT=BIT2		;

	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_A02,R1		;
	MOV.W	R0,@R1						;

;	==== ADD DATA CHK ===
	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_C04,R1	;ADD_
	MOV.L	@R1,R2					;
	CMP/PZ	R2					;
	BT	ERR_INFO_DTCHK2_050			;
	NEG	R2,R2
ERR_INFO_DTCHK2_050:

	MOV.L	#_LINK_1ROT_PLS,R1			;//1回転ﾊﾟﾙｽ(設定ﾚﾍﾞﾙ)
	MOV.L	@R1,R0					;
	MOV.W	#_PLS_ERR_HABPLS1,R1			;
	ADD	R1,R0					;1ROT-PLS+2000
	CMP/HS	R2,R0					;
	BT	ERR_INFO_DTCHK2_100			;1ROT以下
	MEM1_BIT0_TO_BIT7_ORSET MEM=_WK_ERR_INFO_CPU_TOP+_ERR_INFO_A02,LG=W,BIT=BIT4,WKREG=R1 ;//計算不良
ERR_INFO_DTCHK2_100:

;	=====もう一個チェックが必要[2010-10-26] ふりこ時の対策 化け方が0000,0000,FFF,FFFF[+]====
	MOV.L	#_CHK_ADD_DATA_LATCH,R3		;
	MOV.L	@R3+,R1				;
	MOV.L	@R3,R2				;
	CMP/PZ	R1				;
	BT	ERR_INFO_DTCHK2_150		;
	NEG1_64	H_REG=R1,L_REG=R2,WKREG=R0	;
ERR_INFO_DTCHK2_150:
	TST	R1,R1				;
	TST_BIT_OF ERR_INFO_DTCHK2_200		;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_WK_ERR_INFO_CPU_TOP+_ERR_INFO_A02,LG=W,BIT=BIT4,WKREG=R1 ;//計算不良
	M_BRA	ERR_INFO_DTCHK2_300		;

ERR_INFO_DTCHK2_200:
	MOV.L	#_LINK_1ROT_PLS,R1			;//1回転ﾊﾟﾙｽ(設定ﾚﾍﾞﾙ)
	MOV.L	@R1,R0					;
	MOV.W	#_PLS_ERR_HABPLS1,R1			;
	ADD	R1,R0					;1ROT-PLS+2000
	CMP/HS	R2,R0					;
	BT	ERR_INFO_DTCHK2_300			;1ROT以下
	MEM1_BIT0_TO_BIT7_ORSET MEM=_WK_ERR_INFO_CPU_TOP+_ERR_INFO_A02,LG=W,BIT=BIT4,WKREG=R1 ;//計算不良
ERR_INFO_DTCHK2_300:
	NOP



ERR_INFO_DTCHK2_EXT:


	POP_REG1 R3
	POP_REG1 R2
	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS

;	*******************************************
;	***	CHEAK ﾚｽﾄﾊﾟﾙｽが減ること/	***
;	*******************************************
	.ALIGN	4				;
_ERR_INFO_DT_CHK3:
	SUB_START

	MOV.L	#_ERR_INFO_SAVE_LATCH,R1	;
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_ON ERR_INFO_DTCHK3_EXT			;

	MOV.L	#_MODE_SEL,R1				;
	MOV.W	@R1,R0					;
	TST	#_W1SGL,R0				;
	TST_BIT_OF ERR_INFO_DTCHK3_EXT				;

	MOV.L	#_CPOS_CTL_MATH,R0		;
	MOV.W	@R0,R0				;
	TST	#_DMATH_CNTROT,R0		;2002-09-01 回転?
	TST_BIT_OF ERR_INFO_DTCHK3_EXT				;

;	-------------2011-09-14---------------
	MOV.L	#_BRKTST_INPUT_CMD,R1		;2011-09-14
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;
	TST_BIT_ON ERR_INFO_DTCHK3_EXT		;


	MOV.L	#_ERR_INFO_DLY_TIM,R1				;
	MOV.W	@R1,R0						;
	TST	R0,R0						;
	TST_BIT_OF ERR_INFO_DTCHK3_050				;
	ADD	#-1,R0						;
	MOV.W	R0,@R1						;
	M_BRA	ERR_INFO_DTCHK3_EXT				;(ﾚｽﾄﾊﾟﾙｽが安定しないのでその判断はしない)

ERR_INFO_DTCHK3_050:						;

	FAR_JSR	#_LOAD_REST_PLS,R0				;残りﾊﾟﾙｽ
	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_C07,R1		;
	MOV.L	@R1,R3						;
	MOV.L	R0,@R1						;NOW =< OLD
	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_C08,R1		;
	MOV.L	R3,@R1						;OLD SAVE

	CMP/HS	R0,R3						;
	BT	ERR_INFO_DTCHK3_100				;

	PUSH_REG1 R0						;
	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_B03,R1		;
	MOV.W	@R1,R2						;
	ADD	#1,R2						;
	MOV.W	R2,@R1						;

	SUB	R3,R0						;DELT
	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_B04,R1		;増分
	MOV.W	@R1,R2						;
	CMP/HS	R2,R0						;R2<R0
	BF	ERR_INFO_DTCHK3_060				;NO R2 > R0
	MOV.W	R0,@R1						;MAX REFLASH
ERR_INFO_DTCHK3_060:						;

	MEM1_BIT0_TO_BIT7_ORSET MEM=_WK_ERR_INFO_CPU_TOP+_ERR_INFO_A03,LG=W,BIT=BIT0,WKREG=R1 ;//位置増加

	POP_REG1 R0						;
ERR_INFO_DTCHK3_100:						;

;	==== 起動時のRESETより生のﾊﾟﾙｽは小さいか===
;	R0:読み出したパルス

	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_C06,R1		;
	MOV.L	@R1,R2						;
	ADD	#1,R2						;
	CMP/HS	R0,R2						;
	BT	ERR_INFO_DTCHK3_200				;起動時より増えていない

	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_B05,R1		;
	MOV.W	@R1,R0						;
	ADD	#1,R0						;
	MOV.W	R0,@R1						;

	MEM1_BIT0_TO_BIT7_ORSET MEM=_WK_ERR_INFO_CPU_TOP+_ERR_INFO_A03,LG=W,BIT=BIT1,WKREG=R1 ;//

ERR_INFO_DTCHK3_200:

;	==== 起動時のADDより生ﾊﾟﾙｽは小さいか===
	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_C07,R1		;
	MOV.L	@R1,R2						;

	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_C04,R1	;ADD-PLS
	MOV.L	@R1,R0					;
	CMP/PZ	R0					;
	BT	ERR_INFO_DTCHK3_220			;
	NEG	R0,R0					;
ERR_INFO_DTCHK3_220:					;
	ADD	#1,R0					;
	CMP/HS	R2,R0					;R2<R0
	BT	ERR_INFO_DTCHK3_300			;

	MEM1_BIT0_TO_BIT7_ORSET MEM=_WK_ERR_INFO_CPU_TOP+_ERR_INFO_A03,LG=W,BIT=BIT2,WKREG=R1 ;//

	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_B06,R1		;
	MOV.W	@R1,R0						;
	ADD	#1,R0						;
	MOV.W	R0,@R1						;


ERR_INFO_DTCHK3_300:

;	==== ｱｸｾｽ不正異常 =====
	MOV.W	#D'10,R3		;
	XOR	R2,R2			;
	MOV.L	#_ACCESS_ERR1,R1	;
ERR_INFO_DTCHK3_350:
	MOV.L	@R1+,R0			;
	OR	R0,R2			;
	ADD	#-1,R3			;
	TST	R3,R3			;
	TST_BIT_ON ERR_INFO_DTCHK3_350	;
	TST	R2,R2			;
	TST_BIT_OF ERR_INFO_DTCHK3_380	;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_WK_ERR_INFO_CPU_TOP+_ERR_INFO_A03,LG=W,BIT=BIT3,WKREG=R1 ;//(不正ｱｸｾｽ有り)
ERR_INFO_DTCHK3_380:


;	==== REST PLS ﾁｪｯｸ(別次元かな)====
	FAR_JSR	#_ERR_INFO_DT_CHK3X,R0		;OVER


ERR_INFO_DTCHK3_EXT:

	SUB_END
	M_RTS

;	***************************************************
;	***						***
;	***	目標位置+2000＜現在位置+RESETPULS	***
;	***	注意 REST-PLSは20msec後から読み出す	***
;	***						***
;	***************************************************
	.ALIGN	4				;
_ERR_INFO_DT_CHK3X:
	SUB_START

	MOV.L	#_POSLSI_DRIV_SHIN,R1	;//BIT0
	MOV.W	@R1,R0			;
	TST	#BIT0,R0		;
	TST_BIT_OF ERR_INFO_DTCHK3X_100	;
	M_BRA	ERR_INFO_DTCHK3X_200	;
;	==== 正転運転 =====
ERR_INFO_DTCHK3X_100:
	FAR_JSR	#_LOAD_REST_PLS,R0			;残りﾊﾟﾙｽ R0

	MOV.L	#_LINK_SV_OBJ_ABSPLS,R1			;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	@R1+,R2					;
	MOV.L	@R1,R3					;
	XOR	R1,R1
	MOV.W	#_PLS_ERR_HABPLS1,R4			;2000
	ADD8B DT_REGH=R1,DT_REGL=R4,DT_ANS_REGH=R2,DT_ANS_REGL=R3	;OBJ+2000=R2,R3

;;;	MOV.L	#_LINK_RL_OBJ_ABSPLS,R1					;
	MOV.L	#_LINK_PV_ABSPLS,R1					;20060919
	MOV.L	@R1+,R4							;
	MOV.L	@R1,R5							;
	XOR	R1,R1							;R1,R0(残りﾊﾟﾙｽ)
	ADD8B DT_REGH=R1,DT_REGL=R0,DT_ANS_REGH=R4,DT_ANS_REGL=R5	;PV+REST=R4,R5
	
	SUB8B DT_REGH=R4,DT_REGL=R5,DT_ANS_REGH=R2,DT_ANS_REGL=R3
;	R2,R3 - R4,R5= R2,R3 >=0 THEN NOMAL
	CMP/PZ	R2			;
	BT	ERR_INFO_DTCHK3X_300	;
;	=== "-" ===
	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
	MEM1_BIT0_TO_BIT7_ORSET MEM=_WK_ERR_INFO_CPU_TOP+_ERR_INFO_A03,LG=W,BIT=BIT4,WKREG=R1 ;//OVER-RUN
	.AELSE
	.AENDI
	MOV.L	#_WK_ERR_INFO_CPU_TOP+_ERR_INFO_B07,R1		;
	MOV.W	@R1,R0						;
	ADD	#1,R0						;
	MOV.W	R0,@R1						;

	M_BRA	ERR_INFO_DTCHK3X_300	;
;	==== 逆転運転 =====
ERR_INFO_DTCHK3X_200:
ERR_INFO_DTCHK3X_300:

	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	残りﾊﾟﾙｽﾁｪｯｸ		***
;	***	二重回路		***
;	***				***
;	***********************************
	.MACRO REST_PLSCMP2_ERRCHK1 REG1,REG2,IMD,ERRBIT	;
	XOR	R0,R0						;
	SUB	\REG1,\REG2					;
	CMP/PZ	\REG2						;
	BT	JMP01\@						;DATA=<MAX
	NEG	\REG2,\REG2					;
JMP01\@:							;
	MOV.L	#\IMD,\REG1					;
	CMP/HI	\REG2,\REG1					;REG1<REG2
	BT	JMP02\@						;DATA=<MAX
	MOV.W	#\ERRBIT,R0					;
JMP02\@:							;

	.ENDM

;	---2005-04-14-E(4/18)
	.MACRO REST_PLSCMP2_ERRCHK2 REG1,REG2,IMD,ERRBIT,CNT_ADR,CNT_MAX;
	XOR	R0,R0						;
	SUB	\REG1,\REG2					;
	CMP/PZ	\REG2						;
	BT	JMP01\@						;DATA=<MAX
	NEG	\REG2,\REG2					;
JMP01\@:							;
	MOV.L	#\IMD,\REG1					;
	CMP/HI	\REG2,\REG1					;REG1<REG2
	BT	JMP02\@						;DATA=<MAX
	MOV.L	#\CNT_ADR,\REG1					;
	MOV.W	@\REG1,R0					;CNT+1
	ADD	#1,R0						;
	MOV.W	R0,@\REG1					;
	MOV.W	#\CNT_MAX,\REG1					;
	CMP/HS	\REG1,R0					;MAX =< R0
	BF	JMP03\@						;
	MOV.W	#\ERRBIT,R0					;
	M_BRA	JMP04\@						;ERR
JMP02\@:							;
	XOR	R0,R0						;
	MOV.L	#\CNT_ADR,\REG1					;
	MOV.W	R0,@\REG1					;0CLR + ANS=0
JMP03\@:							;
	XOR	R0,R0						;
JMP04\@:							;
	.ENDM











;	***********************************
;	***	ﾊﾞｯｸｱｯﾌﾟ条件ﾁｪｯｸ	***
;	***	非常停止の中で呼ばれる	***
;	***********************************
	.EXPORT	_ERR_INFO_BAKUP_START



	.ALIGN	4				;
_ERR_INFO_BAKUP_START
	SUB_START
	MOV.L	#_ERR_INFO_SAVE_LATCH,R1	;
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_ON ERR_INFO_BAKUP_ST_END	;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_ERR_INFO_SAVE_LATCH,LG=W,BIT=BIT0,WKREG=R1 ;//SAVE-LATCH
	MEM1_BIT0_TO_BIT7_ORSET MEM=_ERR_INFO_SAVE_FLG,LG=W,BIT=BIT0,WKREG=R1 ;//SAVE-START


ERR_INFO_BAKUP_ST_END
	SUB_END
	M_RTS

	.EXPORT		_ERR_INFO_RST_CLR
	.ALIGN	4				;
_ERR_INFO_RST_CLR:
	SUB_START
	FAR_JSR	#_ERR_INFO_WK_CLR,R0
	
	XOR	R0,R0
	MOV.L	#_ERR_INFO_SAVE_FLG,R1
	MOV.W	R0,@R1				;

	MOV.L	#_ERR_INFO_SAVE_LATCH,R1	;
	MOV.W	R0,@R1				;
	SUB_END
	M_RTS

;	***************************
;	***			***
;	***			***
;	***			***
;	***************************
	.ALIGN	4				;
_ERR_INFO_WK_CLR:
	SUB_START
	XOR	R0,R0
	MOV.L	#_WK_ERR_INFO_CPU_TOP,R1
	MOV.W	#_CB_ERR_INFO_MEM/4,R2		;

ERR_INFO_WKCLR_LOP:
	MOV.L	R0,@R1				;
	ADD	#4,R1				;
	ADD	#-1,R2				;
	TST	R2,R2				;
	TST_BIT_ON ERR_INFO_WKCLR_LOP		;

;	------- 2010-10-25---
	MOV.L	#_CHK_ADD_DATA_LATCH,R1		;
	MOV.L	R0,@R1				;
	ADD	#4,R1				;
	MOV.L	R0,@R1				;

	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	１つだけ		***
;	***	自分の情報を相手に送り	***
;	***	相手の情報を取り込む	***
;	***	ﾃﾞｰﾀｸﾞﾗﾌを作成		***
;	***				***
;	***********************************
	.ALIGN	4				;
_CHG_STEP_INFO_MAKE_STEP_DAT:
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R1
	PUSH_REG1 R2
	PUSH_REG1 R3
	PUSH_REG1 R4
	FAR_JSR	#_LOAD_FREQ_PLS,R0
	MOV.L	#_POSLSI_DRV_FRQ,R1								;
	MOV.W	R0,@R1										;
	MEM_MOV_TO_MEM	_LINK_SV_OBJ_ABSPLS+4		,L	,_eSHi_STEP_SV_PLS	,L,R1,R2,R3	;
	MEM_MOV_TO_MEM	_LINK_PV_ABSPLS+4		,L	,_eSHi_STEP_PV_PLS	,L,R1,R2,R3	;
	MEM_MOV_TO_MEM	_NEW_POSLSI_RESTPLS		,L	,_eSHi_STEP_REST_P	,L,R1,R2,R3	;
	MEM_MOV_TO_MEM	_LNGTH_TOTAL_OUTPLS		,L	,_eSHi_TOTAL_PLS	,L,R1,R2,R3	;
;;	MEM_MOV_TO_MEM	_IN_POS_GPOINT_POS		,L	,_eSHi_ADD_PLS		,L,R1,R2,R3	;

	MEM_MOV_TO_MEM	_POSLSI_DRV_FRQ			,W	,_eSHi_STEP_FRQ		,W,R1,R2,R3	;
	MEM_MOV_TO_MEM	_CPU_CTRL_CLK			,W	,_eSHi_STEP_TIM		,W,R1,R2,R3	;
	MEM_MOV_TO_MEM	_INT_POS_CTL_STEP		,W	,_eSHi_NOW_STEP		,W,R1,R2,R3	;

	FAR_JSR	#_DATA_GRF_CNT_DATA_MAKE,R0
	POP_REG1 R4
	POP_REG1 R3
	POP_REG1 R2
	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS

;	***********************************
;	***	連続の行程切り替わり	***
;	***********************************
;	行程3->1のときの演算前のﾃﾞｰﾀ を4へ
;	ﾓﾆﾀ用
	.ALIGN	4				;
_CHG_STEP_INFO_MAKE_ESTEP_BEFOR
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R1
	PUSH_REG1 R2
	PUSH_REG1 R3
	FAR_JSR	#_LOAD_FREQ_PLS,R0
	MOV.L	#_POSLSI_DRV_FRQ,R1								;
	MOV.W	R0,@R1										;
	MEM_MOV_TO_MEM	_LINK_SV_OBJ_ABSPLS+4		,L	,_eSHi_STEP4_SV_PLS	,L,R1,R2,R3	;
	MEM_MOV_TO_MEM	_LINK_PV_ABSPLS+4		,L	,_eSHi_STEP4_PV_PLS	,L,R1,R2,R3;
	MEM_MOV_TO_MEM	_NEW_POSLSI_RESTPLS		,L	,_eSHi_STEP4_REST_P	,L,R1,R2,R3;
	MEM_MOV_TO_MEM	_POSLSI_DRV_FRQ			,W	,_eSHi_STEP4_FRQ	,W,R1,R2,R3;
	MEM_MOV_TO_MEM	_CPU_CTRL_CLK			,W	,_eSHi_STEP4_TIM	,W,R1,R2,R3;

	POP_REG1 R3
	POP_REG1 R2
	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS

;	行程3->1のときの演算後のﾃﾞｰﾀ を1へ
	.ALIGN	4				;
_CHG_STEP_INFO_MAKE_ESTEP_AFTER
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R1
	PUSH_REG1 R2
	PUSH_REG1 R3
	FAR_JSR	#_LOAD_FREQ_PLS,R0
	MOV.L	#_POSLSI_DRV_FRQ,R1								;
	MOV.W	R0,@R1										;
	MEM_MOV_TO_MEM	_LINK_SV_OBJ_ABSPLS+4		,L	,_eSHi_STEP1_SV_PLS	,L,R1,R2,R3	;
	MEM_MOV_TO_MEM	_LINK_PV_ABSPLS+4	,L	,_eSHi_STEP1_PV_PLS	,L,R1,R2,R3;
	MEM_MOV_TO_MEM	_NEW_POSLSI_RESTPLS		,L	,_eSHi_STEP1_REST_P	,L,R1,R2,R3;
	MEM_MOV_TO_MEM	_POSLSI_DRV_FRQ			,W	,_eSHi_STEP1_FRQ	,W,R1,R2,R3;
	MEM_MOV_TO_MEM	_CPU_CTRL_CLK			,W	,_eSHi_STEP1_TIM	,W,R1,R2,R3;

	POP_REG1 R3
	POP_REG1 R2
	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS


;	***********************************
;	***				***
;	***********************************
	.ALIGN	4				;
_CHG_STEP_INFO_MAKE_STEP_END:
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R1
	MOV.L	#_INT_POS_CTL_STEP,R1		;
	MOV.W	@R1,R0				;
	CMP/EQ	#2,R0				;
	BF	CHG_STEP_INFO_MAKSTP_END_010	;
	FAR_JSR	#_CHG_STEP_INFO_MAKE_1STEP_END,R0
	M_BRA	CHG_STEP_INFO_MAKSTP_END_EXT

CHG_STEP_INFO_MAKSTP_END_010:
	CMP/EQ	#3,R0					;
	BF	CHG_STEP_INFO_MAKSTP_END_020		;
	FAR_JSR	#_CHG_STEP_INFO_MAKE_2STEP_END,R0	;
	M_BRA	CHG_STEP_INFO_MAKSTP_END_EXT		;
CHG_STEP_INFO_MAKSTP_END_020:

CHG_STEP_INFO_MAKSTP_END_EXT:
	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS


;	=== 1->2 1の情報を2へ==
	.ALIGN	4				;
_CHG_STEP_INFO_MAKE_1STEP_END
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R1
	PUSH_REG1 R2
	PUSH_REG1 R3
	FAR_JSR	#_LOAD_FREQ_PLS,R0
	MOV.L	#_POSLSI_DRV_FRQ,R1								;
	MOV.W	R0,@R1										;
	MEM_MOV_TO_MEM	_LINK_SV_OBJ_ABSPLS+4		,L	,_eSHi_STEP2_SV_PLS	,L,R1,R2,R3	;
	MEM_MOV_TO_MEM	_LINK_PV_ABSPLS+4		,L	,_eSHi_STEP2_PV_PLS	,L,R1,R2,R3	;
	MEM_MOV_TO_MEM	_NEW_POSLSI_RESTPLS		,L	,_eSHi_STEP2_REST_P	,L,R1,R2,R3	;
	MEM_MOV_TO_MEM	_POSLSI_DRV_FRQ			,W	,_eSHi_STEP2_FRQ	,W,R1,R2,R3	;
	MEM_MOV_TO_MEM	_CPU_CTRL_CLK			,W	,_eSHi_STEP2_TIM	,W,R1,R2,R3	;
	POP_REG1 R3
	POP_REG1 R2
	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS

;	=== 2->3 3の情報 ==
	.ALIGN	4				;
_CHG_STEP_INFO_MAKE_2STEP_END
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R1
	PUSH_REG1 R2
	PUSH_REG1 R3
	FAR_JSR	#_LOAD_FREQ_PLS,R0
	MOV.L	#_POSLSI_DRV_FRQ,R1								;
	MOV.W	R0,@R1										;
	MEM_MOV_TO_MEM	_LINK_SV_OBJ_ABSPLS+4		,L	,_eSHi_STEP3_SV_PLS	,L,R1,R2,R3	;
	MEM_MOV_TO_MEM	_LINK_PV_ABSPLS+4	,L	,_eSHi_STEP3_PV_PLS	,L,R1,R2,R3	;
	MEM_MOV_TO_MEM	_NEW_POSLSI_RESTPLS		,L	,_eSHi_STEP3_REST_P	,L,R1,R2,R3	;
	MEM_MOV_TO_MEM	_POSLSI_DRV_FRQ			,W	,_eSHi_STEP3_FRQ	,W,R1,R2,R3	;
	MEM_MOV_TO_MEM	_CPU_CTRL_CLK			,W	,_eSHi_STEP3_TIM	,W,R1,R2,R3	;

	POP_REG1 R3
	POP_REG1 R2
	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS



	.EXPORT	_MONI_CHG_PROC1
	.ALIGN	4				;
_MONI_CHG_PROC1:
	SUB_START
;;	MNP_MOV_TO_MEM	_eSHi_STEP1_REST_P	,L,_PVP_MONALM_C01,L,R1,R2,H'3FFFFFF
;;	MNP_MOV_TO_MEM	_eSHi_STEP1_PV_PLS	,L,_PVP_MONALM_C02,L,R1,R2,H'3FFFFFF
;;	MEM_MOV_TO_MEM	_eSHi_STEP1_FRQ		,W,_PVP_MONALM_A01,W,R1,R2,R3;
;;	MEM_MOV_TO_MEM	_eSHi_STEP1_TIM		,W,_PVP_MONALM_A02,W,R1,R2,R3;

	SUB_END
	M_RTS



;	****************************
;	***			****
;	****************************

	.IMPORT	_PVP_MONALM_C01
	.IMPORT	_PVP_MONALM_C02
	.IMPORT	_PVP_MONALM_C03
	.IMPORT	_PVP_MONALM_C04
	.IMPORT	_PVP_MONALM_C05
	.IMPORT	_PVP_MONALM_C06
	.IMPORT	_PVP_MONALM_C07
	.IMPORT	_PVP_MONALM_C08
	.IMPORT	_PVP_MONALM_A01
	.IMPORT	_PVP_MONALM_A02
	.IMPORT	_PVP_MONALM_A03
	.IMPORT	_PVP_MONALM_A04
	.IMPORT	_PVP_MONALM_A05
	.IMPORT	_PVP_MONALM_A06
	.IMPORT	_PVP_MONALM_A07
	.IMPORT	_PVP_MONALM_A08
	.IMPORT	_PVP_MONALM_B01
	.IMPORT	_PVP_MONALM_B02
	.IMPORT	_PVP_MONALM_B03
	.IMPORT	_PVP_MONALM_B04
	.IMPORT	_PVP_MONALM_B05
	.IMPORT	_PVP_MONALM_B06
	.IMPORT	_PVP_MONALM_B07
	.IMPORT	_PVP_MONALM_B08

	.IMPORT	_PVP_MONALM_P01
	.IMPORT	_PVP_MONALM_P02
	.IMPORT	_PVP_MONALM_P03
	.IMPORT	_PVP_MONALM_P04

;	***********************************
;	***	NO.15 ERR情報		***
;	***********************************
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;	.EXPORT	_DBG_DISP_POS_LSI
;;;;;;;;;;;;;;;;;;;	.EXPORT	_DBG_DISP_POS_LSI2
;;;;;;;;;;;;;;;;;;;	.ALIGN	4				;
;;;;;;;;;;;;;;;;;;;_DBG_DISP_POS_LSI:
;;;;;;;;;;;;;;;;;;;	SUB_START
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;	=========== A01~A08 =======
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_POS_LSI_ACS_ERR_INF1,W		,_PVP_MONALM_A01,W,R1,R2,R3;SQ222
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_POS_CALC_ERR_INF1,W		,_PVP_MONALM_A02,W,R1,R2,R3;SQ222
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_LSI_PLSCLR_RETRY_CNT1,W	,_PVP_MONALM_A03,W,R1,R2,R3;ﾘｾｯﾄ失敗
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_LSI_PLSSET_RETRY_CNT1,W	,_PVP_MONALM_A04,W,R1,R2,R3;ﾍﾞﾘﾌｧｲ
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_LSI_PLSCMP_RETRY_CNT1,W	,_PVP_MONALM_A05,W,R1,R2,R3;二重回路のﾘﾄﾗｲ
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_LSI_PLSCLR_NG_CNT1,L		,_PVP_MONALM_A06,W,R1,R2,R3;ﾘｾｯﾄｺﾏﾝﾄﾞ MISS
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_LSI_PLSSET_NG_CNT2,L		,_PVP_MONALM_A07,W,R1,R2,R3;-500ﾊﾟﾙｽ  
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_LSI_PLSSET_NG_CNT3,L		,_PVP_MONALM_A08,W,R1,R2,R3;+500ﾊﾟﾙｽ  
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;	=========== B01~B08 =======
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_LSI_PLSRD_NG_CNT1,W		,_PVP_MONALM_B01,W,R1,R2,R3	;
;;;;;;;;;;;;;;;;;;;	XOR	R0,R0
;;;;;;;;;;;;;;;;;;;	REG_MOV_TO_MEM	DST_ADR=_PVP_MONALM_B02		,L1=W,DT_REG=R0,WKREG1=R1	;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_LSI_PLSCLR_NG_CNT2,L		,_PVP_MONALM_B03,W,R1,R2,R3;ﾘｾｯﾄ失敗　TOTAL
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_LSI_PLSSET_NG_CNT1,L		,_PVP_MONALM_B04,W,R1,R2,R3;ﾍﾞﾘﾌｧｲ失敗 TOTAL
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_LSI_PLSCMP_NG_CNT1,W		,_PVP_MONALM_B05,W,R1,R2,R3;二重回路 TOTAL
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_LSI_PLSCLR_AC_CNT1,L		,_PVP_MONALM_B06,W,R1,R2,R3;起動正常回数
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_LSI_PLSSET_AC_CNT2,L		,_PVP_MONALM_B07,W,R1,R2,R3;残り演算正常回数
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_LSI_PLSCMP_AC_CNT1,W		,_PVP_MONALM_B08,W,R1,R2,R3;回路正常回数
;;;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_LSI_PLSSET_AC_CNT1,L		,_PVP_MONALM_B08,W,R1,R2,R3;(NO/USE)
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;	=========== C01~C08 =======
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_SH4_LNGH_ADD_SR,L		,_PVP_MONALM_C01,L,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_SH2_LNGH_ADD_SR,L		,_PVP_MONALM_C02,L,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_SH4_REST_PLS_SR,L		,_PVP_MONALM_C03,L,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_SH2_REST_PLS_SR,L		,_PVP_MONALM_C04,L,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_SH4_REST_PLS_RL,L		,_PVP_MONALM_C05,L,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_SH2_REST_PLS_RL,L		,_PVP_MONALM_C06,L,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;040304
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_LSI_CMPCPUAB_POS_RL,L		,_PVP_MONALM_C07,L,R1,R2,R3	;残りﾊﾟﾙｽの差,ABS
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_LSI_CMPCPUAB_POSMAX,L		,_PVP_MONALM_C08,L,R1,R2,R3	;残りﾊﾟﾙｽの差,+側だけ
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;	SUB_END
;;;;;;;;;;;;;;;;;;;	M_RTS

;;;;;;;;;;;;;;;;;;;;	***********************************
;;;;;;;;;;;;;;;;;;;;	***	NO.16 ERR情報		***
;;;;;;;;;;;;;;;;;;;;	***********************************
;;;;;;;;;;;;;;;;;;;	.ALIGN	4				;
;;;;;;;;;;;;;;;;;;;_DBG_DISP_POS_LSI2:
;;;;;;;;;;;;;;;;;;;	SUB_START
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_CtrlReg,R1		;
;;;;;;;;;;;;;;;;;;;;;;	MOV.W	@R1,R0						;
;;;;;;;;;;;;;;;;;;;;;;	MOV.L	#_POS_CTRL_WORD_DAT,R1				;
;;;;;;;;;;;;;;;;;;;;;;	MOV.W	R0,@R1						;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;	=========== A01~A08 =======
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_POS_CALC_ERR_INF1,W		,_PVP_MONALM_A01,W,R1,R2,R3;SQ222
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_POS_CALC_ERR_INF2,W		,_PVP_MONALM_A02,W,R1,R2,R3;SQ222(詳細)
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_POS_CTRL_WORD_DAT,W		,_PVP_MONALM_A03,W,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_CMP2_ACC_TOTAL_NG_CNT,W	,_PVP_MONALM_A04,W,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_CMP2_BAS_TOTAL_NG_CNT,W	,_PVP_MONALM_A05,W,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_CMP2_TOP_TOTAL_NG_CNT,W	,_PVP_MONALM_A06,W,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_CMP2_NOW_TOTAL_NG_CNT,W	,_PVP_MONALM_A07,W,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_CMP2_LAT_TOTAL_NG_CNT,W	,_PVP_MONALM_A08,W,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;	=========== B01~B08 =======
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_SH4_PLSI_ACCS,W		,_PVP_MONALM_B05,W,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_SH2_PLSI_ACCS,W		,_PVP_MONALM_B06,W,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_SH4_PLSI_LATE,W		,_PVP_MONALM_B07,W,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_SH2_PLSI_LATE,W		,_PVP_MONALM_B08,W,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;	=========== C01~C08 =======
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_SH4_BAS_FRQ_SV,L		,_PVP_MONALM_C01,L,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_SH2_BAS_FRQ_SV,L		,_PVP_MONALM_C02,L,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_SH4_TOP_FRQ_SV,L		,_PVP_MONALM_C03,L,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_SH2_TOP_FRQ_SV,L		,_PVP_MONALM_C04,L,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_SH4_NOW_FRQ_PV,L		,_PVP_MONALM_C05,L,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_SH2_NOW_FRQ_PV,L		,_PVP_MONALM_C06,L,R1,R2,R3;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_FREQ_SV_SPD,L			,_PVP_MONALM_C07,L,R1,R2,R3;設定周波数(MEM)
;;;;;;;;;;;;;;;;;;;	MEM_MOV_TO_MEM	_FREQ_PLSI_MAX_FRQ,L		,_PVP_MONALM_C08,L,R1,R2,R3;最大周波数
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;	SUB_END
;;;;;;;;;;;;;;;;;;;	M_RTS
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;
;	***********************************
;	***				***
;	***	調査機能		***
;	***				***
;	***********************************
;
;	=== 2004-03-04===
;	EMG,EXQ
	.ALIGN	4				;
_LSI_REST_PLS_CHK_STOP_CLR:
	SUB_START


	XOR	R0,R0
	REG_MOV_TO_MEM	DST_ADR=_LSI_PLSCMP_RETRY_CNT1	,L1=W,DT_REG=R0,WKREG1=R1	;

	REG_MOV_TO_MEM	DST_ADR=_eSHi_LOT_CNT_A		,L1=W,DT_REG=R0,WKREG1=R1	;上記のﾃﾞｰﾀ書き込み時の回転ロット数
	REG_MOV_TO_MEM	DST_ADR=_eSHi_LOT_STEP_A	,L1=W,DT_REG=R0,WKREG1=R1	;上記のﾃﾞｰﾀ書き込み時のｽﾃｯﾌﾟ数
	REG_MOV_TO_MEM	DST_ADR=_eSHi_REST_SR_HF	,L1=W,DT_REG=R0,WKREG1=R1	;ﾊﾝﾄﾞｼｪｲｸﾌﾗｸﾞ SH4=>SH2 書いたぞ!起動時移動量
	REG_MOV_TO_MEM	DST_ADR=_eSHi_REST_RL_HF	,L1=W,DT_REG=R0,WKREG1=R1	;ﾊﾝﾄﾞｼｪｲｸﾌﾗｸﾞ SH4=>SH2 書いたぞ!残りﾊﾟﾙｽ

	REG_MOV_TO_MEM	DST_ADR=_CPUy_RESTPLS_LTFLG	,L1=W,DT_REG=R0,WKREG1=R1	;2004-04-12

	SUB_END
	M_RTS

;	=== 2004-03-04===
	.ALIGN	4				;
_LSI_REST_PLS_CHK_START_CLR:
	SUB_START

	XOR	R0,R0
	REG_MOV_TO_MEM	DST_ADR=_LSI_PLSCMP_AC_CNT1	,L1=W,DT_REG=R0,WKREG1=R1	;回路正常回数
	REG_MOV_TO_MEM	DST_ADR=_LSI_PLSSET_AC_CNT2	,L1=L,DT_REG=R0,WKREG1=R1	;残り演算正常回数

	REG_MOV_TO_MEM	DST_ADR=_LSI_CMPCPUAB_POS_RL	,L1=L,DT_REG=R0,WKREG1=R1	;残りﾊﾟﾙｽの差,+/-
	REG_MOV_TO_MEM	DST_ADR=_LSI_CMPCPUAB_POSMAX	,L1=L,DT_REG=R0,WKREG1=R1	;残りﾊﾟﾙｽの差 MAX

;	==== 上は表示を見やすくするため１サイクルデータにする====

	XOR	R0,R0
	REG_MOV_TO_MEM	DST_ADR=_LSI_PLSCMP_RETRY_CNT1	,L1=W,DT_REG=R0,WKREG1=R1	;

	XOR	R0,R0
	REG_MOV_TO_MEM	DST_ADR=_eSHi_LOT_CNT_A		,L1=W,DT_REG=R0,WKREG1=R1	;上記のﾃﾞｰﾀ書き込み時の回転ロット数
	REG_MOV_TO_MEM	DST_ADR=_eSHi_LOT_STEP_A	,L1=W,DT_REG=R0,WKREG1=R1	;上記のﾃﾞｰﾀ書き込み時のｽﾃｯﾌﾟ数
	REG_MOV_TO_MEM	DST_ADR=_eSHi_REST_SR_HF	,L1=W,DT_REG=R0,WKREG1=R1	;ﾊﾝﾄﾞｼｪｲｸﾌﾗｸﾞ SH4=>SH2 書いたぞ!起動時移動量
	REG_MOV_TO_MEM	DST_ADR=_eSHi_REST_RL_HF	,L1=W,DT_REG=R0,WKREG1=R1	;ﾊﾝﾄﾞｼｪｲｸﾌﾗｸﾞ SH4=>SH2 書いたぞ!残りﾊﾟﾙｽ

	REG_MOV_TO_MEM	DST_ADR=_eSHi_LNGH_ADD_SR	,L1=L,DT_REG=R0,WKREG1=R1	;安全一行程,一行程 起動時移動量
	REG_MOV_TO_MEM	DST_ADR=_eSHi_REST_PLS_SR	,L1=L,DT_REG=R0,WKREG1=R1	;安全一行程,一行程 起動時残ﾊﾟﾙｽ
	REG_MOV_TO_MEM	DST_ADR=_eSHi_REST_PLS_RL	,L1=L,DT_REG=R0,WKREG1=R1	;安全一行程,一行程 REAL-TIME残ﾊﾟﾙｽ

	XOR	R0,R0
	REG_MOV_TO_MEM	DST_ADR=_CMP2_BAS_NG_CNT	,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_CMP2_TOP_NG_CNT	,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_CMP2_LAT_NG_CNT	,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_CMP2_ACC_NG_CNT	,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_CMP2_NOW_NG_CNT	,L1=W,DT_REG=R0,WKREG1=R1	;


	FAR_JSR	#_CNT_REST_CHK_CLR,R0		;

;	======= 連続のチェック ======
	XOR	R0,R0
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP1_SV_PLS	,L1=L,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP2_SV_PLS	,L1=L,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP3_SV_PLS	,L1=L,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP4_SV_PLS	,L1=L,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP5_SV_PLS	,L1=L,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP1_REST_P	,L1=L,DT_REG=R0,WKREG1=R1	;(1->2の演算前の残り)
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP2_REST_P	,L1=L,DT_REG=R0,WKREG1=R1	;(2->3)
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP3_REST_P	,L1=L,DT_REG=R0,WKREG1=R1	;(3->1)
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP4_REST_P	,L1=L,DT_REG=R0,WKREG1=R1	;(3->1)
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP5_REST_P	,L1=L,DT_REG=R0,WKREG1=R1	;(3->1)
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP1_PV_PLS	,L1=L,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP2_PV_PLS	,L1=L,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP3_PV_PLS	,L1=L,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP4_PV_PLS	,L1=L,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP5_PV_PLS	,L1=L,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP1_FRQ		,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP2_FRQ		,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP3_FRQ		,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP4_FRQ		,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP5_FRQ		,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP1_TIM		,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP2_TIM		,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP3_TIM		,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP4_TIM		,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_STEP5_TIM		,L1=W,DT_REG=R0,WKREG1=R1	;

	REG_MOV_TO_MEM	DST_ADR=_CNT_GRF_POINT		,L1=W,DT_REG=R0,WKREG1=R1	;

	SUB_END
	M_RTS

;	***************************************************
;	***						***
;	***		連続残りﾊﾟﾙｽ修正		***
;	***						***
;	***************************************************
	.ALIGN	4				;
_CNT_REST_CHK_CLR:
	SUB_START
	XOR	R0,R0
	REG_MOV_TO_MEM	DST_ADR=_eSHi_CNT_REST_PLS	,L1=L,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_eSHi_CNT_REST_HF	,L1=W,DT_REG=R0,WKREG1=R1	;

	REG_MOV_TO_MEM	DST_ADR=_CNT_SYNC_HOS_DAT1	,L1=L,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_CNT_SYNC_HOS_DAT2	,L1=L,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_CNT_SYNC_HOS_FLAG	,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_CNT_SYNC_CHK_CNT2	,L1=W,DT_REG=R0,WKREG1=R1	;

	REG_MOV_TO_MEM	DST_ADR=_CNT_SYNC_STS_FLG	,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_CNT_SYNC_ERR_FLG	,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_CNT_PLSOUT_STOP_CNT	,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_CNT_SYNC_HOS_CNT1	,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_CPUy_RESTPLS_LTFLG	,L1=W,DT_REG=R0,WKREG1=R1	;2004-04-12



	SUB_END
	M_RTS




	.EXPORT	_EXQ_STOP_LEV_POS_CLR		;
	.ALIGN	4				;
_EXQ_STOP_LEV_POS_CLR:
	SUB_START
	XOR	R0,R0
	REG_MOV_TO_MEM	DST_ADR=_eSHi_CNT_REST_HF	,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_CNT_SYNC_HOS_FLAG	,L1=W,DT_REG=R0,WKREG1=R1	;

;	===== 2005-04-14-E(4/18) ===
	FAR_JSR	#_SGL_CMP_ERR_DT_CLR,R0

	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	連続時の補正ﾃﾞｰﾀ	***
;	***	(CPU-Bのみ)		***
;	***********************************
	.ALIGN	4				;
_CNT_HOS_DT_MAK:
	SUB_START
;	CCSのみCALL
	SUB_END
	M_RTS


;	***************************
;	***	修正機能	***
;	***************************
	.ALIGN	4				;
_CNT_SYNC_HOS_CALC
	SUB_START
;	CCSのみCALL
	SUB_END
	M_RTS




;	***************************************************
;	***						***
;	***	回転・連続・ALLVﾓｰﾄﾞ時の減速補正	***
;	***						***
;	***************************************************

;	***************************************************
;	***	急停止・異常時				***
;	***************************************************
	.EXPORT	_GPOSIN_HOS_RESET
	.ALIGN	4				;
_GPOSIN_HOS_RESET:
	SUB_START
	SUB_END
	M_RTS

;	***************************************************
;	***	運転開始時				***
;	***************************************************
	.ALIGN	4				;
_GPOSIN_HOS_DRV_INI:
	SUB_START
	SUB_END
	M_RTS


;	***********************************
;	***	演算			***
;	***********************************
;	(1)減速距離+5を基準値とする
;	(2)+1/-1以内になるまで補正する
;	(3)記憶値から100ﾊﾟﾙｽ以上離れたら再度記憶しなおす
	.ALIGN	4				;
_GPOINT_HOS_CALC:
	SUB_START
	SUB_END
	M_RTS

	




	.EXPORT	_DEBUG_SIGNAL_OFF
	.ALIGN	4				;
_DEBUG_SIGNAL_OFF:
	SUB_START
	DEBUG_LSI_ACS_OF2_BIT BITDT=BIT2		;VERIFAY ERR(OFFない)
	DEBUG_LSI_ACS_OF2_BIT BITDT=BIT6		;RETRY ERR
	SUB_END
	M_RTS

;	***************************************************************************
;	***									***
;	***	工程を自分が切り替えた時点の自分のデータと相手のデータを収集	***
;	***	モニタ専用							***
;	***************************************************************************
_CNT_GRF_MAX		.EQU	200	;MAX 500

_CNT_GRF_1BLOCK		.EQU	64		;64byte
_CGRF_iSTEP_SV_PLS		.EQU	0
_CGRF_iSTEP_PV_PLS		.EQU	4
_CGRF_iSTEP_REST		.EQU	8
_CGRF_iTOTAL_PLS		.EQU	12
_CGRF_iADD_PLS			.EQU	16
_CGRF_GENSOK_LNG1		.EQU	20
_CGRF_iSTEP_FRQ			.EQU	24
_CGRF_iSTEP_TIM			.EQU	26
_CGRF_iNOW_STEP			.EQU	28
_CGRF_SYNC_STS			.EQU	30
_CGRF_SYNC_ERR			.EQU	32

_CGRF_ySTEP_SV_PLS		.EQU	36
_CGRF_ySTEP_PV_PLS		.EQU	40
_CGRF_ySTEP_REST		.EQU	44
_CGRF_yTOTAL_PLS		.EQU	48
_CGRF_yADD_PLS			.EQU	52
_CGRF_ySTEP_FRQ			.EQU	56
_CGRF_ySTEP_TIM			.EQU	60
_CGRF_yNOW_STEP			.EQU	62


	.MACRO	MEM_MOV2B_GBR	MEM,GBROFS,WKREG1
	MOV.L	#\MEM,\WKREG1		;
	MOV.W	@\WKREG1,R0		;
	MOV.W	R0,@(\GBROFS,GBR)	;
	.ENDM

	.MACRO	MEM_MOV4B_GBR	MEM,GBROFS,WKREG1
	MOV.L	#\MEM,\WKREG1		;
	MOV.W	@\WKREG1+,R0		;
	MOV.W	R0,@(\GBROFS,GBR)	;
	MOV.W	@\WKREG1,R0		;
	MOV.W	R0,@(\GBROFS+2,GBR)	;
	.ENDM

	.MACRO	GBR_MOV2B_MEM	MEM,GBROFS,WKREG1
	MOV.W	@(\GBROFS,GBR),R0	;
	MOV.L	#\MEM,\WKREG1		;
	MOV.W	R0,@\WKREG1		;
	.ENDM

	.MACRO	GBR_MOV4B_MEM	MEM,GBROFS,WKREG1
	MOV.W	@(\GBROFS,GBR),R0	;
	MOV.L	#\MEM,\WKREG1		;
	MOV.W	R0,@\WKREG1		;
	MOV.W	@(\GBROFS+2,GBR),R0	;
	ADD	#2,\WKREG1		;
	MOV.W	R0,@\WKREG1		;
	.ENDM
	.MACRO	GBR_MOV4B_MEM_ALMT	MEM,GBROFS,WKREG1,WKREG2
	MOV.W	@(\GBROFS,GBR),R0	;
	MOV.W	#H'3FF,\WKREG2		;
	AND	\WKREG2,R0		;
	
	MOV.L	#\MEM,\WKREG1		;
	MOV.W	R0,@\WKREG1		;
	MOV.W	@(\GBROFS+2,GBR),R0	;
	ADD	#2,\WKREG1		;
	MOV.W	R0,@\WKREG1		;
	.ENDM

;	===== EMG にも呼ばれる======
	.EXPORT	_DATA_GRF_CNT_DATA_MAKE	
	.ALIGN	4				;
_DATA_GRF_CNT_DATA_MAKE:
	SUB_START
	SUB_END
	M_RTS


	.INCLUDE "ssa_disp.inc"		;ﾃﾞﾊﾞｯｸﾓﾆﾀ

;	***************************
;	***			***
;	***************************
	.EXPORT	_HENSA_DAT_MONI_MAK
	.ALIGN	4				;
_HENSA_DAT_MONI_MAK:
	SUB_START

;	===== 遅れ分払い出したことにする====
	MOV.L	#_LINK_SV_OBJ_ABSPLS,R3					;
	MOV.L	@R3,R1							;
	MOV.L	@(4,R3),R2						;

	MOV.L	#_LINK_PV_ABSPLS,R0				;
	MOV.L	@R0,R5							;
	MOV.L	@(4,R0),R6						;

	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;

	MOV.L	#_SV_CONST_SUB_PV,R0					;
	CMP/PZ	R2
	BT	HENSA_DAT_MONMK_050					;
	NEG	R2,R2
HENSA_DAT_MONMK_050:
	MOV.L	R2,@R0							;SV(CONST)-PV=

;	===== 遅れ分払い出したことにする====
	MOV.L	#_LINK_SV_OBJ_ABSPLS,R3					;
	MOV.L	@R3,R1							;
	MOV.L	@(4,R3),R2						;SV-REST-PLS

	MOV.L	#_POSLSI_CHK_RESTPLS,R1					;
	MOV.L	@R1,R6							;
	XOR	R5,R5							;
	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;
	CMP/PZ	R2
	BT	HENSA_DAT_MONMK_100					;
	NEG	R2,R2
HENSA_DAT_MONMK_100:

	MOV.L	#_SV_REAL_SUB_PV,R0
	MOV.L	R2,@R0

	SUB_END
	M_RTS



;//	===================================================
;//	===	対策ソフト部分 2005-04-14-E(4/18)	===
;//	===================================================
	.EXPORT	_SGL_CMP_ERR_DT_CLR
	.ALIGN	4				;
_SGL_CMP_ERR_DT_CLR:
	SUB_START
	XOR	R0,R0
	REG_MOV_TO_MEM	DST_ADR=_CMP_LNGTH_AD_ERR_CNT		,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_CMP_RESTP_SR_ERR_CNT		,L1=W,DT_REG=R0,WKREG1=R1	;
	SUB_END
	M_RTS

	.INCLUDE	"ssa_cntc.inc"		;//2004-12-15


;	***********************************
;	***				***
;	***	2006-05-09		***
;	***				***
;	***********************************
	.EXPORT	_SELF_POS_START_WORK_CLR
	.ALIGN	4				;
_SELF_POS_START_WORK_CLR:
	SUB_START
	FAR_JSR	#_POS_LSI_WORK_STOP_CLR,R0	;
	FAR_JSR	#_POS_LSI_WORK_STOP2,R0
	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	2006-07-28		***
;	***				***
;	***********************************
	.ALIGN	4				;
_POS_CALC_MISS0:
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R1
	MEM1_BIT0_TO_BIT7_ORSET MEM=_CALC_MISS_FLG1,LG=W,BIT=BIT0,WKREG=R1	;
	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS

	.ALIGN	4				;
_POS_CALC_MISS1:
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R1
	MEM1_BIT0_TO_BIT7_ORSET MEM=_CALC_MISS_FLG1,LG=W,BIT=BIT1,WKREG=R1	;
	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS

	.ALIGN	4				;
_POS_CALC_MISS2:
	SUB_START
	PUSH_REG1 R0
	PUSH_REG1 R1
	MEM1_BIT0_TO_BIT7_ORSET MEM=_CALC_MISS_FLG1,LG=W,BIT=BIT2,WKREG=R1	;
	POP_REG1 R1
	POP_REG1 R0
	SUB_END

	M_RTS
;	===================================================================
;	====								===
;	====								===
;	====								===
;	====		2006-09-19オーバライド周波数対応		===
;	====								===
;	====								===
;	====								===
;	====	<1>:基本は指令パルスに対しての制御とする		===
;	====	<2>:位置の切り替えは指令パルスで行なう			===
;	====	<3>:減速の補正は行なわない				===
;	====	<4>:残りパルスの補正は行なうがとりあえずなし/ありも可能	===
;	====	<5>:ﾆｱｾﾞﾛは実測						===
;	====								===
;	====								===
;	===================================================================




;	***************************************************
;	***						***
;	***	SEQからのｵｰﾊﾞﾗｲﾄﾞﾃﾞｰﾀの取り込み		***
;	***						***
;	***************************************************
	.ALIGN	4				;
_OVER_LIDE_SEQREF:
	SUB_START

	MOV.L	#_CB_SEQ_CB_COM346,R1								;
	MOV.W	@R1,R0										;
	MOV	R0,R5										;
	TST	#BIT7,R0									;
	TST_BIT_ON OVER_LIDE_SQRF100								;	

	MOV.L	#_OVER_RIDE_LATE_FLG,R1		;
	MOV.W	@R1,R0				;
	TST	#BIT1,R0			;
	TST_BIT_OF OVER_LIDE_SQRF300		;
	MEM1_BIT0_TO_BIT7_ANDCLR MEM=_OVER_RIDE_LATE_FLG,LG=W,BIT=~BIT1,WKREG=R1		;//
	MEM1_BIT0_F_ADCLR MEM=(_SQ_CBWK_TOP+_WKSQCB230),LG=W,BIT=(~BIT7),WKRG1=R1,WKRG2=R4	;
	M_BRA	OVER_LIDE_SQRF300								;


;	--- REQ ON(ON EDGE 取込)--------
OVER_LIDE_SQRF100:
	MOV.L	#_OVER_RIDE_LATE_FLG,R1					;
	MOV.W	@R1,R0							;
	TST	#BIT1,R0						;
	TST_BIT_ON OVER_LIDE_SQRF300					;

	MOV.L	#_CB_SEQ_CB_COM346,R1					;//20030524
	MOV.W	@R1,R0							;T-LINK=>OVER-RIDE
	MOV.W	#(BIT6+BIT5+BIT4+BIT3+BIT2+BIT1+BIT0),R4		;
	AND	R4,R0							;
	MOV.L	#_OVER_RIDE_LATE_REQ,R1					;//1~127% OVER-RIDE無効時100%
	MOV.W	R0,@R1							;
;	------------ ANS MAKE ----------------------
	MOV.L	#_OVER_RIDE_LATE_ANS,R4						;//1~127% OVER-RIDE無効時100%
	MOV.W	R0,@R4								;
	MOV.L	#_SQ_CBWK_TOP+_WKSQCB230,R3					;
	MOV.W	@R3,R2								;
	MOV.L	#_OVER_RIDE_LATE_ANS,R4						;//1~127% OVER-RIDE無効時100%
	MOV.W	@R4,R0								;
	OR	#BIT7,R0							;ANS+ACK
	MOV.W	#H'FF00,R1							;
	AND	R1,R2								;
	NOT	R1,R1								;
	AND	R1,R0								;
	OR	R0,R2								;
	MOV.W	R2,@R3								;

	MOV.L	#_OVER_RIDE_LATE_ANS,R4						;//1~127% OVER-RIDE無効時100%
	MOV.W	@R4,R0								;
	TST	R0,R0								;
	TST_BIT_ON OVER_LIDE_SQRF220						;
	MOV	#1,R0								;
OVER_LIDE_SQRF220:
	MOV.L	#_SET_SEQ_SPD_OVRLIDE,R1					;
	MOV.W	R0,@R1								;
	MOV.L	#_SET_SEQ_ACC_OVRLIDE,R1					;
	MOV.W	R0,@R1

	MEM1_BIT0_TO_BIT7_ORSET MEM=_OVER_RIDE_LATE_FLG,LG=W,BIT=BIT1,WKREG=R4	;

OVER_LIDE_SQRF300:
	SUB_END
	M_RTS




;	***********************************
;	***				***
;	***	EMG時初期値にする	***
;	***				***
;	***********************************
	.ALIGN	4				;
_OVERLID_DEF_SET:
	SUB_START
	FAR_JSR	#_OVERLID_SEQ_DEF_SET,R0
	FAR_JSR	#_OVERLID_GMN_DEF_SET,R0
	FAR_JSR	#_OVERLID_CTL_DEF_SET,R0
	SUB_END
	M_RTS

	.ALIGN	4				;
_OVERLID_SEQ_DEF_SET:
	SUB_START
	MOV.W	#_OVRLIDE_LATE_MAX,R2						;
	REG_MOV_TO_MEM	DST_ADR=_SET_SEQ_SPD_OVRLIDE,L1=W,DT_REG=R2,WKREG1=R1
	REG_MOV_TO_MEM	DST_ADR=_SET_SEQ_ACC_OVRLIDE,L1=W,DT_REG=R2,WKREG1=R1
	SUB_END
	M_RTS

	.ALIGN	4				;
_OVERLID_GMN_DEF_SET:
	SUB_START
	MOV.W	#_OVRLIDE_LATE_MAX,R2						;
	REG_MOV_TO_MEM	DST_ADR=_SET_GMN_SPD_OVRLIDE,L1=W,DT_REG=R2,WKREG1=R1
	REG_MOV_TO_MEM	DST_ADR=_SET_GMN_ACC_OVRLIDE,L1=W,DT_REG=R2,WKREG1=R1
	SUB_END
	M_RTS

	.ALIGN	4				;
_OVERLID_CTL_DEF_SET:
	SUB_START
	MOV.W	#_OVRLIDE_LATE_MAX,R2						;
	REG_MOV_TO_MEM	DST_ADR=_SET_SPD_OVRLIDE,L1=W,DT_REG=R2,WKREG1=R1
	REG_MOV_TO_MEM	DST_ADR=_SET_ACC_OVRLIDE,L1=W,DT_REG=R2,WKREG1=R1	;

	REG_MOV_TO_MEM	DST_ADR=_POSCTL_OVER_SPD_LAT,L1=W,DT_REG=R2,WKREG1=R1
	REG_MOV_TO_MEM	DST_ADR=_POSCTL_OVER_ACC_LAT,L1=W,DT_REG=R2,WKREG1=R1	;
	SUB_END
	M_RTS


;	***********************************
;	***				***
;	***	2006-07-28		***
;	***	画面ｵｰﾊﾞﾗｲﾄﾞ		***
;	***				***
;	***********************************
;------2013-02-08 ---
	.IMPORT	_SVP_OVERLIDE_COF

	.ALIGN	4				;
_GAMEN_OVER_RIDE:
	SUB_START

;------2013-02-08 ---
	MOV.L	#_SVP_OVERLIDE_COF,R1		;
	MOV.W	@R1,R2				;
	MOV.L	#_SET1_OVERLIDE_COF,R1		;
	MOV.W	R2,@R1				;
;	----------------------------


	MOV.L	#_SET1_OVERLIDE_COF,R1						;
	MOV.W	@R1,R2								;
	TST	R2,R2								;
	TST_BIT_ON GAMEN_OVRIDE_100						;
	MOV.W	#1,R2								;
GAMEN_OVRIDE_100:								;
	REG_MOV_TO_MEM	DST_ADR=_SET_GMN_SPD_OVRLIDE,L1=W,DT_REG=R2,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_SET_GMN_ACC_OVRLIDE,L1=W,DT_REG=R2,WKREG1=R1	;
	SUB_END
	M_RTS

;	***************************************************
;	***						***
;	***						***
;	***						***
;	***************************************************
	.ALIGN	4				;
_SET_OVER_RIDE:
	SUB_START
	MOV.L	#_MODE_SEL,R1							;
	MOV.W	@R1,R0								;
	TST	#_W1CNT+_W1SGL+_W1INC+_W1OPT,R0					;
	TST_BIT_OF SET_OVERID500						;

	MOV.L	#_OVERLIDE_DT_SEL,R1						;画面ｵｰﾊﾞﾗｲﾄﾞ有効
	MOV.W	@R1,R0								;
	CMP/EQ	#1,R0								;
	BF	SET_OVERID200							;
;	------ 画面ﾃﾞｰﾀ有効--------
	MEM_MOV_TO_MEM	_SET_GMN_SPD_OVRLIDE,W,_SET_SPD_OVRLIDE,W,R1,R2,R3	;
	MEM_MOV_TO_MEM	_SET_GMN_ACC_OVRLIDE,W,_SET_ACC_OVRLIDE,W,R1,R2,R3	;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_OVER_RIDE_USEFUL,LG=W,BIT=BIT0,WKREG=R4	;
	MEM1_BIT0_TO_BIT7_ANDCLR MEM=_OVER_RIDE_USEFUL,LG=W,BIT=~BIT1,WKREG=R4	;
	M_BRA	SET_OVERID900	

SET_OVERID200:
	MEM1_BIT0_TO_BIT7_ANDCLR MEM=_OVER_RIDE_USEFUL,LG=W,BIT=~BIT0,WKREG=R4	;

;	===========================
;	===	ｼｰｹﾝｽ		===
;	===========================
	MOV.L	#_CB_SEQ_CB_COM346,R1						;
	MOV.W	@R1,R3								;
	MOV.W	#BIT15,R4							;
	TST	R4,R3								;
	TST_BIT_OF SET_OVERID500
	MEM_MOV_TO_MEM	_SET_SEQ_SPD_OVRLIDE,W,_SET_SPD_OVRLIDE,W,R1,R2,R3	;
	MEM_MOV_TO_MEM	_SET_SEQ_ACC_OVRLIDE,W,_SET_ACC_OVRLIDE,W,R1,R2,R3	;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_OVER_RIDE_USEFUL,LG=W,BIT=BIT1,WKREG=R4	;
	M_BRA	SET_OVERID900							;

SET_OVERID500:
	MOV.W	#_OVRLIDE_LATE_MAX,R2						;
	REG_MOV_TO_MEM	DST_ADR=_SET_SPD_OVRLIDE,L1=W,DT_REG=R2,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_SET_ACC_OVRLIDE,L1=W,DT_REG=R2,WKREG1=R1	;
	MEM1_BIT0_TO_BIT7_ANDCLR MEM=_OVER_RIDE_USEFUL,LG=W,BIT=~BIT1,WKREG=R4	;

	MEM1_BIT0_TO_BIT7_ANDCLR MEM=_OVER_RIDE_USEFUL,LG=W,BIT=~(BIT1+BIT0),WKREG=R4	;

SET_OVERID900:

	SUB_END
	M_RTS




;	***********************************************************
;	***							***
;	***							***
;	***			化石				***
;	***							***
;	***							***
;	***********************************************************
















;	***********************************************************
;	***							***
;	***							***
;	***							***
;	***		その他からのＣＡＬＬ			***
;	***							***
;	***							***
;	***							***
;	***********************************************************
;	*******************************************
;	***					***
;	***		運転釦ON起動時		***
;	***					***
;	*******************************************
	.EXPORT	_OVER_RID_UPDN_LAT_DTMK
	.ALIGN	4				;
_OVER_RID_UPDN_LAT_DTMK:
	SUB_START
	MOV.L	#_OVER_UPDN_DBGCNT,R1
	MOV.W	@R1,R0
	ADD	#1,R0
	MOV.W	R0,@R1				;
	FAR_JSR	#_SET_OVER_RIDE,R0		;起動時

	FAR_JSR	#_OVERRIDE_CALC_LATE_SEL,R0	;
	FAR_JSR	#_OVERRIDE_CALC_SPED_SEL,R0	;

;	--------- ﾌﾞﾚｰｷ異常ﾃﾞｰﾀ1　ｵｰﾊﾞﾗｲﾄﾞにも対応しておく----
	FAR_JSR	#_ACCBRK1_SV_MAKE,R0		;
	FAR_JSR	#_ACCBRK2_SV_MAKE,R0		;

	SUB_END
	M_RTS


;	*******************************************
;	***					***
;	***					***
;	***	起動時及び１回転毎		***
;	***					***
;	***					***
;	*******************************************
	.ALIGN	4				;
_OVERRIDE_CALC_LATE_SEL:							;
	SUB_START								;

	MEM_MOV_TO_MEM	_SET_ACC_OVRLIDE,W,_POSCTL_OVER_ACC_LAT,W,R1,R2,R3	;%
	FAR_JSR	#_ACCLAT1_SV_MAK_OVR,R0						;
	FAR_JSR	#_ACCBRK1_SV_MAK_OVR,R0						;

	SUB_END
	M_RTS

	.ALIGN	4				;
_OVERRIDE_CALC_SPED_SEL:						;
	SUB_START							;

	MEM_MOV_TO_MEM	_SET_SPD_OVRLIDE,W,_POSCTL_OVER_SPD_LAT,W,R1,R2,R3	;

	SUB_END
	M_RTS










;	*******************************************
;	***					***
;	***	Input  R1:時間			***
;	***	Output R1:時間×100/OVER	***
;	***					***
;	*******************************************
;	===================
;	==== 2005-01-17 ===
	.EXPORT	_OVER_RIDE_ERR_TIMCHG
	.ALIGN	4				;
_OVER_RIDE_ERR_TIMCHG:
	SUB_START
	PUSH_REG1 R2

	MOV	R1,R2						;R1-->R2

	MOV.L	#_OVER_RIDE_USEFUL,R1				;
	MOV.W	@R1,R0						;
	TST	#BIT0,R0					;
	TST_BIT_OF OVER_RIDE_ERRTIMCHG_100

	MOV.L	#_POSCTL_OVER_ACC_LAT,R0			;ｵｰﾊﾞﾗｲﾄﾞ%
	MOV.W	@R0,R4						;

;	============ 2005-04-06(距離一定) =========
								;
	FAR_JSR	#_OVRLIDE_LATE_MULDIV,R0			;
								;
;	===========================================

OVER_RIDE_ERRTIMCHG_100						;
	MOV	R2,R1						;

	POP_REG1 R2						;ANS:R1
	SUB_END
	M_RTS


;	*******************************************
;	***					***
;	***	時間の次元			***
;	***	2005-01-17			***
;	***	Input R2	ANS R2		***
;	*******************************************
;	R0,R2 DESTROY 
;	ANS:R2:_POS_LSI_ACCLT1
;	(R2)data * 100/SV
;	BREAK ERR用
	.ALIGN	4				;
_OVER_RID_UPDN_LAT_CALC:
	SUB_START

	SUB_END
	M_RTS


;	===================================================================
;	====								===
;	====								===
;	====								===
;	====		2006-09-19オーバライド周波数対応		===
;	====								===
;	====								===
;	====								===
;	====	<1>:基本は指令パルスに対しての制御とする		===
;	====	<2>:位置の切り替えは指令パルスで行なう			===
;	====	<3>:減速の補正は行なわない				===
;	====	<4>:残りパルスの補正は行なうがとりあえずなし/ありも可能	===
;	====	<5>:ﾆｱｾﾞﾛは実測						===
;	====								===
;	====								===
;	===================================================================

	.EXPORT	_PRESET_PV_ABS_TO_OBJ
_PRESET_PV_ABS_TO_OBJ:
	SUB_START
	MOV.L	#_ERR_FIRST_ST,R1
	MOV.W	@R1,R0
	TST	#BIT0,R0
	TST_BIT_ON PRESET_PVABSTOOBJ_100

	FAR_JSR	#_SET_PV_ABS_TO_OBJ,R0						;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_ERR_FIRST_ST,LG=W,BIT=BIT0,WKREG=R1	;
	M_BRA	PRESET_PVABSTOOBJ_EXT						;

PRESET_PVABSTOOBJ_100:
	.AIF	_CB_CPU_SEL EQ	_CB_CPUA

	.AELSE

	FAR_JSR	#_CPUB_GET_CPUA_OBJPOS,R0

	.AENDI


PRESET_PVABSTOOBJ_EXT:
	SUB_END
	M_RTS


	.EXPORT	_PRESET_PV_FLGCLR
_PRESET_PV_FLGCLR
	SUB_START
	XOR	R0,R0
	MOV.L	#_ERR_FIRST_ST,R1	;
	MOV.W	R0,@R1			;

	SUB_END
	M_RTS




_CPUB_GET_CPUA_OBJPOS
	SUB_START

;;;;;;;;;;2015-04-08 全ﾓｰﾄﾞ対象
;;;;;;;;;;	MOV.L	#_MODE_SEL,R1				;
;;;;;;;;;;	MOV.W	@R1,R0					;
;;;;;;;;;;	TST	#_W1CNT+_W1SGL,R0		;
;;;;;;;;;;	TST_BIT_OF CPUB_GET_OBJPOS_EXT			;


	MOV.L	#_SH_POSCTL_RL_ABSPLS,R4		;[CPUAのﾃﾞｰﾀをCPUB側で使用する2014-11-07]
	MOV.L	@(0,R4),R1				;
	MOV.L	@(4,R4),R2				;

	MOV.L	@(0,R4),R5				;
	MOV.L	@(4,R4),R6				;
	SUB	R1,R5
	SUB	R2,R6					;
	OR	R5,R6					;
	TST	R6,R6					;
	TST_BIT_OF CPUB_GET_OBJPOS_100			;8ﾊﾞｲﾄｱｸｾｽ中の問題

	MOV.L	@(0,R4),R1				;
	MOV.L	@(4,R4),R2				;


CPUB_GET_OBJPOS_100
	MOV.L	#_LINK_RL_OBJ_ABSPLS,R4			;//ﾘｱﾙﾀｲﾑ目標絶対位置(ﾊﾞｯｸﾗｯｼなし)
	MOV.L	R1,@(0,R4)
	MOV.L	R2,@(4,R4)

CPUB_GET_OBJPOS_EXT

	SUB_END
	M_RTS


;	*******************************************
;	***					***
;	***	2006-09-19			***
;	***					***
;	***	起動または異常時の位置あわせ	***
;	***					***
;	*******************************************
	.ALIGN	4				;
_SET_PV_ABS_TO_OBJ:
	SUB_START
	PUSH_REG1 R0				;
	PUSH_REG1 R1
	PUSH_REG1 R2
	PUSH_REG1 R4
	
;	----------------------------------------------
;;;;;;;	MOV.L	#_POS_HOLD_RDY_EXITF,R1		;//しょうがない
;;;;;;;	MOV.W	@R1,R0				;
;;;;;;;	MOV.L	#_POS_HOLD_RDY_EXITF2,R1	;//しょうがない
;;;;;;;	MOV.W	@R1,R2				;
;;;;;;;	OR	R2,R0
;;;;;;;	TST	#BIT0,R0			;
;;;;;;;	TST_BIT_ON SETPVABSTOOBJ_EXT

	MOV.L	#_LINK_PV_ABSPLS,R4		;
	MOV.L	@R4+,R1					;
	MOV.L	@R4,R2					;
	MOV.L	#_LINK_RL_OBJ_ABSPLS,R4			;//ﾘｱﾙﾀｲﾑ目標絶対位置(ﾊﾞｯｸﾗｯｼなし)
	MOV.L	R1,@(0,R4)
	MOV.L	R2,@(4,R4)

;;;;;;;SETPVABSTOOBJ_EXT:

	POP_REG1 R4
	POP_REG1 R2
	POP_REG1 R1
	POP_REG1 R0
	SUB_END
	M_RTS
;	*******************************************
;	***					***
;	***	2006-09-19			***
;	***					***
;	***	ﾊﾟﾙｽ管理			***
;	***	(位置決め部分での処理)		***
;	***					***
;	*******************************************
;	*******************************************
;	***					***
;	***					***
;	***		演算INI			***
;	***					***
;	***					***
;	***					***
;	*******************************************
	.ALIGN	4				;
_PLS_LSI_CTL_INI:
	SUB_START



	SUB_END
	M_RTS


;	*******************************************
;	***					***
;	***					***
;	***		演算END			***
;	***		どうするか？		***
;	***					***
;	***					***
;	*******************************************
	.ALIGN	4				;
_PLS_LSI_SPEED_OFF:
	SUB_START

	FAR_JSR	#_PLS_LSI_STOP_END,R0						;

	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	SPD * OVER LIMIT-->SPD	***
;	***				***
;	***********************************
;	input R2 output R2
_OVER_LIDE_SPD_CALC
	SUB_START
	MOV.L	#_POSCTL_OVER_SPD_LAT,R3		;
	MOV.W	@R3,R1					;
	MOV.W	#_OVRLIDE_LATE_MAX,R4			;100
	FAR_JSR	#_FPU_R2_MUL_R1_DIV_R4,R0		;
	MOV.L	#_POSCTL_SV_OFS_SPD,R1			;//自起動 PLS/S
	MOV.L	@R1,R3					;
	CMP/GE	R3,R2					;
	BT	OVER_LIDE_SPDCAL100			;
	MOV	R3,R2					;
OVER_LIDE_SPDCAL100
	
	SUB_END
	M_RTS


;	***********************************************************


;	***********************************
;	***				***
;	***	上限リミット		***
;	***	2013-02-15		***
;	***********************************
;	input R2[PLS/S] output R2[PLS/S]
;	
_SPD_UPLIMT_CALC
	SUB_START
	MOV.L	#_UPLIMIT_START_F,R1	;//BIT0:寸動からの指令
	MOV.W	@R1,R0			;
	TST	R0,R0			;
	TST_BIT_OF SPD_UPLIMT_CALEND	;LIMITしない

	MOV.L	#_UPLIMIT_SV_SPD,R1	;
	MOV.L	@R1,R3			;
	CMP/GE	R2,R3			;R2=< R3
	BT	SPD_UPLIMT_CALEND	;
	MOV	R3,R2			;UP LIMIT
SPD_UPLIMT_CALEND			;
	SUB_END
	M_RTS

;	***********************************************************
;	***							***
;	***	減速すべき距離か（現在の速度で停止可能かどうか）***
;	***	位置決め部演算					***
;	***********************************************************
;	Input 	R1,R2:残り距離 +/-
;		R11
;		R12
;


	.ALIGN	4				;
_CMP_POSLSI_CTLGENSOK:
	SUB_START
;	----------- 減速演算 Ｖ×Ｖ ＝  ２×α×Ｓ + β*β---------------
	MOV.L	#_POSCTL_SV_PLS,R4					;SV
	MOV.L	@(0,R4),R1						;
	MOV.L	@(4,R4),R2						;

;	---------------リアルタイム目標位置-----------
	MOV.L	#_POSCTL_RL_PLS,R4					;RL
	MOV.L	@(0,R4),R5						;
	MOV.L	@(4,R4),R6						;
	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;目標-実測

	MOV.L	#_POSLSI_DRIV_SHIN,R4					;
	MOV.W	@R4,R0							;
	TST	#BIT0,R0						;
	TST_BIT_OF CMP_PLSLSI_CTLCAL_200					;正転
	NEG1_64	H_REG=R1,L_REG=R2,WKREG=R0				;|R1,R2|
CMP_PLSLSI_CTLCAL_200:							;


	MOV.L	#_POSCTL_RL_SPD,R4					;
	MOV.L	@R4,R9							;

	MOV.L	#_POSCTL_SV_OFS_SPD,R4					;
	MOV.L	@R4,R10							;

	MOV.L	#_POSCTL_SV_DN_ACC,R4					;500,000/1000
	MOV.L	@R4,R11							;

	FAR_JSR	#_CMP_SPD_REST_PLSCHKCOM,R0				;

	SUB_END
	M_RTS


;	***********************************************************
;	***							***
;	***	減速すべき距離か（現在の速度で停止可能かどうか）***
;	***	連続切り替え条件演算				***
;	***********************************************************
;	Input 	R1,R2:残り距離 +/-
;		R11
;		R12
;
	.ALIGN	4				;
_CMP_CNT_CTLGENSOK:
	SUB_START
;	----------- 減速演算 Ｖ×Ｖ ＝  ２×α×Ｓ + β*β---------------
	MOV.L	#_LINK_SV_OBJ_ABSPLS,R4					;LINKX_SV_OBJ_ABSPLSの場合があるかも
	MOV.L	@R4+,R1							;
	MOV.L	@R4,R2							;

	MOV.L	#_CONT_STOP_END_SUBPLS,R4				;
	MOV.L	@R4,R4							;
	XOR	R3,R3							;3FFF,FFFF以下
	MOV.W	#_PROC_2MS_PLS,R0					;
	ADD	R0,R4							;R3,R4
	SUB8B DT_REGH=R3,DT_REGL=R4,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;目標-DT = 目標'

;	---------------リアルタイム目標位置-----------
	MOV.L	#_POSCTL_RL_PLS,R4					;RL
	MOV.L	@(0,R4),R5						;
	MOV.L	@(4,R4),R6						;
	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;目標-実測

	MOV.L	#_POSLSI_DRIV_SHIN,R4					;
	MOV.W	@R4,R0							;
	TST	#BIT0,R0						;
	TST_BIT_OF CMP_CNT_CTLCAL_200					;正転
	NEG1_64	H_REG=R1,L_REG=R2,WKREG=R0				;|R1,R2|
CMP_CNT_CTLCAL_200:							;

	MOV.L	#_POSCTL_RL_SPD,R4					;
	MOV.L	@R4,R9							;

	MOV.L	#_POSCTL_SV_OFS_SPD,R4					;
	MOV.L	@R4,R10							;

	MOV.L	#_POSCTL_SV_DN_ACC,R4					;500,000/1000
	MOV.L	@R4,R11							;

	FAR_JSR	#_CMP_SPD_REST_PLSCHKCOM,R0				;
	SUB_END
	M_RTS

;	***********************************************************
;	***							***
;	***	減速すべき距離か（現在の速度で停止可能かどうか）***
;	***	ブレーキ異常条件演算				***
;	***********************************************************
;	Input 	R1,R2:残り距離 +/-
;		R11
;		R12
;
	.EXPORT	_CMP_BRK2_CTLGENSOK
	.ALIGN	4				;
_CMP_BRK2_CTLGENSOK:
	SUB_START
;	----------- 減速演算 Ｖ×Ｖ ＝  ２×α×Ｓ + β*β---------------
	MOV.L	#_LINK_SV_OBJ_ABSPLS,R4					;LINKX_SV_OBJ_ABSPLSの場合があるかも
	MOV.L	@R4+,R1							;
	MOV.L	@R4,R2							;


;	---------------実測目標位置-----------
	MOV.L	#_LINK_PV_ABSPLS,R4		;
	MOV.L	@(0,R4),R5						;
	MOV.L	@(4,R4),R6						;
	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;目標-実測

	MOV.L	#_POSLSI_DRIV_SHIN,R4					;
	MOV.W	@R4,R0							;
	TST	#BIT0,R0						;
	TST_BIT_OF CMP_BRK2_CTLCAL_200					;正転
	NEG1_64	H_REG=R1,L_REG=R2,WKREG=R0				;|R1,R2|
CMP_BRK2_CTLCAL_200:							;
	MOV.L	#_ABS_ENC_PLS_SPD,R4					;実測
	MOV.L	@R4,R9							;

	MOV.L	#_POSCTL_SV_OFS_SPD,R4					;
	MOV.L	@R4,R10							;

	MOV.L	#_BRK2_SV_DN_ACC,R4					;500,000/1000
	MOV.L	@R4,R11							;

	FAR_JSR	#_CMP_SPD_REST_PLSCHKCOM,R0				;
	SUB_END
	M_RTS






;	*******************************************
;	***					***
;	***	一旦停止			***
;	***					***
;	*******************************************
	.ALIGN	4				;
	.EXPORT	_CMP_HOLD_CTLGENSOK
_CMP_HOLD_CTLGENSOK:
	SUB_START
;	----------- 減速演算 Ｖ×Ｖ ＝  ２×α×Ｓ + β*β---------------
;;;input	MOV.L	#_POSCTL_SV_PLS,R4					;SV
;;;	MOV.L	@(0,R4),R1						;
;;;	MOV.L	@(4,R4),R2						;

;	---------------リアルタイム目標位置-----------
	MOV.L	#_POSCTL_RL_PLS,R4					;RL
	MOV.L	@(0,R4),R5						;
	MOV.L	@(4,R4),R6						;
	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;目標-実測

	MOV.L	#_POSLSI_DRIV_SHIN,R4					;
	MOV.W	@R4,R0							;
	TST	#BIT0,R0						;
	TST_BIT_OF CMP_HOLD_CTL200					;正転
	NEG1_64	H_REG=R1,L_REG=R2,WKREG=R0				;|R1,R2|
CMP_HOLD_CTL200:							;

	MOV.L	#_POSCTL_RL_SPD,R4					;
	MOV.L	@R4,R9							;

	MOV.L	#_POSCTL_SV_OFS_SPD,R4					;
	MOV.L	@R4,R10							;

;;;;	MOV.L	#_POSCTL_SV_DN_ACC,R4					;500,000/1000
;;;;	MOV.L	@R4,R11							;

	MOV.L	#_POSHLD_SET_DN_ACC,R4					;500,000/1000
	MOV.L	@R4,R11							;

	FAR_JSR	#_CMP_SPD_REST_PLSCHKCOM,R0				;

	SUB_END
	M_RTS



;	*******************************************************************
;	***								***
;	***								***
;	***			クラッチ位置決め部			***
;	***								***
;	***								***
;	***								***
;	*******************************************************************

;	*******************************************
;	***					***
;	***	PLS/S --> 位置決めLSI		***
;	***					***
;	*******************************************
;	_POS_LSI_SPDMAX=FFFF		;16bit
;	_POS_FRQ_SPDMAX=500000		;500KHZ(500000PLS/S)
;	Input R2:設定PLS/S
	.ALIGN	4				;
_PLS_LSI_CTL_SPDINI:							;初回起動時
	SUB_START

	MOV.L	#_POSCTL_SET_SPD,R1						;速度
	MOV.L	R2,@R1								;

	MEM_MOV_TO_MEM	_POSCTL_SV_OFS_SPD,L,_POSCTL_RL_SPD,L,R1,R2,R3		;開始は自動起動
	MOV.L	#_POSCTL_SV_OFS_SPD,R1						;
	MOV.L	@R1,R2								;
;	------ BASE時のみ変換が必要---------
	FAR_JSR	#_PLS_CHG_PLS_TO_LSI,R0						;
	MOV.L	#_FREQ_BAS_SV_SPD,R1						;BASE設定
	MOV.L	R2,@R1								;
	POS_LSI_32BIT_DAT_SET ADR=_PLS_BasFreqL,ADR_REG=R6,DAT_REG=R2		;R2 KEEP


	FAR_JSR	#_PLS_LSI_CTL_SPDSET,R0						;PLS/S-->
	SUB_END
	M_RTS


	.ALIGN	4				;
_PLS_LSI_CTL_SPDCNT:								;運転中の速度変動時
	SUB_START
	MOV.L	#_POSCTL_SET_SPD,R1						;速度
	MOV.L	R2,@R1								;SAVE 設定速度

	FAR_JSR	#_PLS_LSI_CTL_SPDSET,R0						;
	SUB_END
	M_RTS


;	-------------------------------------------
;	---	input _POSCTL_RL_SPD		---
;	-------------------------------------------
	.ALIGN	4				;
_PLS_LSI_CTL_SPDSET
	SUB_START
	MOV.L	#_POSCTL_RL_SPD,R0					;内部演算リアルタイム速度(PLS/S)
	MOV.L	@R0,R2							;
	FAR_JSR	#_PLS_CHG_PLS_TO_LSI,R0					;

	MOV.L	#_FREQ_SV_SPD,R6					;2003-07-01(二重化対象速度)
	MOV.L	R2,@R6							;
	POS_LSI_32BIT_DAT_SET ADR=_PLS_TopFreqL,ADR_REG=R6,DAT_REG=R2	;
	SUB_END
	M_RTS


;	***********************************
;	***				***
;	***	停止処理		***
;	***				***
;	***********************************
;	(1)自起動速度になったらEMGｺﾏﾝﾄﾞを発行する
;	(2)速度=0にして残りパルスを0にする
;	とりあえず(1)を行なう。
	.ALIGN	4				;
_PLS_LSI_STOP_END:
	SUB_START
	MOV.L	#(BIT11*H'10000),R4					;
	POS_LSI_BIT_SET_LG ADR=_PLS_BitComdL,MEM=_LSI_BUF_PLS_BitComdL	;
	NOP
	NOP
	NOP
	PUSH_REG1 R4
	XOR	R0,R0								;
	REG_MOV_TO_MEM	DST_ADR=_POSCTL_SV_OFS_SPD,L1=L,DT_REG=R0,WKREG1=R1	;
	POP_REG1 R4								;
	NOP
	NOP
	NOP
	MOV.L	#~(BIT11*H'10000),R4		;
	POS_LSI_BIT_CLR_LG ADR=_PLS_BitComdL,MEM=_LSI_BUF_PLS_BitComdL	;

	SUB_END
	M_RTS






;	***************************************************
;	***						***
;	***	Input R2 PLS/SEC-->LSI(0-FFFF)data	***
;	***						***
;	***************************************************
;	Input R2                                         
	.IMPORT	_POS_LSI_FRQ_DATA_MAK

	.ALIGN	4				;
_PLS_CHG_PLS_TO_LSI
	SUB_START
	FAR_JSR	#_POS_LSI_FRQ_DATA_MAK,R0			;PLS/S → 65535=500KHZ

;	========== MAX ========
	MOV.L	#_LSI_SET_SPD_MAXLMT,R1					;(周波数上のﾘﾐｯﾀ)
	MOV.L	@R1,R3							;
	CMP/HS	R2,R3							;R2 =< R3
	BT	PLS_CHG_PLSTOLSI_100					;
	MOV	R3,R2							;LIMIT
PLS_CHG_PLSTOLSI_100:
;============================ とりあえず策　本当はﾃﾞｰﾀﾚﾍﾞﾙでやるべき==========
;	=== SIT4は未出荷(SIT3:20070914)(COP2:2007-07-20)===
	MOV.L	#_INT_CLS_CTL_FLG,R1		;
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;
	TST_BIT_OF PLS_CHG_PLSTOLSI_120		;
	TST	#BIT6,R0			;
	TST_BIT_ON PLS_CHG_PLSTOLSI_120		;
	MOV.L	#_SET_CLSINC_SPDBAS_PLS,R1	;//65535=500KHZ
	MOV.L	@R1,R3				;
	M_BRA	PLS_CHG_PLSTOLSI_150		;

PLS_CHG_PLSTOLSI_120:

;	-----------2013-06-12-----
	MOV.L	#_TEP_MODE_DRV,R1		;//起動時に判定
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_OF PLS_CHG_PLSTOLSI_130		;



	MOV.L	#_TEP_MIN_SPD_FRQ,R1		;
	MOV.L	@R1,R3				;FREQ 500.000/65535= 7.62PLS/S
	M_BRA	PLS_CHG_PLSTOLSI_150		;

PLS_CHG_PLSTOLSI_130:


;	========== MIN ========
	MOV.L	#_POS_LSI_SPDBAS,R1		;65535=500KHZ
	MOV.L	@R1,R3				;
PLS_CHG_PLSTOLSI_150:

	CMP/HS	R3,R2							;R3 =< R2
	BT	PLS_CHG_PLSTOLSI_200					;
	MOV	R3,R2							;LIMIT
PLS_CHG_PLSTOLSI_200							;
	SUB_END
	M_RTS

;	*******************************************************************
;	***								***
;	***								***
;	***			データ作成				***
;	***								***
;	***								***
;	***								***
;	*******************************************************************
;	起動時または1CYCLE終了時



;	***********************************
;	***				***
;	***	加速度データの作成	***
;	***	_POSCTL_SV_UP_ACC	***
;	***				***
;	***********************************
;	1回転CYCLE
;	ｵｰﾊﾞﾗｲﾄﾞなし
	.EXPORT	_ACCLAT1_SV_MAK_COM			;

	.ALIGN	4				;
_ACCLAT1_SV_MAK_OVR:					;ｵｰﾊﾞﾗｲﾄﾞ演算有り
	SUB_START
	MOV.L	#_POSCTL_OVER_ACC_LAT,R0		;time* 100/(1~127)
	MOV.W	@R0,R4					;1~100

	MOV.L	#_SET1_ACCLAT_TIM1,R0			;
	MOV.W	@R0,R2					;R2:時間

	FAR_JSR	#_ACCLAT1_SV_MAK_COM,R0			;INPUT R2,R4

	MOV.L	#_SET_UP_ACC_LATE,R1				;//目標加速度(PLS/S/S)
	MOV.L	R2,@R1						;
	MOV.L	#_SET_DN_ACC_LATE,R1				;//目標加速度(PLS/S/S)
	MOV.L	R2,@R1						;(最終減速専用)

	SUB_END
	M_RTS

;	-----------------------------------------------------------
;	---	INPUT R2(TIME),R4 OVER-LIDE DATA 1~100,100	---
;	-----------------------------------------------------------
	.ALIGN	4				;
_ACCLAT1_SV_MAK_COM:
	SUB_START

	FAR_JSR	#_OVRLIDE_LATE_MULDIV,R0		;Input R2,R4 ANS R2
	MOV.L	#_OVER_LIDE_ANS_TIM,R1			;TIME *100*100/1*1 = 10000*
	MOV.L	R2,@R1					;(ﾃﾞﾊﾞｯｸ用)
;
;	====時間の次元==>加速度の次元===
;;	MOV.L	#_POS_FRQ_SPDMAX,R0			;500KHZ(500000PLS/S)
;	------- こっちがわかりよい-------
	MOV	R2,R4					;
	MOV.L	#_LINK_MAX_SPD_PLS,R0				;//ｲﾝｸﾘﾒﾝﾀﾙｴﾝｺｰﾀﾞ換算値　pls/s
	MOV.L	@R0,R2						;
	FAR_JSR	#_FPU_DIVS_32REG2_32REG1_R4_32REG2_R2,R0	;R2/R4 

	TST	R2,R2						;
	TST_BIT_ON ACCLAT1_SV_MAKCOM_200			;
	MOV	#1,R2						;
ACCLAT1_SV_MAKCOM_200:						;

	SUB_END
	M_RTS


;	*******************************************
;	***					***
;	***	OVERLIDE 加速度への演算		***
;	***					***
;	*******************************************
;	Input R2(ACC時間),R4(0~100per)/OUTPUT R2,R4
	.ALIGN	4				;
_OVRLIDE_LATE_MULDIV:
	SUB_START

;	------- 2010-10-06-- ふりこ
	PUSH_REG1 R2
	PUSH_REG1 R4
	FAR_JSR	#_CHK_DNM_SPEC_MOD1,R0
	POP_REG1 R4
	POP_REG1 R2

	TST	R0,R0
	TST_BIT_ON OVRLIDE_LATMULDIV200		;ふりこ時時間一定



	MOV.L	#_WPAR_ACCTYP_SEL,R0				;0:加速距離一定(SIT3ｴｸｾﾃﾞｨ) 1:加速時間一定 2:加速度一定
	MOV.W	@R0,R0						;
	CMP/EQ	#0,R0						;0:距離一定(LATE*LATE)
	BT	OVRLIDE_LATMULDIV300				;
	CMP/EQ	#1,R0						;
	BT	OVRLIDE_LATMULDIV200				;加速時間一定JUMP
	M_BRA	OVRLIDE_LATMULDIV550				;加速度一定


OVRLIDE_LATMULDIV200:						;
	MOV.W	#_OVRLIDE_LATE_MAX,R1				;R2(時間)*(100 R1)/(PER R4)加速時間一定
	M_BRA	OVRLIDE_LATMULDIV400				;V=Vmax/Tmax V*0.5 Tmax->Tmax/0.5

OVRLIDE_LATMULDIV300:						;
	MOV	R4,R0						;
	MULU.W	R4,R0						;
	STS	MACL,R4						;V*V=2*Vmax/Tmax*S
	MOV.W	#_OVRLIDE_LATE_MAX*_OVRLIDE_LATE_MAX,R1		;R2(時間)*(100*100 R1)/(PER*PER R4)

OVRLIDE_LATMULDIV400:						;

	EXTU.W	R2,R2						;R2(TIME)*R1/R4
	FAR_JSR	#_FPU_R2_MUL_R1_DIV_R4,R0			;

	MOV.L	#H'0000FFFF,R4					;
	CMP/HS	R2,R4						;
	BT	OVRLIDE_LATMULDIV500				;
	MOV	R4,R2						;
OVRLIDE_LATMULDIV500						;
	TST	R2,R2						;
	TST_BIT_ON OVRLIDE_LATMULDIV550				;
	MOV	#1,R2						;
OVRLIDE_LATMULDIV550:						;

	SUB_END
	M_RTS


;	***********************************
;	***				***
;	***	BRK1ﾃﾞｰﾀMAKE		***
;	***				***
;	***********************************
	.ALIGN	4				;
_ACCBRK1_SV_MAKE:					;ｵｰﾊﾞﾗｲﾄﾞ演算有り
	SUB_START
	MOV.W	#_OVRLIDE_LATE_MAX,R4			;100%
	MOV.L	#_WPAR_BRK1_ACCTM,R0			;//38 msec
	MOV.W	@R0,R2					;

	FAR_JSR	#_ACCLAT1_SV_MAK_COM,R0			;INPUT R2,R4

	MOV.L	#_BRK1_SV_DN_ACC,R1;//目標加速度((PLS/1000)/S/S)
	MOV.L	R2,@R1						;
	SUB_END
	M_RTS

	.ALIGN	4				;
_ACCBRK1_SV_MAK_OVR:					;ｵｰﾊﾞﾗｲﾄﾞ演算有り
	SUB_START
	MOV.L	#_POSCTL_OVER_ACC_LAT,R0		;
	MOV.W	@R0,R4					;1~100

	MOV.L	#_WPAR_BRK1_ACCTM,R0			;//38 msec
	MOV.W	@R0,R2					;

	FAR_JSR	#_ACCLAT1_SV_MAK_COM,R0			;INPUT R2,R4

	MOV.L	#_BRK1_SV_DN_ACC,R1;//目標加速度((PLS/1000)/S/S)
	MOV.L	R2,@R1						;
	SUB_END
	M_RTS


;	***********************************
;	***				***
;	***	BRK2ﾃﾞｰﾀMAKE		***
;	***				***
;	***********************************
	.ALIGN	4				;
_ACCBRK2_SV_MAKE:					;ｵｰﾊﾞﾗｲﾄﾞ演算有り
	SUB_START
	MOV.W	#_OVRLIDE_LATE_MAX,R4			;100%
	MOV.L	#_WPAR_BRK2_ACCTM,R0			;//38 msec
	MOV.W	@R0,R2					;

	FAR_JSR	#_ACCLAT1_SV_MAK_COM,R0			;INPUT R2,R4

	MOV.L	#_BRK2_SV_DN_ACC,R1;//目標加速度((PLS/1000)/S/S)
	MOV.L	R2,@R1						;


	SUB_END
	M_RTS

;	S2b	WPAR_BRK1_ACCTM			;//37 msec
;	S4b	BRK1_SV_DN_ACC;//目標加速度((PLS/1000)/S/S)
;	S4b	BRK1_CAL_DN_ACC;//OVER LIDE 含む


;	*******************************************************************
;	***								***
;	***								***
;	***			演算					***
;	***								***
;	***								***
;	***								***
;	*******************************************************************

;	*******************************************
;	***					***
;	***	2006-09-19			***
;	***	演算				***
;	***	速度LSI設定→PLS/Sにする	***
;	***					***
;	*******************************************
;
	.ALIGN	4				;
_CHG_LSI_LATE_TO_PLS		;2006-09-19
	SUB_START
	MOV.L	#_POS_FRQ_SPDMAX,R0				;500KHZ(500000PLS/S)
	MOV.L	@R0,R1						;
	MOV.L	#_POS_LSI_SPDMAX,R0				;FFFF
	MOV.L	@R0,R4						;
	MOV	R4,R0						;
;;	ADD	#-1,R0						;
;;	ADD	R0,R2						;切上
	FAR_JSR	#_FPU_R2_MUL_R1_DIV_R4,R0			;
	
	SUB_END
	M_RTS




;	***********************************
;	***				***
;	***	起動コマンド		***
;	***				***
;	***********************************
	.ALIGN	4				;
_SPD_CTL_START
	SUB_START

	MOV.W	#1,R0								;
	REG_MOV_TO_MEM	DST_ADR=_POSCTL_STEP_CMD,L1=W,DT_REG=R0,WKREG1=R1	;

	MOV.L	#_POSCTL_STEP_FLG,R1						;//0(IDLE) BIT0:起動 BIT6:END
	MOV.W	@R1,R0								;
	TST	#BIT0,R0							;
	TST_BIT_OF SPD_CTL_ST100						;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POSCTL_CALC_ERR,LG=W,BIT=BIT0,WKREG=R1	;
SPD_CTL_ST100
	XOR	R0,R0			;
	REG_MOV_TO_MEM	DST_ADR=_POSCTL_STEP_FLG,L1=W,DT_REG=R0,WKREG1=R1

	SUB_END
	M_RTS

;	-------------------------------------------
;	---					---
;	-------------------------------------------
;	***********************************
;	***				***
;	***	EMG停止コマンド		***
;	***				***
;	***********************************
	.ALIGN	4				;
_SPD_CTL_EMG_STOP
	SUB_START
	MOV.W	#3,R0								;0:EMG
	REG_MOV_TO_MEM	DST_ADR=_POSCTL_STEP_CMD,L1=W,DT_REG=R0,WKREG1=R1	;
	SUB_END
	M_RTS

;	-------------------------------------------
;	---					---
;	-------------------------------------------
;	***********************************
;	***				***
;	***	SLOW停止コマンド	***
;	***				***
;	***********************************
	.ALIGN	4				;
_SPD_CTL_SLOW_STOP
	SUB_START
	MOV.W	#2,R0								;2:SLOW
	REG_MOV_TO_MEM	DST_ADR=_POSCTL_STEP_CMD,L1=W,DT_REG=R0,WKREG1=R1	;
	SUB_END
	M_RTS


;	***********************************************************
;	***							***
;	***							***
;	***			前回I/F				***
;	***							***
;	***							***
;	***********************************************************
;	*******************************************
;	***	トップ周波数	起動		***
;	*******************************************
;	65535へ正規化または7FFFへ正規化
;	Input R2:
	.ALIGN	4				;
_POS_LSI_TOP_SPEED_SET:
	SUB_START
	FAR_JSR	#_PLS_LSI_CTL_SPDINI,R0
	SUB_END
	M_RTS

;	*******************************************
;	***	トップ周波数	速度可変	***
;	*******************************************
	.ALIGN	4				;
_POS_LSI_TOP_SPEED_SETX:
	SUB_START
	FAR_JSR	#_PLS_LSI_CTL_SPDCNT,R0
	SUB_END
	M_RTS

;	***********************************
;	***	ベース周波数		***
;	***********************************
;	(1回だけ)
	.ALIGN	4				;
_POS_LSI_BAS_SPEED_SET:
	SUB_START
	MEM_MOV_TO_MEM	_SET_SPDBAS_PLS,L,_POSCTL_SV_OFS_SPD,L,R1,R2,R3	;
	SUB_END
	M_RTS

;	*******************************************
;	***	ベース周波数(HAIF-CLOSE)	***
;	*******************************************
	.EXPORT	_POS_LSI_CLS_BAS_SPD_SET
	.ALIGN	4				;
_POS_LSI_CLS_BAS_SPD_SET:
	SUB_START
	MEM_MOV_TO_MEM	_SET_CLS_SPDBAS_PLS,L,_POSCTL_SV_OFS_SPD,L,R1,R2,R3	;
	SUB_END
	M_RTS



;	***********************************
;	***	ベース周波数		***
;	***********************************
;	2013-06-13
	.EXPORT	_POS_LSI_TEP_BAS_SPEED_SET
	.ALIGN	4				;
_POS_LSI_TEP_BAS_SPEED_SET:
	SUB_START
	MEM_MOV_TO_MEM	_TEP_MIN_SPD_PLS,L,_POSCTL_SV_OFS_SPD,L,R1,R2,R3	;
	SUB_END
	M_RTS



;
;	*******************************************
;	***	トップSPEED=自起動=ｲﾝﾁﾝｸﾞ	***
;	*******************************************
;	65535へ正規化または7FFFへ正規化
;	Input R2:
	.EXPORT	_POS_LSI_CLS_TOP_EQ_BAS_SET1
	.ALIGN	4				;
_POS_LSI_CLS_TOP_EQ_BAS_SET1:
	SUB_START
	MEM_MOV_TO_MEM	_SET_CLS_SPDBAS_PLS,L,_POSCTL_SV_OFS_SPD,L,R1,R2,R3	;
	MOV.L	#_POSCTL_SV_OFS_SPD,R1		;
	MOV.L	@R1,R2				;
	FAR_JSR	#_POS_LSI_TOP_SPEED_SET,R0
	SUB_END
	M_RTS

	.EXPORT	_POS_LSI_CLS_TOP_EQ_BAS_SET2
	.ALIGN	4				;
_POS_LSI_CLS_TOP_EQ_BAS_SET2:
	SUB_START
	MEM_MOV_TO_MEM	_SET_CLSINC_SPDBAS_PLS,L,_POSCTL_SV_OFS_SPD,L,R1,R2,R3	;
	MOV.L	#_POSCTL_SV_OFS_SPD,R1		;
	MOV.L	@R1,R2				;
	FAR_JSR	#_POS_LSI_TOP_SPEED_SET,R0

	SUB_END
	M_RTS

;	***********************************
;	***	通常加減速		***
;	***********************************
;	(1回だけ):加速度
	.ALIGN	4				;
_POS_LSI_ACC1_SET:
	SUB_START
	MOV.L	#_POS_LSI_ACCLT1,R0		;
	MOV.W	@R0,R2
	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_AccLate1,R6	;
	MOV.W	R2,@R6						;
	SUB_END
	M_RTS
	
;	***********************************
;	***	急停止加減速		***
;	***********************************
;	(1回だけ):加速度
	.ALIGN	4				;
_POS_LSI_ACC2_SET:
	SUB_START
	MOV.L	#_POS_LSI_ACCLT2,R0
	MOV.W	@R0,R2
	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_AccLate2,R6	;
	MOV.W	R2,@R6						;
	SUB_END
	M_RTS

;	***********************************
;	***	速度LATE		***
;	***********************************
;	(1回だけ):
	.ALIGN	4				;
_POS_LSI_SPDLATE_SET:
	SUB_START
	MOV.L	#_POS_LSI_SPDLAT,R0				;
	MOV.W	@R0,R2
	MOV.L	#_poslsi1_top+_PLSI_CH1+_PLS_SpedLate,R6	;
	MOV.W	R2,@R6						;
	SUB_END
	M_RTS





;	***********************************
;	***				***
;	***	REAL TIME MONITOR	***
;	***				***
;	***********************************
;	============== 20060919 DBG=====================
	.GLOBAL		_SH_POSCTL_SV_SPD	;.SRES	4*2	;[+0:SH4 +4:SH2]
	.GLOBAL		_SH_POSCTL_RL_SPD	;.SRES	4*2	;[+0:SH4 +4:SH2]
	.GLOBAL		_SH_POSCTL_ACC		;.SRES	4*2	;
	.GLOBAL		_SH_POSCTL_OFS		;.SRES	4*2	;
	.GLOBAL		_SH_POSCTL_SV_ABSPLS	;.SRES	8*2	;
	.GLOBAL		_SH_POSCTL_RL_ABSPLS	;.SRES	8*2	;
	.GLOBAL		_SH_POSCTL_PV_ABSPLS	;.SRES	8*2	;
	.GLOBAL		_SH_POSCTL_REST_PLS	;.SRES	4*2	;
	.GLOBAL		_SH_POSCTL_CAL_REST	;.SRES	4*2	;演算(SV-PV)
	.GLOBAL		_SH_POSCTL_HENSA	;.SRES	4*2	;演算(SV-PV)
	.GLOBAL		_SH_POSCTL_LSIFREQ	;.SRES	4*2	;LSI

	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
_SH_2B	.EQU	0
_SH_4B	.EQU	0
_SH_8B	.EQU	0
	.AELSE
_SH_2B	.EQU	2
_SH_4B	.EQU	4
_SH_8B	.EQU	8
	.AENDI





	.ALIGN	4				;
_MONI_SEINOU_CMP_OUTPUT:
	SUB_START

;	設定速度
	MEM_MOV_TO_MEM	_POSCTL_SV_SPD,L	,_SH_POSCTL_SV_SPD+_SH_4B	,L,R1,R2,R3	;[+0:SH4 +4:SH2]
;	制御速度
	MEM_MOV_TO_MEM	_POSCTL_RL_SPD,L	,_SH_POSCTL_RL_SPD+_SH_4B	,L,R1,R2,R3	;[+0:SH4 +4:SH2]
	MEM_MOV_TO_MEM	_POSCTL_SV_UP_ACC,L	,_SH_POSCTL_ACC+_SH_4B		,L,R1,R2,R3	;
	MEM_MOV_TO_MEM	_POSCTL_SV_OFS_SPD,L	,_SH_POSCTL_OFS+_SH_4B		,L,R1,R2,R3	;
	MEM_MOV_TO_MEM	_NEW_POSLSI_RESTPLS,L	,_SH_POSCTL_REST_PLS+_SH_4B	,L,R1,R2,R3	;

;	目標位置
	MOV.L	#_LINK_SV_OBJ_ABSPLS,R4					;LINKX_SV_OBJ_ABSPLSの場合があるかも
	MOV.L	@R4+,R1							;
	MOV.L	@R4,R2							;
	MOV.L	#_SH_POSCTL_SV_ABSPLS+_SH_8B,R4				;
	MOV.L	R1,@(0,R4)
	MOV.L	R2,@(4,R4)

;	ﾘｱﾙﾀｲﾑ目標位置
	MOV.L	#_LINK_RL_OBJ_ABSPLS,R4							;
	MOV.L	@R4+,R5									;
	MOV.L	@R4,R6									;
	MOV.L	#_SH_POSCTL_RL_ABSPLS+_SH_8B,R4						;[CPUB側で使用する2014-11-07]
	MOV.L	R5,@(0,R4)								;
	MOV.L	R6,@(4,R4)								;
	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2			;
	REG_MOV_TO_MEM	DST_ADR=_SH_POSCTL_CAL_REST+_SH_4B,L1=L,DT_REG=R2,WKREG1=R1	;

;	実測位置
	MOV.L	#_LINK_PV_ABSPLS,R4							;
	MOV.L	@R4+,R1									;
	MOV.L	@R4,R2									;
	MOV.L	#_SH_POSCTL_PV_ABSPLS+_SH_8B,R4						;
	MOV.L	R1,@(0,R4)								;
	MOV.L	R2,@(4,R4)								;
	SUB8B DT_REGH=R1,DT_REGL=R2,DT_ANS_REGH=R5,DT_ANS_REGL=R6			;
	REG_MOV_TO_MEM	DST_ADR=_SH_POSCTL_HENSA+_SH_4B,L1=L,DT_REG=R6,WKREG1=R1	;

	FAR_JSR	#_LOAD_NOW_FREQ_PLS,R0							;
	REG_MOV_TO_MEM	DST_ADR=_SH_POSCTL_LSIFREQ+_SH_4B,L1=L,DT_REG=R0,WKREG1=R1	;


;	------------------- 2007-03-02--------------------
	.GLOBAL		_SH_SQ200_IN		;
	.GLOBAL		_SH_CNTSTOP_FLG		;
	MOV.L	#_di1_cb_ctl1_dt,R1			;// ﾚﾍﾞﾙﾃﾞ-ﾀ
	MOV.W	@R1,R2					;
	MOV.W	#(BIT11+BIT10+BIT9+BIT8),R4		;
	NOT	R4,R4					;
	AND	R4,R2					;

	MOV.L	#_BTTN_FLG,R1				;
	MOV.W	@R1,R0					;BIT8,9,10,11
	SHLL8	R0					;BIT8,9,10
	OR	R0,R2					;
	MOV.W	#BIT7,R4			;
	NOT	R4,R4					;
	AND	R4,R2					;

	MOV.L	#_CNT_STOP_CMD,R1			;
	MOV.W	@R1,R0					;
	TST	R0,R0					;
	TST_BIT_OF MONI_DI_CHK_050			;
	MOV.W	#BIT7,R4				;
	OR	R4,R2					;
MONI_DI_CHK_050:
	REG_MOV_TO_MEM	DST_ADR=_SH_SQ200_IN+_SH_2B,L1=W,DT_REG=R2,WKREG1=R1	;


	MOV.L	#_STOP_LATCH_B,R1		;//BIT0:ｽﾄｯﾌﾟ釦
	MOV.W	@R1,R0				;IN
	AND	#BIT0,R0			;
	SHLL	R0
	MOV	R0,R2				;

	MOV.L	#_STOP_LATCH,R1			;//BIT0:ｽﾄｯﾌﾟ釦
	MOV.W	@R1,R0				;LATCH
	AND	#BIT0,R0			;
	OR	R0,R2				;
	REG_MOV_TO_MEM	DST_ADR=_SH_CNTSTOP_FLG+_SH_2B,L1=W,DT_REG=R2,WKREG1=R1	;

	.IMPORT	_SH_OUTPLS_DELT
	MOV.L	#_OUTPLS_DELT,R1			;
	MOV.W	@R1,R2
	REG_MOV_TO_MEM	DST_ADR=_SH_OUTPLS_DELT+_SH_2B,L1=W,DT_REG=R2,WKREG1=R1	;

	SUB_END
	M_RTS




;	*******************************************
;	***					***
;	***					***
;	***					***
;	*******************************************
	.ALIGN	4				;
_RL_POS_DATA_CHK:
	SUB_START
	MOV.L	#_MONI_CPUAB_PLSDELT,R4
	.AIF	_CB_CPU_SEL EQ	_CB_CPUA
	MOV.L	#_SH_POSCTL_RL_ABSPLS+0,R7			;自分
	MOV.L	#_SH_POSCTL_RL_ABSPLS+8,R9			;相手
	.AELSE
	MOV.L	#_SH_POSCTL_RL_ABSPLS+0,R9			;相手
	MOV.L	#_SH_POSCTL_RL_ABSPLS+8,R7			;自分
	.AENDI

RL_POSDTCHK_SECOND_RD:
	MOV.L	@(0,R9),R5						;
	MOV.L	@(4,R9),R6						;
	MOV.L	@(0,R9),R1						;
	MOV.L	@(4,R9),R2						;
	CMP/EQ	R1,R5							;相手
	BF	RL_POSDTCHK_SECOND_RD
	CMP/EQ	R2,R6							;
	BF	RL_POSDTCHK_SECOND_RD

	MOV.L	@(0,R7),R3						;
	MOV.L	@(4,R7),R4						;
	SUB8B DT_REGH=R3,DT_REGL=R4,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;R1,R2(相手-自分)

	MOV.L	#_MONI_CPUAB_PLSDELT,R0					;相手-自分
	MOV.L	R1,@(0,R0)
	MOV.L	R2,@(4,R0)						;
	


	SUB_END
	M_RTS

;	***************************************************
;	***						***
;	***		ためし				***
;	***						***
;	***************************************************
;	Input R2
	.ALIGN	4				;
_CNT_HOSEI_CHK_CALC:
	SUB_START
	.AIF	_CB_CPU_SEL EQ	_CB_CPUB			;ﾊﾟﾙｽ補正
	MOV.L	#_emg_err_flg,R1		;//異常ﾗｯﾁ
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_ON CNT_HOSEI_CHKCAL_050		;
	MOV.L	#_exq_err_flg,R1		;//異常ﾗｯﾁ
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_ON CNT_HOSEI_CHKCAL_050					;

	MOV.L	#_MODE_SEL,R1						;
	MOV.W	@R1,R0							;
	TST	#_W1CNT,R0						;
	TST_BIT_OF CNT_HOSEI_CHKCAL_050					;

	MOV.L	#_CPOS_MOD_FLG1,R1					;
	MOV.W	@R1,R0							;
	TST	#BIT3,R0						;
	TST_BIT_ON CNT_HOSEI_CHKCAL_100					;VMODE
CNT_HOSEI_CHKCAL_050:
	FAR_JSR	#_CNTREST_HOS_RESET,R0					;
	M_BRA	CNT_HOSEI_SPDSET_EXT					;

CNT_HOSEI_CHKCAL_100:
	MOV.L	#_MONI_CPUAB_PLSDELT,R0
	MOV.L	@(0,R0),R1			;(0or1)
	MOV.L	@(4,R0),R2			;
	MOV	R2,R3				;+/-
	CMP/PZ	R1				;+
	BT	CNT_HOSEI_CHKCAL_200		;相手-自分
	NEG	R2,R2				;
CNT_HOSEI_CHKCAL_200:				;
	FAR_JSR	#_CNT_SYNC_HOS_SPD_TYP,R0	;


CNT_HOSEI_SPDSET_EXT:
	.AENDI


	SUB_END
	M_RTS


;	*******************************************
;	***					***
;	***					***
;	***					***
;	*******************************************
;	HOS1 1000:1000~  1:7HZ
;	HOS1 2000:2000~  2:14HZ
;	HOS1 3000:3000~  4:28HZ
;	HOS1 4000:ERR
_SYNC2_ERR_HABPLS1	.EQU	8000	;16000

_SYNC2_ERR_HOSHAB1	.EQU	300	;
_SYNC2_ERR_HOSHAB2	.EQU	400	;(100)
_SYNC2_ERR_HOSHAB3	.EQU	500	;(500)
_SYNC2_ERR_HOSHAB4	.EQU	1000	;(500)
_SYNC2_ERR_HOSHAB5	.EQU	1500	;(500)
_SYNC2_ERR_HOSHAB6	.EQU	2000	;(500)
_SYNC2_ERR_HOSHAB7	.EQU	2500	;(500)


_SYNC2_HOS_SPD1		.EQU	1	;
_SYNC2_HOS_SPD2		.EQU	4	;
_SYNC2_HOS_SPD3		.EQU	8	;
_SYNC2_HOS_SPD4		.EQU	32	;
_SYNC2_HOS_SPD5		.EQU	64	;
_SYNC2_HOS_SPD6		.EQU	128	;
_SYNC2_HOS_SPD7		.EQU	256	;2000khz
_SYNC2_HOS_SPD8		.EQU	512	;2000khz 2006-10-28

	.ALIGN	4				;
_CNT_SYNC_HOS_SPD_TYP:
	SUB_START

	MOV.L	#_CNT_SYNC_HOS_DAT2,R1		;相手-自分
	MOV.L	R3,@R1				;(+/-生ﾃﾞｰﾀ)

	MOV.W	#_SYNC2_ERR_HABPLS1,R1		;
	CMP/HS	R2,R1				;
	BT	CNT_SYNCHOS_SPDTYP_080		;

;	-------- 2006-10-23--
	MOV	#BIT0,R4			;
	MOV.L	#_SYNC2_HOS_SPD8,R5		;MAX
	M_BRA	CNT_SYNCHOS_SPDTYP_400		;


;;;	MEM1_BIT0_TO_BIT7_ORSET MEM=_CNT_SYNC_ERR_FLG,LG=W,BIT=(BIT1+BIT0),WKREG=R1	;SYNC_ERR
;;;
;;;	M_BRA	CNT_SYNCHOS_SPDTYP_EXT							;

CNT_SYNCHOS_SPDTYP_080:

	MOV.W	#_SYNC2_ERR_HOSHAB1,R1		;
	CMP/HI	R1,R2				;=<data1(1000)
	BT	CNT_SYNCHOS_SPDTYP_200		;R1(1000)<R2(PLS) JUMP
CNT_SYNCHOS_SPDTYP_100:
;	=== 正常補正なし====
	XOR	R4,R4				;FLG_BIT
	XOR	R5,R5				;data
	M_BRA	CNT_SYNCHOS_SPDTYP_450		;

CNT_SYNCHOS_SPDTYP_200:
	MOV.W	#_SYNC2_ERR_HOSHAB2,R1		;
	CMP/HI	R1,R2				;=<data2(2000)
	BT	CNT_SYNCHOS_SPDTYP_250		;R1(2000)<R2(PLS) JUMP
	MOV	#BIT0,R4			;
	MOV.W	#_SYNC2_HOS_SPD1,R5		
	M_BRA	CNT_SYNCHOS_SPDTYP_400		;

CNT_SYNCHOS_SPDTYP_250:
	MOV.W	#_SYNC2_ERR_HOSHAB3,R1		;
	CMP/HI	R1,R2				;=<data3(3000)
	BT	CNT_SYNCHOS_SPDTYP_300		;R1(3000)<R2(PLS) JUMP
	MOV	#BIT0,R4			;
	MOV.W	#_SYNC2_HOS_SPD2,R5		
	M_BRA	CNT_SYNCHOS_SPDTYP_400		;

CNT_SYNCHOS_SPDTYP_300:

	MOV.W	#_SYNC2_ERR_HOSHAB4,R1		;
	CMP/HI	R1,R2				;=<data4(3000)
	BT	CNT_SYNCHOS_SPDTYP_310		;R1(3000)<R2(PLS) JUMP
	MOV	#BIT0,R4			;
	MOV.W	#_SYNC2_HOS_SPD3,R5		
	M_BRA	CNT_SYNCHOS_SPDTYP_400		;

CNT_SYNCHOS_SPDTYP_310:
	MOV.W	#_SYNC2_ERR_HOSHAB5,R1		;
	CMP/HI	R1,R2				;=<data4(3000)
	BT	CNT_SYNCHOS_SPDTYP_320		;R1(3000)<R2(PLS) JUMP
	MOV	#BIT0,R4			;
	MOV.W	#_SYNC2_HOS_SPD4,R5		
	M_BRA	CNT_SYNCHOS_SPDTYP_400		;

CNT_SYNCHOS_SPDTYP_320:
	MOV.W	#_SYNC2_ERR_HOSHAB6,R1		;
	CMP/HI	R1,R2				;=<data4(3000)
	BT	CNT_SYNCHOS_SPDTYP_330		;R1(3000)<R2(PLS) JUMP
	MOV	#BIT0,R4			;
	MOV.W	#_SYNC2_HOS_SPD5,R5		
	M_BRA	CNT_SYNCHOS_SPDTYP_400		;

CNT_SYNCHOS_SPDTYP_330:
	MOV.W	#_SYNC2_ERR_HOSHAB7,R1		;
	CMP/HI	R1,R2				;=<data4(3000)
	BT	CNT_SYNCHOS_SPDTYP_390		;R1(3000)<R2(PLS) JUMP
	MOV	#BIT0,R4			;
	MOV.W	#_SYNC2_HOS_SPD6,R5		
	M_BRA	CNT_SYNCHOS_SPDTYP_400		;

CNT_SYNCHOS_SPDTYP_390:
	MOV	#BIT0,R4			;
	MOV.W	#_SYNC2_HOS_SPD7,R5		
	M_BRA	CNT_SYNCHOS_SPDTYP_400		;

CNT_SYNCHOS_SPDTYP_400:
	MOV.L	#_CNT_SYNC_CHK_CNT2,R1
	MOV.W	@R1,R0
	ADD	#1,R0
	MOV.W	R0,@R1				;

	CMP/PZ	R3				;相手-自分= 10 +に溜まっている.速度UP
	BT	CNT_SYNCHOS_SPDTYP_450		;          -10 -に溜まっている.速度DN
	NEG	R5,R5				;
CNT_SYNCHOS_SPDTYP_450:				;
	MOV.L	#_CNT_REST_SPD_HOSEI_FLG,R1	;
	MOV.W	R4,@R1				;
	MOV.L	#_CNT_REST_SPD_HOSEI_DAT,R1	;
	MOV.L	R5,@R1				;

CNT_SYNCHOS_SPDTYP_EXT:
	MOV.L	#_CNT_REST_SPD_HOSEI_DAT,R1	;
	MOV.L	@R1,R0				;
	MOV.L	#_CNT_SYNC_HOS_DAT1,R1		;
	MOV.L	R0,@R1				;

	SUB_END
	M_RTS

;	***********************************
;	***				***
;	***	速度設定		***
;	***	FFFF(500Kはありえない)	***
;	***				***
;	***********************************
;	input R2 speed
	.ALIGN	4				;
_CNT_REST_HOSEI_SPD_TYP:
	SUB_START
	MOV.L	#_CNT_REST_SPD_HOSEI_FLG,R1	;
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;
	TST_BIT_OF CNT_REST_HOSEI_SPDTYP_EXT	;
	MOV.L	#_CNT_REST_SPD_HOSEI_DAT,R1	;
	MOV.L	@R1,R0				;
	ADD	R0,R2				;
CNT_REST_HOSEI_SPDTYP_EXT:
	SUB_END
	M_RTS

	.EXPORT	_CNTREST_HOS_RESET
	.ALIGN	4				;
_CNTREST_HOS_RESET
	SUB_START
	XOR	R0,R0
	REG_MOV_TO_MEM	DST_ADR=_CNT_REST_SPD_HOSEI_FLG	,L1=W,DT_REG=R0,WKREG1=R1	;
	REG_MOV_TO_MEM	DST_ADR=_CNT_REST_SPD_HOSEI_DAT	,L1=L,DT_REG=R0,WKREG1=R1	;
	SUB_END
	M_RTS



;	*******************************************
;	***					***
;	***	2010-10-05			***
;	***					***
;	***					***
;	*******************************************
	.ALIGN	4				;
_dum_SET_PV_ABS_TO_OBJ:
	SUB_START
	SUB_END
	M_RTS

;	***************************************************
;	***						***
;	***	反転のタイマ途中からの再起動		***
;	***	(安全一、寸動、連続寸動一、連続タイマ)	***
;	***	2012-05-15				***
;	***						***
;	***************************************************
;	起動時,
;
	.ALIGN	4				;
_DURING_TIM_CNTINUE_CHK
	SUB_START
	MOV.L	#_DURING_TIM_FX,R1				;
	MOV.W	@R1,R0						;
DURING_TIM_CNTCK_END
	SUB_END
	M_RTS


;	------------- 再度0から行うか,途中から行うか,ﾀｲﾌﾟｱｯﾌﾟから行うか
;	input R1:設定
;
_DURING_TIM_PRESET_CALC
	SUB_START

	MOV.L	#_DURING_TIM_FX,R0					;
	MOV.W	@R0,R0							;
	TST	R0,R0							;
	TST_BIT_OF DURING_TIM_PRECALC200				;通常の処理

	TST	R1,R1							;
	TST_BIT_OF DURING_TIM_PRECALC200				;ﾃﾞｰﾀが0

	MOV.L	#(_PAR_STOPTIM_SEL-_CB_SYS_PARAM000+_W_PARAM_TOP),R0	;
	MOV.W	@R0,R0							;
	CMP/EQ	#2,R0							;
	BT	DURING_TIM_PRECALC100					;"ｸﾘｱ":ﾀｲﾑｱｯﾌﾟからはじめる

	CMP/EQ	#1,R0							;
	BF	DURING_TIM_PRECALC200					;0:(2,1以外):(設定をｾｯﾄする)
	M_BRA	DURING_TIM_PRECALCEND					;1:設定しない:継続


DURING_TIM_PRECALC100
	XOR	R1,R1							;
DURING_TIM_PRECALC200
	MOV.L	#_SDAT_WAIT_PVTIM,R4					;
	MOV.L	R1,@R4							;
DURING_TIM_PRECALCEND
	SUB_END
	M_RTS



;	*******************************************
;	***					***
;	***		2013-02-08		***
;	***		CPUB_CURVSEL[4]		***
;	*******************************************
;;	CPUA=CPUB=TBLCURV時に生かす
	.IMPORT		_PAR_DNMDEND_DLY

_DNMODE_ENDWAIT_TIM_SET				;[[[2013-03-24復活]]]
	SUB_START				;[[[2013-03-24復活]]]

	MOV.L	#_SETX_POS_CTL_MATH,R1		;[[[2013-03-24復活]]]
	MOV.W	@R1,R0				;[[[2013-03-24復活]]]
	TST	#_DMATH_DNDRIV,R0		;[[[2013-03-24復活]]]
	TST_BIT_OF DNMODE_ENDWAIT_TIMST100	;[[[2013-03-24復活]]]

	MOV.L	#_MODE_SEL,R1			;[[[2013-03-24復活]]]
	MOV.W	@R1,R0				;[[[2013-03-24復活]]]
	TST	#_W1CNT,R0			;[[[2013-03-24復活]]]
	TST_BIT_OF DNMODE_ENDWAIT_TIMST100	;[[[2013-03-24復活]]]

	MOV.L	#(_PAR_DNMDEND_DLY-_CB_SYS_PARAM000+_W_PARAM_TOP),R1	;[[[2013-03-24復活]]]
	MOV.W	@R1,R0							;[[[2013-03-24復活]]]
	M_BRA	DNMODE_ENDWAIT_TIMST200					;[[[2013-03-24復活]]]

DNMODE_ENDWAIT_TIMST100							;[[[2013-03-24復活]]]
	XOR	R0,R0							;[[[2013-03-24復活]]]
DNMODE_ENDWAIT_TIMST200							;
	MOV.L	#_PVX_DNMOD_DLYTIM,R1					;[[[2013-03-24復活]]]
	MOV.W	R0,@R1							;[[[2013-03-24復活]]]
									;
	SUB_END								;[[[2013-03-24復活]]]
	M_RTS								;

_DNMODE_ENDWAIT_TIM_CHK							;[[[2013-03-24復活]]]
	SUB_START							;[[[2013-03-24復活]]]
	MOV.L	#_PVX_DNMOD_DLYTIM,R1					;[[[2013-03-24復活]]]
	MOV.W	@R1,R0							;[[[2013-03-24復活]]]
	TST	R0,R0							;[[[2013-03-24復活]]]
	TST_BIT_OF DNMODE_ENDWAIT_TIMCK_END				;ANS R0=0 [[[2013-03-24復活]]]
									;[[[2013-03-24復活]]]
	ADD	#-1,R0							;[[[2013-03-24復活]]]
	MOV.W	R0,@R1							;[[[2013-03-24復活]]]
	MOV.B	#1,R0							;R0=1 NOT TIM UP[[[2013-03-24復活]]]
		
DNMODE_ENDWAIT_TIMCK_END						;[[[2013-03-24復活]]]

	SUB_END								;[[[2013-03-24復活]]]
	M_RTS								;[[[2013-03-24復活]]]

;	***************************************************
;	***						***
;	***		寸動時上限制限をかける		***
;	***		2013-02-15			***
;	***************************************************
_INC_UPLIMT_CALC:
	SUB_START
	MOV.L	#_MODE_SEL,R1				;
	MOV.W	@R1,R0					;
	TST	#(_W1INC),R0				;
	TST_BIT_OF INC_UPLIMT_CAL100			;

	MOV.L	#_CB_SEQ_CB_COM349,R1			;
	MOV.W	@R1,R0					;
	MOV.W	#BIT8,R4				;
	TST	R4,R0					;
	TST_BIT_OF INC_UPLIMT_CAL100			;

	MOV.L	#(_PAR_INCSPD_UPLMT-_CB_SYS_PARAM000+_W_PARAM_TOP),R1	;
	MOV.W	@R1,R2							;
	FAR_JSR	#_CYCLE_SPD1,R0						;
	MOV.L	#_UPLIMIT_SV_SPD,R1			;//(上限共通DATA)PLS/S
	MOV.L	R2,@R1					;

	MOV.W	#BIT0,R0				;
	M_BRA	INC_UPLIMT_CAL200			;

INC_UPLIMT_CAL100:
	XOR	R0,R0
INC_UPLIMT_CAL200:
	MOV.L	#_UPLIMIT_START_F,R1	;//BIT0:寸動からの指令
	MOV.W	R0,@R1			;
INC_UPLIMT_CALEND:

	SUB_END
	M_RTS


;	*******************************************
;	***					***
;	***	2009-10-07			***
;	***	下振子				***
;	***	非常停止			***
;	*******************************************
	.ALIGN	4				;
_DNM_DATA_CLR:
	SUB_START
	XOR	R0,R0
	MOV.L	#_DNM_DIR_SET_FLG,R1		;//2BYTE 0:往路 1:復路(動作中保証：停止時に切り替わり)
	MOV.W	R0,@R1
	MOV.L	#_DNM_DIR_NOW_FLG,R1		;//運転釦起動時
	MOV.W	R0,@R1
	SUB_END
	M_RTS

;	*******************************************
;	***					***
;	***	2014-09-17			***
;	***	下振子				***
;	***	左待機点からの開始		***
;	***					***
;	*******************************************
;	初期値は0：右
	.EXPORT	_DNM_DATA_REV_SET
_DNM_DATA_REV_SET:
	SUB_START
	MOV.B	#BIT0,R0			;
	MOV.L	#_DNM_DIR_SET_FLG,R1		;//2BYTE 0:往路 1:復路(動作中保証：停止時に切り替わり)
	MOV.W	R0,@R1

;;;;;;;	MOV.L	#_DNM_DIR_NOW_FLG,R1		;//運転釦起動時,次のｻｲｸﾙ起動時 SET_FLG=>NOW_FLG
;;;;;;;	MOV.W	R0,@R1

	SUB_END
	M_RTS


_DNM_CYCLE_END:					;
	SUB_START				;

	XOR	R2,R2				;
	MOV.L	#_SETX_POS_CTL_MATH,R1		;
	MOV.W	@R1,R0				;
	TST	#_DMATH_DNDRIV,R0
	TST_BIT_OF DNM_CYCLE_ED_100		;

	MOV.L	#_DNM_DIR_NOW_FLG,R1		;//
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_ON DNM_CYCLE_ED_100		;
	MOV	#1,R2				;
DNM_CYCLE_ED_100:				;
	MOV.L	#_DNM_DIR_SET_FLG,R1		;//
	MOV.W	R2,@R1				;NEXT-SET

;	----------------[2014-11-10 add]---------
	MOV.L	#_DNM_DIR_FLG_INC_LATCH,R1;	//ふりこの場合の前回までの動作方向(今回動きべき方向)
	MOV.W	R2,@R1				;
;	---------------------------------------------

	SUB_END
	M_RTS

;	***************************************************
;	***						***
;	***	ふりこ　連続の次のサイクル開始		***
;	***						***
;	***************************************************
;	ここでオーバライド演算も追加する(2010-10-05)

_DNM_CYCLE_START:				;
	SUB_START				;
	XOR	R2,R2				;
	MOV.L	#_SETX_POS_CTL_MATH,R1		;
	MOV.W	@R1,R0				;
	TST	#_DMATH_DNDRIV,R0		;
	TST_BIT_OF DNM_CYCLE_STR_100		;

	MOV.L	#_DNM_DIR_SET_FLG,R1		;//
	MOV.W	@R1,R2				;
	MOV.L	#_DNM_DIR_NOW_FLG,R1		;//
	MOV.W	R2,@R1				;

;	----------------[2014-11-10 add]---------
	MOV.L	#_DNM_DIR_FLG_INC_LATCH,R1;	//ふりこの場合の前回までの動作方向
	MOV.W	R2,@R1				;
;	---------------------------------------------

	FAR_JSR	#_CPOS_INI1_DTMOV2,R0
	M_BRA	DNM_CYCLE_STR_200		;

DNM_CYCLE_STR_100:
	MOV.L	#_DNM_DIR_NOW_FLG,R1		;//
	MOV.W	R2,@R1				;

DNM_CYCLE_STR_200:


	SUB_END
	M_RTS

;	***************************
;	***	1MS-MAINでCALL	***
;	***************************
	.EXPORT	_DNM_MATH_ELSE_DAT_MAKE


_DNM_MATH_ELSE_DAT_MAKE:
	SUB_START
	MOV.L	#_INC_ENC360,R1					;
	MOV.W	@R1,R2

	MOV.L	#_SETX_POS_CTL_MATH,R1		;
	MOV.W	@R1,R0				;
	TST	#_DMATH_DNDRIV,R0		;
	TST_BIT_OF DNM_MATH_ELSE_DATMK100	;

	MOV.L	#_MODE_SEL,R1						;
	MOV.W	@R1,R0							;
	TST	#_W1CNT+_W1SGL+_W1INC+_W1OPT,R0				;
	TST_BIT_OF DNM_MATH_ELSE_DATMK100				;

	MOV.L	#_DNM_DIR_NOW_FLG,R1		;
	MOV.W	@R1,R0				;

;;;;2013-02-15不要	MOV.W	@R1,R3				;必ず同じになる
;;;;2013-02-15不要	CMP/EQ	R0,R3				;
;;;;2013-02-15不要	BF	DNM_MATH_ELSE_DATMK050		;違ったら更新したかったのかな？

	MOV.L	#_DNM_DIR_SAM_FLG,R1		;//2BYTE 0:往路 1:復路(動作中保証：停止時に切り替わり)
	MOV.W	R0,@R1				;動作・動かしたいデータが同じ

;;;;2013-02-15不要	DNM_MATH_ELSE_DATMK050:
	MOV.L	#_DNM_DIR_SAM_FLG,R1		;
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_OF DNM_MATH_ELSE_DATMK100	;180

	FAR_JSR	#_DIG01_CHG_DN_DATA_MAKE,R0	;上限が0度　下限が180で左右同じじゃないとｸﾗﾝｸに戻す必要有り

DNM_MATH_ELSE_DATMK100:
	MOV.L	#_DNM_CTL_INC3600,R1		;//CAM、ﾛｯﾄｶｳﾝﾀ、荷重用
	MOV.W	R2,@R1				;

	SUB_END
	M_RTS

;	***********************************
;	***	2015-04-08		***
;	***	工程集終了ﾊﾝﾄﾞｼｪｲｸ	***
;	***********************************
_ENDHAND_WAIT_TIMCNT
	SUB_START

	MOV.L	#_CMPSTEP_STEP_END,R1		;
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_ON ENDHAND_WAIT_TIMC100		;[ﾆｱｾﾞﾛ確認が終わっている]
	MOV.W	#D'10,R2			;10msec
	MOV.L	#_ENDHAND_TIMOUT_PV,R1		;
	MOV.W	R2,@R1				;
	M_BRA	ENDHAND_WAIT_TIMC200

ENDHAND_WAIT_TIMC100
	DN_TIME LG=W,MEM_ADR=_ENDHAND_TIMOUT_PV,WKREG1=R1,WKREG2=R2	;
ENDHAND_WAIT_TIMC200
	SUB_END
	M_RTS

;	ANS R0!=0 ﾊﾝﾄﾞｼｪｲｸを強制実行
	.EXPORT	_API_ENDHAND_SIGCHK
_API_ENDHAND_SIGCHK
	SUB_START
	MOV.L	#_CMPSTEP_STEP_END,R1	;
	MOV.W	@R1,R0			;
	TST	#BIT2,R0		;
	TST_BIT_ON API_ENDHANDSIGCHK_EXT

	TST	#(BIT1+BIT0),R0			;
	TST_BIT_OF API_ENDHANDSIGCHK_100	;

	MOV.L	#_ENDHAND_TIMOUT_PV,R1		;
	MOV.W	@R1,R1				;
	TST	R1,R1				;
	TST_BIT_ON API_ENDHANDSIGCHK_EXT	;TIME ｱｯﾌﾟ前
API_ENDHANDSIGCHK_100
	XOR	R0,R0
API_ENDHANDSIGCHK_EXT

	SUB_END
	M_RTS

;	*******************************************
;	***					***
;	***					***
;	***					***
;	***	モーション繰り返し		***
;	***	位置決め部			***
;	***					***
;	*******************************************
;
;非常停止,ｻｲｸﾙ終了後の初起動時
;非常停止(exqは運転継続だからCLRしない)
;ｻｲｸﾙ終了
;ﾘﾋﾟｰﾄ終了
;[EXQはｸﾘｱしない：運転継続だから]
;
;BIT0(ﾘﾋﾟｰﾄ戻り中)
;BIT1(ﾚﾋﾟｰﾄ戻演算しろ)
;BIT2(ﾘﾋﾟｰﾄ戻り→ﾘﾋﾟｰﾄ開始)
;

	.ALIGN	4					;
_MOT_REP_CLR					;
	SUB_START
	XOR	R0,R0				;
	MOV.L	#_MOT_REP_CNT,R1		;
	MOV.W	R0,@R1				;
	MOV.L	#_MOT_REP_F,R1			;
	MOV.W	R0,@R1				;
	SUB_END
	M_RTS

;	-----------ｽﾃｯﾌﾟ終了時CHECK-------------
_MOT_REP_STEPCHK
	SUB_START

	MOV.L	#_SET1_MOTREP_USEFUL,R1		;
	MOV.W	@R1,R0				;
	TST	R0,R0				;
	TST_BIT_OF MOT_REP_STEPCK_EXT		;

	MOV.L	#_MOT_REP_F,R1			;
	MOV.W	@R1,R0				;
	TST	#BIT0,R0			;ﾘﾋﾟｰﾄ戻り実行中?
	TST_BIT_OF MOT_REP_STEPCK_100		;NO

	MOV.B	#BIT2,R0			;戻り開始工程演算しろ
	MOV.L	#_MOT_REP_F,R1			;BIT2:CLR
	MOV.W	R0,@R1				;


	FAR_JSR	#_DEBUG_BRK_POINT1,R0		;

	M_BRA	MOT_REP_STEPCK_EXT		;




MOT_REP_STEPCK_100
	MOV.L	#_INT_POS_CTL_STEP,R1		;//内部制御工程1~11
	MOV.W	@R1,R0				;
	MOV.L	#_SET1_MOTREP_STGE,R1		;//繰り返し終了行程[この工程は停止工程とする]
	MOV.W	@R1,R2				;
	CMP/EQ	R2,R0				;
	BF	MOT_REP_STEPCK_EXT		;終了ｽﾃｯﾌﾟ?

	MOV.L	#_SET1_MOTREP_CNT,R1		;//繰り返し回数
	MOV.W	@R1,R3				;
	TST	R3,R3				;
	TST_BIT_OF MOT_REP_STEPCK_EXT

	MOV.L	#_MOT_REP_CNT,R4		;
	MOV.W	@R4,R2				;
	CMP/HS	R3,R2				;設定<=CNT
	BT	MOT_REP_STEPCK_200		;終了
	ADD	#1,R2				;
	MOV.W	R2,@R4				;

;	------- 戻る----------
	MOV.B	#(BIT1+BIT0),R0			;戻り実行中、戻り演算しろ
	MOV.L	#_MOT_REP_F,R1			;
	MOV.W	R0,@R1				;
	M_BRA	MOT_REP_STEPCK_EXT		;


MOT_REP_STEPCK_200
	FAR_JSR	#_MOT_REP_CLR,R0		;

MOT_REP_STEPCK_EXT
	SUB_END
	M_RTS


_MOT_REPSTART_CALC:
	SUB_START

	MOV.L	#_SET1_MOTREP_SPD,R1		;//一定速度時の速度 
	MOV.L	@R1,R2				;
	MOV.L	#_LINK_SV_OBJ_SPDPLS,R1		;//目標速度
	MOV.L	R2,@R1				;


	FAR_JSR	#_POS_LSI_TOP_SPEED_SET,R1	;

	MOV.L	#_SET1_MOTREP_STGS,R4		;//繰り返し終了行程[この工程は停止工程とする]
	MOV.W	@R4,R0				;
	CMP/EQ	#1,R0				;
	BF	MOT_REPSTART_CL050		;
	MOV.L	#_CPOS_SDAT1_UP_POS,R4		;//待機点または各段
	MOV.L	@R4+,R1				;
	MOV.L	@R4,R2				;(目標位置)
	M_BRA	MOT_REPSTART_CL100		;

MOT_REPSTART_CL050:
	ADD	#-2,R0
	SHLL2	R0
	SHLL	R0
	MOV.L	#_CPOS_SDAT1_CHGAPOS,R4		;8byte
	ADD	R0,R4
	MOV.L	@R4+,R1				;
	MOV.L	@R4,R2				;(目標位置)
MOT_REPSTART_CL100:


;	--------- 反転用---------------
	MOV.L	#_NEG_CTL_OBJ_POS_PUSH,R4	;//abs停止目標位置(設定ﾊﾞｯｸﾗｯｼなし)
	MOV.L	R1,@R4				;
	MOV.L	R2,@(4,R4)			;save

	MOV.L	#_NEG_CTRL_BEFOR_OBJ_PLS,R4	;//目標−手前
	MOV.L	R1,@R4				;
	MOV.L	R2,@(4,R4)			;save

;	-------- 通常用-----------------
	FAR_JSR	#_LENGH_ADD_CALC,R0		;

	XOR	R3,R3				;
	CMP/PZ	R1				;+正転?
	BT	MOT_REPSTART_CL200		;
	MOV	#BIT0,R3			;
MOT_REPSTART_CL200:
	MOV.L	#_POSLSI_DRIV_SHIN,R1		;//BIT0
	MOV.W	@R1,R0				;
	AND	#LOW ~BIT0,R0			;
	OR	R3,R0				;
	MOV.W	R0,@R1				;
;	----------------------------------------

	SUB_END
	M_RTS

;	*******************************************
;	***					***
;	***					***
;	***					***
;	***	制動性能試験			***
;	***					***
;	***					***
;	*******************************************
	.ALIGN	4						;
	.INCLUDE	"ssa_btst.inc"		;//2010-08-30


;	*******************************************
;	***					***
;	***					***
;	***					***
;	***	ポジショナ- CPUA		***
;	***					***
;	***					***
;	*******************************************
	.ALIGN	4					;
	.INCLUDE	"ssa_cop1pos.inc"		; //























;	*******************************************
;	***					***
;	***					***
;	***					***
;	***	低速減速優先演算		***
;	***	2015-11-17			***
;	***					***
;	***					***
;	*******************************************
	.EXPORT	_ACCLW_DATA_MAIN		;
	.EXPORT	_API_ACCLW_DRV_START1		;
	.EXPORT	_API_ACCLW_DRV_STOP		;
	.EXPORT	_ACCLW_CTRL_CALC		;


	.INCLUDE	"ssa_aclw.inc"		;//2010-09-21ふりこテーブル演算












;	**********************************************************
;	***							***
;	***							***
;	***							***
;	***							***
;	***	CPUBの高速化「以下にはプログラム追加しないこと」***
;	***	2013-03-15					***
;	***							***
;	***	A5007000~A5008FFFまで				***
;	***	[PHiRAM]					***
;	***							***
;	***							***
;	***********************************************************
	.ALIGN	4					;
	.AIF	_SIT_CPU_SEL EQ _SIT4_CPUB		;
	.SECTION	PHiROM,CODE			;
	.AENDI						;

;
;
;
;
;
	.ALIGN	4						;
;	*******************************************
;	***					***
;	***	2006-09-19			***
;	***					***
;	***	ﾊﾟﾙｽ管理			***
;	***	(位置決め部分での処理)		***
;	***					***
;	*******************************************
;	Input :現在位置(出力ﾊﾟﾙｽ側)    [8byte]
;	Input :最終停止位置(出力ﾊﾟﾙｽ上)[8byte]
;	Input :設定速度(0.01%単位)     [4byte]
;	Input :制御周期 TIME-LATE:1/1000
;	Input :加速度(0.001%/s/s)[4byte]
;	Input :
;	Input :処理状態：起動/減速停止/処理継続
;	Output:加速度書換え
;
;	*******************************************
;	***					***
;	***					***
;	***		主制御			***
;	***	(ここは標準・ふりこ共通)	***
;	***					***
;	***					***
;	*******************************************
;_POSCTL_STEP_FLG BIT0 ACTIVE
;		  BIT1 減速ｺﾏﾝﾄﾞ
;		  BIT2 最終減速ﾗｯﾁ：解除は目標位置変更
;		  BIT6:END	
	.ALIGN	4				;
_PLS_LSI_CTRL:
	SUB_START


;	---------------最終目標位置-----------
	MOV.L	#_LINK_SV_OBJ_ABSPLS,R4			;LINKX_SV_OBJ_ABSPLSの場合があるかも
	MOV.L	@R4+,R1					;
	MOV.L	@R4,R2					;
	MOV.L	#_POSCTL_SV_PLS,R4			;SV
	MOV.L	@(0,R4),R5				;
	MOV.L	@(4,R4),R6				;
	MOV.L	R1,@(0,R4)				;
	MOV.L	R2,@(4,R4)				;

	XOR	R1,R5					
	XOR	R2,R6					;
	OR	R5,R6					;
	TST	R6,R6					;
	TST_BIT_OF PLS_LSICTRL_050			;
	MEM1_BIT0_TO_BIT7_ANDCLR MEM=_POSCTL_STEP_FLG,LG=W,BIT=~BIT2,WKREG=R1	;
	
PLS_LSICTRL_050			;


;	---------------リアルタイム目標位置-----------
	MOV.L	#_LINK_RL_OBJ_ABSPLS,R4			;
	MOV.L	@R4+,R1					;
	MOV.L	@R4,R2					;
	MOV.L	#_POSCTL_RL_PLS,R4			;RL
	MOV.L	R1,@(0,R4)				;
	MOV.L	R2,@(4,R4)				;


;	==================================================
	MOV.L	#_POS_HLDSTOP1_FLG,R1			;
	MOV.W	@R1,R0					;
	TST	#BIT0,R0				;HOLD減速
	TST_BIT_OF PLS_LSICTRL_070			;

;	---------------------------------
	MOV.L	#_POSHLD_SET_DN_ACC,R1			;//位置決めキャンセル減速
	MOV.L	@R1,R2					;
	MOV.L	#_POSCTL_SV_DN_ACC,R1			;
	MOV.L	R2,@R1					;
	M_BRA	PLS_LSICTRL_080				;

PLS_LSICTRL_070					;
;	--------- ｵｰﾊﾞﾗｲﾄﾞ転送---- -----------
	MEM_MOV_TO_MEM	_SET_UP_ACC_LATE,L,_POSCTL_SV_UP_ACC,L,R1,R2,R3	;
	MEM_MOV_TO_MEM	_SET_DN_ACC_LATE,L,_POSCTL_SV_DN_ACC,L,R1,R2,R3	;

PLS_LSICTRL_080					;

;	-------------------------------------------
;	---		2015-11-17		---
;	-------------------------------------------
	MOV.L	#_POSCTL_SET_SPD,R3			;速度
	MOV.L	@R3,R2					;

	FAR_JSR	#_ACCLW_CTRL_CALC,R0			;2015-11-17 減速選択
							;INPUT R2-OUTPUT R2

;;;2015-11-17	MOV.L	#_POSCTL_SET_SPD,R3		;速度
;;;2015-11-17	MOV.L	@R3,R2				;
;	-------------------------------------------

	FAR_JSR	#_OVER_LIDE_SPD_CALC,R0			;INPUT R2-OUTPUT R2


;	-------------2013-02-15 速度上限制限[ここはふりこも共通]-----------------------
	FAR_JSR	#_SPD_UPLIMT_CALC,R0			;INPUT R2-OUTPUT R2
;	--------------------------------------------------------------

	FAR_JSR	#_CNT_REST_HOSEI_SPD_TYP,R0		;INPUT R2 OUTPUT R2


	MOV.L	#_POSCTL_SV_SPD,R1			;
	MOV.L	R2,@R1					;

;	========== 管理=============
	MOV.L	#_POSCTL_STEP_FLG,R1			;//0(IDLE) BIT0/BIT6 (BIT2,3,4 減速関連)
	MOV.W	@R1,R0					;
	TST	#BIT6,R0				;終了?
	TST_BIT_ON PLS_LSICTRL_END			;

	TST	#BIT0,R0				;ACTIVE
	TST_BIT_ON PLS_LSICTRL_100			;

;	--- 停止中---
	MOV.L	#_POSCTL_STEP_CMD,R1			;
	MOV.W	@R1,R0					;
	CMP/EQ	#1,R0					;起動?
	BF	PLS_LSICTRL_END				;NO

	FAR_JSR	#_PLS_LSI_CTL_INI,R0			;起動
	MOV.W	#BIT0,R0				;
	REG_MOV_TO_MEM	DST_ADR=_POSCTL_STEP_FLG,L1=W,DT_REG=R0,WKREG1=R1

PLS_LSICTRL_100:
	MOV.L	#_POSCTL_STEP_CMD,R1			;//3:EMG停止(速度=0) 1:起動ｺﾏﾝﾄﾞ 2:(減速停止)
	MOV.W	@R1,R0					;EMG-STOP
	CMP/EQ	#3,R0					;
	BF	PLS_LSICTRL_200				;

	XOR	R0,R0					;
	REG_MOV_TO_MEM	DST_ADR=_POSCTL_STEP_FLG,L1=W,DT_REG=R0,WKREG1=R1
	REG_MOV_TO_MEM	DST_ADR=_POSCTL_STEP_CMD,L1=W,DT_REG=R0,WKREG1=R1

	FAR_JSR	#_PLS_LSI_SPEED_OFF,R0			;
	M_BRA	PLS_LSICTRL_END				;

PLS_LSICTRL_200:

;	----------- ふりこ加減速と通常加減速を分ける---
;;;;2010-09-27 ふりこのため	FAR_JSR	#_PLS_LSI_CTL_CALC,R0			;

	MOV.L	#_DNM_ACC_CALFLG,R1		;//0/1
	MOV.W	@R1,R0				;
	CMP/EQ	#1,R0				;
	BF	PLS_LSICTRL_220			;
	FAR_JSR	#_DNM_PLS_LSICTL_CALC,R0	;
	M_BRA	PLS_LSICTRL_END			;ふりこ加減速

PLS_LSICTRL_220:
	FAR_JSR	#_PLS_LSI_CTL_CALC,R0		;通常減速

PLS_LSICTRL_END:

;	-------- 2013-07-18 DEBUG ----------
;;;;;;;;;;;;;;;;	MOV.L	#_POSCTL_CALC_ERR,R1			;BIT0:起動時
;;;;;;;;;;;;;;;;	MOV.W	@R1,R0					;BIT1:減速時
;;;;;;;;;;;;;;;;	MOV.L	#_SQ_CBWK_TOP+_WKSQCB239,R1		;
;;;;;;;;;;;;;;;;	MOV.W	R0,@R1					;

	SUB_END
	M_RTS

;	*******************************************
;	***					***
;	***					***
;	***		加減速演算		***
;	***					***
;	***					***
;	***					***
;	*******************************************

	.ALIGN	4				;
_PLS_LSI_CTL_CALC:
	SUB_START

;	--------- 2010-09-27 残りパルス演算の共通化----
	FAR_JSR	#_ACC_REST_INFO_MAKE,R0


	MOV.L	#_POSCTL_STEP_FLG,R1						;//0(IDLE) BIT0/BIT6 END (BIT1 LATCH)
	MOV.W	@R1,R0								;
	TST	#BIT1,R0							;
	TST_BIT_ON PLS_LSI_CTLCAL_020						;強制減速停止中(寸動停止)
	TST	#BIT2,R0							;
	TST_BIT_ON PLS_LSI_CTLCAL_050						;最終減速状態YES
	M_BRA	PLS_LSI_CTLCAL_100						;

PLS_LSI_CTLCAL_020
;	--- 減速コマンドラッチ---
	MOV.L	#_POSCTL_SV_OFS_SPD,R1						;//自起動 PLS/S
	MOV.L	@R1,R2								;
	MOV.L	#_POSCTL_RL_SPD,R5						;
	MOV.L	@R5,R3								;
	CMP/HI	R2,R3								;R2(SV) < R3(NOW)
	BT	PLS_LSI_CTLCAL_050						;YES
	M_BRA	PLS_LSI_CTLCAL_800						;(減速停止)終了処理
PLS_LSI_CTLCAL_050:
	M_BRA	PLS_LSI_CTLCAL_700						;減速処理

PLS_LSI_CTLCAL_100:
	MOV.L	#_POSCTL_STEP_CMD,R1						;//3:EMG停止(速度=0) 1:起動ｺﾏﾝﾄﾞ 2:(減速停止)
	MOV.W	@R1,R0								;EMG-STOP
	CMP/EQ	#2,R0								;減速停止
	BF	PLS_LSI_CTLCAL_150						;NO
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POSCTL_STEP_FLG,LG=W,BIT=BIT1,WKREG=R1	;強制減速停止指令(寸動停止)
	M_BRA	PLS_LSI_CTLCAL_500						;

;-------通常制御----
PLS_LSI_CTLCAL_150:
	MOV.L	#_INT_CLS_CTL_FLG,R1						;
	MOV.W	@R1,R0								;
	TST	#BIT0,R0							;
	TST_BIT_OF PLS_LSI_CTLCAL_160						;
;	-----------やるべきことが今一不明--------
	M_BRA	PLS_LSI_CTLCAL_EXT						;


PLS_LSI_CTLCAL_160:

;<<<2010-09-21>>>
	FAR_JSR	#_CMP_POSLSI_CTLGENSOK,R0					;<<<2010-09-21>>>

	TST	R0,R0								;
	TST_BIT_OF PLS_LSI_CTLCAL_500
	CMP/EQ	#1,R0								;
	BT	PLS_LSI_CTLCAL_700
;	----- ABNOMAL CALC------						;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POSCTL_CALC_ERR,LG=W,BIT=BIT1,WKREG=R4	;
	M_BRA	PLS_LSI_CTLCAL_700
;;;;;;	M_BRA	PLS_LSI_CTLCAL_ERR	手動ﾊﾟﾙｻでうまくいかない 2013-06-20

;	===== 距離がありそう =====
PLS_LSI_CTLCAL_500:								;
;<<<2010-09-21>>>
;;;;;;2015-03-10	FAR_JSR	#_PLS_LSI_SPD_ACC_ADD,R0					;<<<2010-09-21>>>
;;;;;;2015-03-10
;;;;;;2015-03-10	TST	R0,R0								;
;;;;;;2015-03-10	TST_BIT_OF PLS_LSI_CTLCAL_EXT						;書き換えない
;;;;;;2015-03-10	FAR_JSR	#_PLS_LSI_CTL_SPDSET,R0						;LSI SET
;;;;;;2015-03-10	M_BRA	PLS_LSI_CTLCAL_900						;

;	--------- 自起動速度設定の動作も対応[各機種共通事項]-----------
	FAR_JSR	#_PLS_LSI_SPD_ACC_ADD,R0					;<<<2010-09-21>>>
	TST	R0,R0								;
	TST_BIT_ON PLS_LSI_CTLCAL_580

;	---払い出し完了ならやめる---------
	FAR_JSR	#_LOD_POS_STS_REG_IN,R0		;
	TST	#BIT2,R0			;停止?
	TST_BIT_ON PLS_LSI_CTLCAL_800		;YES:
	M_BRA	PLS_LSI_CTLCAL_EXT		;

PLS_LSI_CTLCAL_580:
	FAR_JSR	#_PLS_LSI_CTL_SPDSET,R0						;LSI SET
	M_BRA	PLS_LSI_CTLCAL_900						;



;------------最終減速処理(自動・手動ともこの演算を行なう)----------
PLS_LSI_CTLCAL_700:
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POSCTL_STEP_FLG,LG=W,BIT=BIT2,WKREG=R1	;減速中
;	---払い出し完了ならやめる---------
	FAR_JSR	#_LOD_POS_STS_REG_IN,R0		;
	TST	#BIT2,R0			;停止?
	TST_BIT_ON PLS_LSI_CTLCAL_820		;YES:ﾌﾗｸﾞ終了

;<<<2010-09-21>>>
;	----ここにきたら目標位置が変わるまで加速はしない------
	MOV.L	#_POSCTL_RL_SPD,R5		;
	MOV.L	@R5,R2				;
	MOV.L	#_POSCTL_SV_DN_ACC,R4		;
	MOV.L	@R4,R3				;
	TST	R3,R3				;
	TST_BIT_ON PLS_LSI_CTLCAL_720		;
	MOV	#1,R3				;
PLS_LSI_CTLCAL_720:				;
	SUB	R3,R2				;
	CMP/PZ	R2				;
	BT	PLS_LSI_CTLCAL_740		;
	XOR	R2,R2				;
PLS_LSI_CTLCAL_740:				;



	MOV.L	#_POSCTL_SV_OFS_SPD,R1		;
	MOV.L	@R1,R3				;
	CMP/HI	R3,R2				;
	BT	PLS_LSI_CTLCAL_760		;OFS < CALC
	MOV	R3,R2				;MNINLINIT
;	-------------------
	MOV.L	#_POSCTL_STEP_FLG,R1		;
	MOV.W	@R1,R0				;
	TST	#BIT1,R0			;手動減速中
	TST_BIT_ON PLS_LSI_CTLCAL_800		;

PLS_LSI_CTLCAL_760:				;
	MOV.L	R2,@R5				;
	FAR_JSR	#_PLS_LSI_CTL_SPDSET,R0		;LSI SET
	M_BRA	PLS_LSI_CTLCAL_900		;

;	-------------終了処理(STEP STOP)----------
PLS_LSI_CTLCAL_800:
	FAR_JSR	#_PLS_LSI_SPEED_OFF,R0						;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POSCTL_STEP_FLG,LG=W,BIT=BIT5,WKREG=R1	;DEBUG
PLS_LSI_CTLCAL_820:
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POSCTL_STEP_FLG,LG=W,BIT=BIT6,WKREG=R1	;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POSCTL_STEP_FLG,LG=W,BIT=BIT3,WKREG=R1	;DEBUG

	.AIF	_CB_CPU_SEL EQ	_CB_CPUA

	FAR_JSR	#_VIB_PLS_OUT_OF,R0	;2010-08-23加振動制御
	.AENDI

PLS_LSI_CTLCAL_900:
	M_BRA	PLS_LSI_CTLCAL_EXT						;

PLS_LSI_CTLCAL_ERR:
	FAR_JSR	#_PLS_LSI_SPEED_OFF,R0						;
	MEM1_BIT0_TO_BIT7_ORSET MEM=_POSCTL_STEP_FLG,LG=W,BIT=BIT6,WKREG=R1	;

PLS_LSI_CTLCAL_EXT:






	SUB_END
	M_RTS

;	*******************************************
;	***					***
;	***					***
;	***		加速・減速		***
;	***					***
;	***					***
;	***					***
;	*******************************************
;
;	ANS R0:0ﾃﾞｰﾀ変更なし R0:1ﾃﾞｰﾀ変更有り
;
	.ALIGN	4				;
_PLS_LSI_SPD_ACC_ADD:
	SUB_START
	XOR	R0,R0						;
	MOV.L	#_POSCTL_SV_SPD,R1				;
	MOV.L	@R1,R3						;
	MOV.L	#_POSCTL_RL_SPD,R5				;
	MOV.L	@R5,R2						;
	CMP/EQ	R2,R3						;
	BT	PLS_LSI_SPD_ACCADD_END				;SV=REAL
	CMP/GE	R2,R3						;R2<R3
	BF	PLS_LSI_SPD_ACCADD_200					;NO 減速しろ
;	---加速しろ----
	MOV.L	#_POSCTL_SV_UP_ACC,R4					;500,000/1000
	MOV.L	@R4,R1							;
	ADD	R1,R2
	CMP/GT	R2,R3							;
	BT	PLS_LSI_SPD_ACCADD_300					;R2<R3(SV) THEN そのまま加速
	MOV	R3,R2							;SV→REAL
	M_BRA	PLS_LSI_SPD_ACCADD_300					;

PLS_LSI_SPD_ACCADD_200:
;	---減速しろ---
	MOV.L	#_POSCTL_SV_DN_ACC,R4					;500,000/1000
	MOV.L	@R4,R1							;
	SUB	R1,R2							;
	CMP/GT	R3,R2							;
	BT	PLS_LSI_SPD_ACCADD_300					;R3<R2
	MOV	R3,R2							;
PLS_LSI_SPD_ACCADD_300:							;
	MOV.L	R2,@R5							;
	MOV	#1,R0							;
PLS_LSI_SPD_ACCADD_END:
	SUB_END
	M_RTS




;	*******************************************
;	***					***
;	***	Input R1,R2(残り距離)		***
;	***	Input R9:SPEED  DATA		***
;	***	Input R10:OFFSET SPEED		***
;	***	Input R11:ACC_LATE		***
;	***					***
;	*******************************************
;	ANS
;	00:KEEP
;	01:STOP
;	-1:ERR
;
	.ALIGN	4				;
_CMP_SPD_REST_PLSCHKCOM:
	SUB_START
	CMP/PZ	R1						;
	BT	CMPSPD_RSTPLS_250				;NOMAL
;	----- ABNOMAL CALC------				;
	M_BRA	CMP_SPD_REST_ERR				;

CMPSPD_RSTPLS_250:

	TST	R1,R1						;
	TST_BIT_OF CMPSPD_RSTPLS_280				;
	M_BRA	CMP_SPD_REST_MOV				;まだまだ残り距離がある(32bit以上残り距離がある)
CMPSPD_RSTPLS_280:
	MOV.L	#_GENSOK_LNGTH_MAX,R4				;30秒*500KHよりも距離がある
	CMP/GE	R4,R2						;
	BT	CMP_SPD_REST_MOV				;減速距離がまだまだ大きい(連続でもありえない)
;	---------------------------------------------------

;	-------減速距離比較------------
;	(R2:距離S)
;;	MOV.L	#_POSCTL_SV_DN_ACC,R4					;500,000/1000
;;	MOV.L	@R4,R11							;

	MOV.W	#_ACC_UNIT,R4						;α:(PLS/1000)/s/s
	DMULS.L	R4,R11							;α'=α*1000
	STS	MACL,R3							;
	ADD	R3,R3							;2*α*1000

	DMULS.L	R2,R3							;2*α'*S
	STS	MACL,R8							;
	STS	MACH,R7							;R7,R8=2*α*S
;;	MOV.L	#_POSCTL_SV_OFS_SPD,R4					;
;;	MOV.L	@R4,R10							;
	DMULS.L	R10,R10							;
	STS	MACL,R2							;
	STS	MACH,R1							;
	ADD8B DT_REGH=R7,DT_REGL=R8,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;R1,R2=2*α*S+β*β

;加速しないならこれでよい。
;この状態で演算し、且つ加速した結果でも演算する必要がある。		;
;;	MOV.L	#_POSCTL_RL_SPD,R4					;
;;	MOV.L	@R4,R9							;
	DMULS.L	R9,R9							;V*V
	STS	MACL,R6							;
	STS	MACH,R5							;R5,R6=V*V

	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;2*α*S+β*β - V*V
	CMP/PZ	R1							;
	BT	CMP_SPD_REST_MOV					;
	M_BRA	CMP_SPD_REST_STOP					;

CMP_SPD_REST_MOV:
	XOR	R0,R0
	M_BRA	CMP_SPD_REST_END

;	====== 減速開始すべき位置======
CMP_SPD_REST_ERR:
	MOV	#-1,R0
	M_BRA	CMP_SPD_REST_END	;
CMP_SPD_REST_STOP:
	MOV	#1,R0
CMP_SPD_REST_END:
	SUB_END
	M_RTS



;	***************************************************
;	***						***
;	***		残距離作成			***
;	***		2010-09-22			***
;	***		演算の簡略化			***
;	***						***
;	***************************************************
	.ALIGN	4				;
_ACC_REST_INFO_MAKE
	SUB_START
;	----------- 設定目標位置	---------
	MOV.L	#_POSCTL_SV_PLS,R4					;SV
	MOV.L	@(0,R4),R1						;
	MOV.L	@(4,R4),R2						;

;	---------------リアルタイム目標位置-----------
	MOV.L	#_POSCTL_RL_PLS,R4					;RL
	MOV.L	@(0,R4),R5						;
	MOV.L	@(4,R4),R6						;
	SUB8B DT_REGH=R5,DT_REGL=R6,DT_ANS_REGH=R1,DT_ANS_REGL=R2	;目標-実測

	MOV.L	#_POSLSI_DRIV_SHIN,R4					;
	MOV.W	@R4,R0							;
	TST	#BIT0,R0						;
	TST_BIT_OF ACC_REST_INFMK_100					;正転
	NEG1_64	H_REG=R1,L_REG=R2,WKREG=R0				;|R1,R2|
ACC_REST_INFMK_100							;正転

	MOV.L	#_ACC_REST_ABS_PLS,R5	;
	MOV.L	R1,@R5			;
	MOV.L	R2,@(4,R5)		;


	XOR	R0,R0
	TST	R1,R1					;8byteの上位4byteがあるか？
	TST_BIT_ON ACC_REST_INFMK_200			;まだ4BYTE以上ある

	MOV.L	#_GENSOK_LNGTH_MAX,R4				;30秒*500KHよりも距離がある
	CMP/GE	R4,R2						;
	BT	ACC_REST_INFMK_200				;減速距離がまだまだ大きい(連続でもありえない)

	MOV.B	#-1,R0						;4BYTE以下なので減速演算してもいい
							;演算オーバフロー対策

ACC_REST_INFMK_200							;
	MOV.L	#_ACC_REST_FLG,R4					;
	MOV.W	R0,@R4							;0:まだまだ距離が十分ある

	SUB_END
	M_RTS

;	*******************************************
;	***					***
;	***					***
;	***					***
;	***	振り子加速・減速演算		***
;	***					***
;	***					***
;	*******************************************
	.EXPORT	_DNM_TBL_CALC	
	.EXPORT	_DNM_START_ACC_CALC	
	.EXPORT	_DNM_STEP_ACC_CHANGE	

	.EXPORT	_DNM_SPD_CALC	
	.EXPORT	_DNM_ACC_CALC	
	.IMPORT	_DATA_CMP2B_R5R6_REF		;DTMK

;	===================================
;	===  SCURVが有効であれば生かす	===
;	===================================

	.EXPORT	_USE_IN_TBL_MOV			;
	.INCLUDE	"ssa_acct.inc"		;//2010-09-21ふりこテーブル演算


;	***********************************************************
;	***							***
;	***	CPUBの高速化「以下にはプログラム追加しないこと」***
;	***	2013-03-15					***
;	***********************************************************


;	***************************************************
;	***						***
;	***		CPUBの高速化終了		***
;	***		2013-03-15			***
;	***						***
;	***************************************************
	.ALIGN	4					;
	.AIF	_SIT_CPU_SEL EQ _SIT4_CPUB		;
	.SECTION	P,CODE				;
	.AENDI						;



	.END
